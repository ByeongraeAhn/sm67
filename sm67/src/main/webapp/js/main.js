// ======================================================================//
// ======================================================================//
// ======================================================================//
//
// PLUGIN
//
// ======================================================================//
// ======================================================================//
// ======================================================================//
/*! jQuery v2.1.3 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
! function(a, b) {
  "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
    if (!a.document) throw new Error("jQuery requires a window with a document");
    return b(a)
  } : b(a)
}("undefined" != typeof window ? window : this, function(a, b) {
  var c = [],
    d = c.slice,
    e = c.concat,
    f = c.push,
    g = c.indexOf,
    h = {},
    i = h.toString,
    j = h.hasOwnProperty,
    k = {},
    l = a.document,
    m = "2.1.3",
    n = function(a, b) {
      return new n.fn.init(a, b)
    },
    o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    p = /^-ms-/,
    q = /-([\da-z])/gi,
    r = function(a, b) {
      return b.toUpperCase()
    };
  n.fn = n.prototype = {
    jquery: m,
    constructor: n,
    selector: "",
    length: 0,
    toArray: function() {
      return d.call(this)
    },
    get: function(a) {
      return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this)
    },
    pushStack: function(a) {
      var b = n.merge(this.constructor(), a);
      return b.prevObject = this, b.context = this.context, b
    },
    each: function(a, b) {
      return n.each(this, a, b)
    },
    map: function(a) {
      return this.pushStack(n.map(this, function(b, c) {
        return a.call(b, c, b)
      }))
    },
    slice: function() {
      return this.pushStack(d.apply(this, arguments))
    },
    first: function() {
      return this.eq(0)
    },
    last: function() {
      return this.eq(-1)
    },
    eq: function(a) {
      var b = this.length,
        c = +a + (0 > a ? b : 0);
      return this.pushStack(c >= 0 && b > c ? [this[c]] : [])
    },
    end: function() {
      return this.prevObject || this.constructor(null)
    },
    push: f,
    sort: c.sort,
    splice: c.splice
  }, n.extend = n.fn.extend = function() {
    var a, b, c, d, e, f, g = arguments[0] || {},
      h = 1,
      i = arguments.length,
      j = !1;
    for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)
      if (null != (a = arguments[h]))
        for (b in a) c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));
    return g
  }, n.extend({
    expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
    isReady: !0,
    error: function(a) {
      throw new Error(a)
    },
    noop: function() {},
    isFunction: function(a) {
      return "function" === n.type(a)
    },
    isArray: Array.isArray,
    isWindow: function(a) {
      return null != a && a === a.window
    },
    isNumeric: function(a) {
      return !n.isArray(a) && a - parseFloat(a) + 1 >= 0
    },
    isPlainObject: function(a) {
      return "object" !== n.type(a) || a.nodeType || n.isWindow(a) ? !1 : a.constructor && !j.call(a.constructor.prototype, "isPrototypeOf") ? !1 : !0
    },
    isEmptyObject: function(a) {
      var b;
      for (b in a) return !1;
      return !0
    },
    type: function(a) {
      return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a
    },
    globalEval: function(a) {
      var b, c = eval;
      a = n.trim(a), a && (1 === a.indexOf("use strict") ? (b = l.createElement("script"), b.text = a, l.head.appendChild(b).parentNode.removeChild(b)) : c(a))
    },
    camelCase: function(a) {
      return a.replace(p, "ms-").replace(q, r)
    },
    nodeName: function(a, b) {
      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
    },
    each: function(a, b, c) {
      var d, e = 0,
        f = a.length,
        g = s(a);
      if (c) {
        if (g) {
          for (; f > e; e++)
            if (d = b.apply(a[e], c), d === !1) break
        } else
          for (e in a)
            if (d = b.apply(a[e], c), d === !1) break
      } else if (g) {
        for (; f > e; e++)
          if (d = b.call(a[e], e, a[e]), d === !1) break
      } else
        for (e in a)
          if (d = b.call(a[e], e, a[e]), d === !1) break; return a
    },
    trim: function(a) {
      return null == a ? "" : (a + "").replace(o, "")
    },
    makeArray: function(a, b) {
      var c = b || [];
      return null != a && (s(Object(a)) ? n.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c
    },
    inArray: function(a, b, c) {
      return null == b ? -1 : g.call(b, a, c)
    },
    merge: function(a, b) {
      for (var c = +b.length, d = 0, e = a.length; c > d; d++) a[e++] = b[d];
      return a.length = e, a
    },
    grep: function(a, b, c) {
      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
      return e
    },
    map: function(a, b, c) {
      var d, f = 0,
        g = a.length,
        h = s(a),
        i = [];
      if (h)
        for (; g > f; f++) d = b(a[f], f, c), null != d && i.push(d);
      else
        for (f in a) d = b(a[f], f, c), null != d && i.push(d);
      return e.apply([], i)
    },
    guid: 1,
    proxy: function(a, b) {
      var c, e, f;
      return "string" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (e = d.call(arguments, 2), f = function() {
        return a.apply(b || this, e.concat(d.call(arguments)))
      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0
    },
    now: Date.now,
    support: k
  }), n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
    h["[object " + b + "]"] = b.toLowerCase()
  });

  function s(a) {
    var b = a.length,
      c = n.type(a);
    return "function" === c || n.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a
  }
  var t = function(a) {
    var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date,
      v = a.document,
      w = 0,
      x = 0,
      y = hb(),
      z = hb(),
      A = hb(),
      B = function(a, b) {
        return a === b && (l = !0), 0
      },
      C = 1 << 31,
      D = {}.hasOwnProperty,
      E = [],
      F = E.pop,
      G = E.push,
      H = E.push,
      I = E.slice,
      J = function(a, b) {
        for (var c = 0, d = a.length; d > c; c++)
          if (a[c] === b) return c;
        return -1
      },
      K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
      L = "[\\x20\\t\\r\\n\\f]",
      M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
      N = M.replace("w", "w#"),
      O = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + N + "))|)" + L + "*\\]",
      P = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + O + ")*)|.*)\\)|)",
      Q = new RegExp(L + "+", "g"),
      R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"),
      S = new RegExp("^" + L + "*," + L + "*"),
      T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"),
      U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"),
      V = new RegExp(P),
      W = new RegExp("^" + N + "$"),
      X = {
        ID: new RegExp("^#(" + M + ")"),
        CLASS: new RegExp("^\\.(" + M + ")"),
        TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
        ATTR: new RegExp("^" + O),
        PSEUDO: new RegExp("^" + P),
        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
        bool: new RegExp("^(?:" + K + ")$", "i"),
        needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
      },
      Y = /^(?:input|select|textarea|button)$/i,
      Z = /^h\d$/i,
      $ = /^[^{]+\{\s*\[native \w/,
      _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      ab = /[+~]/,
      bb = /'|\\/g,
      cb = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"),
      db = function(a, b, c) {
        var d = "0x" + b - 65536;
        return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
      },
      eb = function() {
        m()
      };
    try {
      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType
    } catch (fb) {
      H = {
        apply: E.length ? function(a, b) {
          G.apply(a, I.call(b))
        } : function(a, b) {
          var c = a.length,
            d = 0;
          while (a[c++] = b[d++]);
          a.length = c - 1
        }
      }
    }

    function gb(a, b, d, e) {
      var f, h, j, k, l, o, r, s, w, x;
      if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], k = b.nodeType, "string" != typeof a || !a || 1 !== k && 9 !== k && 11 !== k) return d;
      if (!e && p) {
        if (11 !== k && (f = _.exec(a)))
          if (j = f[1]) {
            if (9 === k) {
              if (h = b.getElementById(j), !h || !h.parentNode) return d;
              if (h.id === j) return d.push(h), d
            } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j) return d.push(h), d
          } else {
            if (f[2]) return H.apply(d, b.getElementsByTagName(a)), d;
            if ((j = f[3]) && c.getElementsByClassName) return H.apply(d, b.getElementsByClassName(j)), d
          }
        if (c.qsa && (!q || !q.test(a))) {
          if (s = r = u, w = b, x = 1 !== k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
            o = g(a), (r = b.getAttribute("id")) ? s = r.replace(bb, "\\$&") : b.setAttribute("id", s), s = "[id='" + s + "'] ", l = o.length;
            while (l--) o[l] = s + rb(o[l]);
            w = ab.test(a) && pb(b.parentNode) || b, x = o.join(",")
          }
          if (x) try {
            return H.apply(d, w.querySelectorAll(x)), d
          } catch (y) {} finally {
            r || b.removeAttribute("id")
          }
        }
      }
      return i(a.replace(R, "$1"), b, d, e)
    }

    function hb() {
      var a = [];

      function b(c, e) {
        return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e
      }
      return b
    }

    function ib(a) {
      return a[u] = !0, a
    }

    function jb(a) {
      var b = n.createElement("div");
      try {
        return !!a(b)
      } catch (c) {
        return !1
      } finally {
        b.parentNode && b.parentNode.removeChild(b), b = null
      }
    }

    function kb(a, b) {
      var c = a.split("|"),
        e = a.length;
      while (e--) d.attrHandle[c[e]] = b
    }

    function lb(a, b) {
      var c = b && a,
        d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);
      if (d) return d;
      if (c)
        while (c = c.nextSibling)
          if (c === b) return -1;
      return a ? 1 : -1
    }

    function mb(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return "input" === c && b.type === a
      }
    }

    function nb(a) {
      return function(b) {
        var c = b.nodeName.toLowerCase();
        return ("input" === c || "button" === c) && b.type === a
      }
    }

    function ob(a) {
      return ib(function(b) {
        return b = +b, ib(function(c, d) {
          var e, f = a([], c.length, b),
            g = f.length;
          while (g--) c[e = f[g]] && (c[e] = !(d[e] = c[e]))
        })
      })
    }

    function pb(a) {
      return a && "undefined" != typeof a.getElementsByTagName && a
    }
    c = gb.support = {}, f = gb.isXML = function(a) {
      var b = a && (a.ownerDocument || a).documentElement;
      return b ? "HTML" !== b.nodeName : !1
    }, m = gb.setDocument = function(a) {
      var b, e, g = a ? a.ownerDocument || a : v;
      return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = g.documentElement, e = g.defaultView, e && e !== e.top && (e.addEventListener ? e.addEventListener("unload", eb, !1) : e.attachEvent && e.attachEvent("onunload", eb)), p = !f(g), c.attributes = jb(function(a) {
        return a.className = "i", !a.getAttribute("className")
      }), c.getElementsByTagName = jb(function(a) {
        return a.appendChild(g.createComment("")), !a.getElementsByTagName("*").length
      }), c.getElementsByClassName = $.test(g.getElementsByClassName), c.getById = jb(function(a) {
        return o.appendChild(a).id = u, !g.getElementsByName || !g.getElementsByName(u).length
      }), c.getById ? (d.find.ID = function(a, b) {
        if ("undefined" != typeof b.getElementById && p) {
          var c = b.getElementById(a);
          return c && c.parentNode ? [c] : []
        }
      }, d.filter.ID = function(a) {
        var b = a.replace(cb, db);
        return function(a) {
          return a.getAttribute("id") === b
        }
      }) : (delete d.find.ID, d.filter.ID = function(a) {
        var b = a.replace(cb, db);
        return function(a) {
          var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
          return c && c.value === b
        }
      }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
        return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0
      } : function(a, b) {
        var c, d = [],
          e = 0,
          f = b.getElementsByTagName(a);
        if ("*" === a) {
          while (c = f[e++]) 1 === c.nodeType && d.push(c);
          return d
        }
        return f
      }, d.find.CLASS = c.getElementsByClassName && function(a, b) {
        return p ? b.getElementsByClassName(a) : void 0
      }, r = [], q = [], (c.qsa = $.test(g.querySelectorAll)) && (jb(function(a) {
        o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\f]' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]")
      }), jb(function(a) {
        var b = g.createElement("input");
        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:")
      })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && jb(function(a) {
        c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", P)
      }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function(a, b) {
        var c = 9 === a.nodeType ? a.documentElement : a,
          d = b && b.parentNode;
        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
      } : function(a, b) {
        if (b)
          while (b = b.parentNode)
            if (b === a) return !0;
        return !1
      }, B = b ? function(a, b) {
        if (a === b) return l = !0, 0;
        var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
        return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === g || a.ownerDocument === v && t(v, a) ? -1 : b === g || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1)
      } : function(a, b) {
        if (a === b) return l = !0, 0;
        var c, d = 0,
          e = a.parentNode,
          f = b.parentNode,
          h = [a],
          i = [b];
        if (!e || !f) return a === g ? -1 : b === g ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;
        if (e === f) return lb(a, b);
        c = a;
        while (c = c.parentNode) h.unshift(c);
        c = b;
        while (c = c.parentNode) i.unshift(c);
        while (h[d] === i[d]) d++;
        return d ? lb(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0
      }, g) : n
    }, gb.matches = function(a, b) {
      return gb(a, null, null, b)
    }, gb.matchesSelector = function(a, b) {
      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b))) try {
        var d = s.call(a, b);
        if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d
      } catch (e) {}
      return gb(b, n, null, [a]).length > 0
    }, gb.contains = function(a, b) {
      return (a.ownerDocument || a) !== n && m(a), t(a, b)
    }, gb.attr = function(a, b) {
      (a.ownerDocument || a) !== n && m(a);
      var e = d.attrHandle[b.toLowerCase()],
        f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
      return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null
    }, gb.error = function(a) {
      throw new Error("Syntax error, unrecognized expression: " + a)
    }, gb.uniqueSort = function(a) {
      var b, d = [],
        e = 0,
        f = 0;
      if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
        while (b = a[f++]) b === a[f] && (e = d.push(f));
        while (e--) a.splice(d[e], 1)
      }
      return k = null, a
    }, e = gb.getText = function(a) {
      var b, c = "",
        d = 0,
        f = a.nodeType;
      if (f) {
        if (1 === f || 9 === f || 11 === f) {
          if ("string" == typeof a.textContent) return a.textContent;
          for (a = a.firstChild; a; a = a.nextSibling) c += e(a)
        } else if (3 === f || 4 === f) return a.nodeValue
      } else
        while (b = a[d++]) c += e(b);
      return c
    }, d = gb.selectors = {
      cacheLength: 50,
      createPseudo: ib,
      match: X,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: !0
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: !0
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        ATTR: function(a) {
          return a[1] = a[1].replace(cb, db), a[3] = (a[3] || a[4] || a[5] || "").replace(cb, db), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4)
        },
        CHILD: function(a) {
          return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || gb.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && gb.error(a[0]), a
        },
        PSEUDO: function(a) {
          var b, c = !a[6] && a[2];
          return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
        }
      },
      filter: {
        TAG: function(a) {
          var b = a.replace(cb, db).toLowerCase();
          return "*" === a ? function() {
            return !0
          } : function(a) {
            return a.nodeName && a.nodeName.toLowerCase() === b
          }
        },
        CLASS: function(a) {
          var b = y[a + " "];
          return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function(a) {
            return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "")
          })
        },
        ATTR: function(a, b, c) {
          return function(d) {
            var e = gb.attr(d, a);
            return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(Q, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0
          }
        },
        CHILD: function(a, b, c, d, e) {
          var f = "nth" !== a.slice(0, 3),
            g = "last" !== a.slice(-4),
            h = "of-type" === b;
          return 1 === d && 0 === e ? function(a) {
            return !!a.parentNode
          } : function(b, c, i) {
            var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
              q = b.parentNode,
              r = h && b.nodeName.toLowerCase(),
              s = !i && !h;
            if (q) {
              if (f) {
                while (p) {
                  l = b;
                  while (l = l[p])
                    if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                  o = p = "only" === a && !o && "nextSibling"
                }
                return !0
              }
              if (o = [g ? q.firstChild : q.lastChild], g && s) {
                k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2], l = n && q.childNodes[n];
                while (l = ++n && l && l[p] || (m = n = 0) || o.pop())
                  if (1 === l.nodeType && ++m && l === b) {
                    k[a] = [w, n, m];
                    break
                  }
              } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w) m = j[1];
              else
                while (l = ++n && l && l[p] || (m = n = 0) || o.pop())
                  if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (s && ((l[u] || (l[u] = {}))[a] = [w, m]), l === b)) break; return m -= e, m === d || m % d === 0 && m / d >= 0
            }
          }
        },
        PSEUDO: function(a, b) {
          var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || gb.error("unsupported pseudo: " + a);
          return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ib(function(a, c) {
            var d, f = e(a, b),
              g = f.length;
            while (g--) d = J(a, f[g]), a[d] = !(c[d] = f[g])
          }) : function(a) {
            return e(a, 0, c)
          }) : e
        }
      },
      pseudos: {
        not: ib(function(a) {
          var b = [],
            c = [],
            d = h(a.replace(R, "$1"));
          return d[u] ? ib(function(a, b, c, e) {
            var f, g = d(a, null, e, []),
              h = a.length;
            while (h--)(f = g[h]) && (a[h] = !(b[h] = f))
          }) : function(a, e, f) {
            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop()
          }
        }),
        has: ib(function(a) {
          return function(b) {
            return gb(a, b).length > 0
          }
        }),
        contains: ib(function(a) {
          return a = a.replace(cb, db),
            function(b) {
              return (b.textContent || b.innerText || e(b)).indexOf(a) > -1
            }
        }),
        lang: ib(function(a) {
          return W.test(a || "") || gb.error("unsupported lang: " + a), a = a.replace(cb, db).toLowerCase(),
            function(b) {
              var c;
              do
                if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-");
              while ((b = b.parentNode) && 1 === b.nodeType);
              return !1
            }
        }),
        target: function(b) {
          var c = a.location && a.location.hash;
          return c && c.slice(1) === b.id
        },
        root: function(a) {
          return a === o
        },
        focus: function(a) {
          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)
        },
        enabled: function(a) {
          return a.disabled === !1
        },
        disabled: function(a) {
          return a.disabled === !0
        },
        checked: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b && !!a.checked || "option" === b && !!a.selected
        },
        selected: function(a) {
          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0
        },
        empty: function(a) {
          for (a = a.firstChild; a; a = a.nextSibling)
            if (a.nodeType < 6) return !1;
          return !0
        },
        parent: function(a) {
          return !d.pseudos.empty(a)
        },
        header: function(a) {
          return Z.test(a.nodeName)
        },
        input: function(a) {
          return Y.test(a.nodeName)
        },
        button: function(a) {
          var b = a.nodeName.toLowerCase();
          return "input" === b && "button" === a.type || "button" === b
        },
        text: function(a) {
          var b;
          return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
        },
        first: ob(function() {
          return [0]
        }),
        last: ob(function(a, b) {
          return [b - 1]
        }),
        eq: ob(function(a, b, c) {
          return [0 > c ? c + b : c]
        }),
        even: ob(function(a, b) {
          for (var c = 0; b > c; c += 2) a.push(c);
          return a
        }),
        odd: ob(function(a, b) {
          for (var c = 1; b > c; c += 2) a.push(c);
          return a
        }),
        lt: ob(function(a, b, c) {
          for (var d = 0 > c ? c + b : c; --d >= 0;) a.push(d);
          return a
        }),
        gt: ob(function(a, b, c) {
          for (var d = 0 > c ? c + b : c; ++d < b;) a.push(d);
          return a
        })
      }
    }, d.pseudos.nth = d.pseudos.eq;
    for (b in {
        radio: !0,
        checkbox: !0,
        file: !0,
        password: !0,
        image: !0
      }) d.pseudos[b] = mb(b);
    for (b in {
        submit: !0,
        reset: !0
      }) d.pseudos[b] = nb(b);

    function qb() {}
    qb.prototype = d.filters = d.pseudos, d.setFilters = new qb, g = gb.tokenize = function(a, b) {
      var c, e, f, g, h, i, j, k = z[a + " "];
      if (k) return b ? 0 : k.slice(0);
      h = a, i = [], j = d.preFilter;
      while (h) {
        (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({
          value: c,
          type: e[0].replace(R, " ")
        }), h = h.slice(c.length));
        for (g in d.filter) !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({
          value: c,
          type: g,
          matches: e
        }), h = h.slice(c.length));
        if (!c) break
      }
      return b ? h.length : h ? gb.error(a) : z(a, i).slice(0)
    };

    function rb(a) {
      for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
      return d
    }

    function sb(a, b, c) {
      var d = b.dir,
        e = c && "parentNode" === d,
        f = x++;
      return b.first ? function(b, c, f) {
        while (b = b[d])
          if (1 === b.nodeType || e) return a(b, c, f)
      } : function(b, c, g) {
        var h, i, j = [w, f];
        if (g) {
          while (b = b[d])
            if ((1 === b.nodeType || e) && a(b, c, g)) return !0
        } else
          while (b = b[d])
            if (1 === b.nodeType || e) {
              if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f) return j[2] = h[2];
              if (i[d] = j, j[2] = a(b, c, g)) return !0
            }
      }
    }

    function tb(a) {
      return a.length > 1 ? function(b, c, d) {
        var e = a.length;
        while (e--)
          if (!a[e](b, c, d)) return !1;
        return !0
      } : a[0]
    }

    function ub(a, b, c) {
      for (var d = 0, e = b.length; e > d; d++) gb(a, b[d], c);
      return c
    }

    function vb(a, b, c, d, e) {
      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)(f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h));
      return g
    }

    function wb(a, b, c, d, e, f) {
      return d && !d[u] && (d = wb(d)), e && !e[u] && (e = wb(e, f)), ib(function(f, g, h, i) {
        var j, k, l, m = [],
          n = [],
          o = g.length,
          p = f || ub(b || "*", h.nodeType ? [h] : h, []),
          q = !a || !f && b ? p : vb(p, m, a, h, i),
          r = c ? e || (f ? a : o || d) ? [] : g : q;
        if (c && c(q, r, h, i), d) {
          j = vb(r, n), d(j, [], h, i), k = j.length;
          while (k--)(l = j[k]) && (r[n[k]] = !(q[n[k]] = l))
        }
        if (f) {
          if (e || a) {
            if (e) {
              j = [], k = r.length;
              while (k--)(l = r[k]) && j.push(q[k] = l);
              e(null, r = [], j, i)
            }
            k = r.length;
            while (k--)(l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l))
          }
        } else r = vb(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r)
      })
    }

    function xb(a) {
      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = sb(function(a) {
          return a === b
        }, h, !0), l = sb(function(a) {
          return J(b, a) > -1
        }, h, !0), m = [function(a, c, d) {
          var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
          return b = null, e
        }]; f > i; i++)
        if (c = d.relative[a[i].type]) m = [sb(tb(m), c)];
        else {
          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
            for (e = ++i; f > e; e++)
              if (d.relative[a[e].type]) break;
            return wb(i > 1 && tb(m), i > 1 && rb(a.slice(0, i - 1).concat({
              value: " " === a[i - 2].type ? "*" : ""
            })).replace(R, "$1"), c, e > i && xb(a.slice(i, e)), f > e && xb(a = a.slice(e)), f > e && rb(a))
          }
          m.push(c)
        }
      return tb(m)
    }

    function yb(a, b) {
      var c = b.length > 0,
        e = a.length > 0,
        f = function(f, g, h, i, k) {
          var l, m, o, p = 0,
            q = "0",
            r = f && [],
            s = [],
            t = j,
            u = f || e && d.find.TAG("*", k),
            v = w += null == t ? 1 : Math.random() || .1,
            x = u.length;
          for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
            if (e && l) {
              m = 0;
              while (o = a[m++])
                if (o(l, g, h)) {
                  i.push(l);
                  break
                }
              k && (w = v)
            }
            c && ((l = !o && l) && p--, f && r.push(l))
          }
          if (p += q, c && q !== p) {
            m = 0;
            while (o = b[m++]) o(r, s, g, h);
            if (f) {
              if (p > 0)
                while (q--) r[q] || s[q] || (s[q] = F.call(i));
              s = vb(s)
            }
            H.apply(i, s), k && !f && s.length > 0 && p + b.length > 1 && gb.uniqueSort(i)
          }
          return k && (w = v, j = t), r
        };
      return c ? ib(f) : f
    }
    return h = gb.compile = function(a, b) {
      var c, d = [],
        e = [],
        f = A[a + " "];
      if (!f) {
        b || (b = g(a)), c = b.length;
        while (c--) f = xb(b[c]), f[u] ? d.push(f) : e.push(f);
        f = A(a, yb(e, d)), f.selector = a
      }
      return f
    }, i = gb.select = function(a, b, e, f) {
      var i, j, k, l, m, n = "function" == typeof a && a,
        o = !f && g(a = n.selector || a);
      if (e = e || [], 1 === o.length) {
        if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
          if (b = (d.find.ID(k.matches[0].replace(cb, db), b) || [])[0], !b) return e;
          n && (b = b.parentNode), a = a.slice(j.shift().value.length)
        }
        i = X.needsContext.test(a) ? 0 : j.length;
        while (i--) {
          if (k = j[i], d.relative[l = k.type]) break;
          if ((m = d.find[l]) && (f = m(k.matches[0].replace(cb, db), ab.test(j[0].type) && pb(b.parentNode) || b))) {
            if (j.splice(i, 1), a = f.length && rb(j), !a) return H.apply(e, f), e;
            break
          }
        }
      }
      return (n || h(a, o))(f, b, !p, e, ab.test(a) && pb(b.parentNode) || b), e
    }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = jb(function(a) {
      return 1 & a.compareDocumentPosition(n.createElement("div"))
    }), jb(function(a) {
      return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href")
    }) || kb("type|href|height|width", function(a, b, c) {
      return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
    }), c.attributes && jb(function(a) {
      return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
    }) || kb("value", function(a, b, c) {
      return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue
    }), jb(function(a) {
      return null == a.getAttribute("disabled")
    }) || kb(K, function(a, b, c) {
      var d;
      return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
    }), gb
  }(a);
  n.find = t, n.expr = t.selectors, n.expr[":"] = n.expr.pseudos, n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;
  var u = n.expr.match.needsContext,
    v = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
    w = /^.[^:#\[\.,]*$/;

  function x(a, b, c) {
    if (n.isFunction(b)) return n.grep(a, function(a, d) {
      return !!b.call(a, d, a) !== c
    });
    if (b.nodeType) return n.grep(a, function(a) {
      return a === b !== c
    });
    if ("string" == typeof b) {
      if (w.test(b)) return n.filter(b, a, c);
      b = n.filter(b, a)
    }
    return n.grep(a, function(a) {
      return g.call(b, a) >= 0 !== c
    })
  }
  n.filter = function(a, b, c) {
    var d = b[0];
    return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function(a) {
      return 1 === a.nodeType
    }))
  }, n.fn.extend({
    find: function(a) {
      var b, c = this.length,
        d = [],
        e = this;
      if ("string" != typeof a) return this.pushStack(n(a).filter(function() {
        for (b = 0; c > b; b++)
          if (n.contains(e[b], this)) return !0
      }));
      for (b = 0; c > b; b++) n.find(a, e[b], d);
      return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + " " + a : a, d
    },
    filter: function(a) {
      return this.pushStack(x(this, a || [], !1))
    },
    not: function(a) {
      return this.pushStack(x(this, a || [], !0))
    },
    is: function(a) {
      return !!x(this, "string" == typeof a && u.test(a) ? n(a) : a || [], !1).length
    }
  });
  var y, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    A = n.fn.init = function(a, b) {
      var c, d;
      if (!a) return this;
      if ("string" == typeof a) {
        if (c = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : z.exec(a), !c || !c[1] && b) return !b || b.jquery ? (b || y).find(a) : this.constructor(b).find(a);
        if (c[1]) {
          if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : l, !0)), v.test(c[1]) && n.isPlainObject(b))
            for (c in b) n.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
          return this
        }
        return d = l.getElementById(c[2]), d && d.parentNode && (this.length = 1, this[0] = d), this.context = l, this.selector = a, this
      }
      return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? "undefined" != typeof y.ready ? y.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this))
    };
  A.prototype = n.fn, y = n(l);
  var B = /^(?:parents|prev(?:Until|All))/,
    C = {
      children: !0,
      contents: !0,
      next: !0,
      prev: !0
    };
  n.extend({
    dir: function(a, b, c) {
      var d = [],
        e = void 0 !== c;
      while ((a = a[b]) && 9 !== a.nodeType)
        if (1 === a.nodeType) {
          if (e && n(a).is(c)) break;
          d.push(a)
        }
      return d
    },
    sibling: function(a, b) {
      for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
      return c
    }
  }), n.fn.extend({
    has: function(a) {
      var b = n(a, this),
        c = b.length;
      return this.filter(function() {
        for (var a = 0; c > a; a++)
          if (n.contains(this, b[a])) return !0
      })
    },
    closest: function(a, b) {
      for (var c, d = 0, e = this.length, f = [], g = u.test(a) || "string" != typeof a ? n(a, b || this.context) : 0; e > d; d++)
        for (c = this[d]; c && c !== b; c = c.parentNode)
          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {
            f.push(c);
            break
          }
      return this.pushStack(f.length > 1 ? n.unique(f) : f)
    },
    index: function(a) {
      return a ? "string" == typeof a ? g.call(n(a), this[0]) : g.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
    },
    add: function(a, b) {
      return this.pushStack(n.unique(n.merge(this.get(), n(a, b))))
    },
    addBack: function(a) {
      return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
    }
  });

  function D(a, b) {
    while ((a = a[b]) && 1 !== a.nodeType);
    return a
  }
  n.each({
    parent: function(a) {
      var b = a.parentNode;
      return b && 11 !== b.nodeType ? b : null
    },
    parents: function(a) {
      return n.dir(a, "parentNode")
    },
    parentsUntil: function(a, b, c) {
      return n.dir(a, "parentNode", c)
    },
    next: function(a) {
      return D(a, "nextSibling")
    },
    prev: function(a) {
      return D(a, "previousSibling")
    },
    nextAll: function(a) {
      return n.dir(a, "nextSibling")
    },
    prevAll: function(a) {
      return n.dir(a, "previousSibling")
    },
    nextUntil: function(a, b, c) {
      return n.dir(a, "nextSibling", c)
    },
    prevUntil: function(a, b, c) {
      return n.dir(a, "previousSibling", c)
    },
    siblings: function(a) {
      return n.sibling((a.parentNode || {}).firstChild, a)
    },
    children: function(a) {
      return n.sibling(a.firstChild)
    },
    contents: function(a) {
      return a.contentDocument || n.merge([], a.childNodes)
    }
  }, function(a, b) {
    n.fn[a] = function(c, d) {
      var e = n.map(this, b, c);
      return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = n.filter(d, e)), this.length > 1 && (C[a] || n.unique(e), B.test(a) && e.reverse()), this.pushStack(e)
    }
  });
  var E = /\S+/g,
    F = {};

  function G(a) {
    var b = F[a] = {};
    return n.each(a.match(E) || [], function(a, c) {
      b[c] = !0
    }), b
  }
  n.Callbacks = function(a) {
    a = "string" == typeof a ? F[a] || G(a) : n.extend({}, a);
    var b, c, d, e, f, g, h = [],
      i = !a.once && [],
      j = function(l) {
        for (b = a.memory && l, c = !0, g = e || 0, e = 0, f = h.length, d = !0; h && f > g; g++)
          if (h[g].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
            b = !1;
            break
          }
        d = !1, h && (i ? i.length && j(i.shift()) : b ? h = [] : k.disable())
      },
      k = {
        add: function() {
          if (h) {
            var c = h.length;
            ! function g(b) {
              n.each(b, function(b, c) {
                var d = n.type(c);
                "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && g(c)
              })
            }(arguments), d ? f = h.length : b && (e = c, j(b))
          }
          return this
        },
        remove: function() {
          return h && n.each(arguments, function(a, b) {
            var c;
            while ((c = n.inArray(b, h, c)) > -1) h.splice(c, 1), d && (f >= c && f--, g >= c && g--)
          }), this
        },
        has: function(a) {
          return a ? n.inArray(a, h) > -1 : !(!h || !h.length)
        },
        empty: function() {
          return h = [], f = 0, this
        },
        disable: function() {
          return h = i = b = void 0, this
        },
        disabled: function() {
          return !h
        },
        lock: function() {
          return i = void 0, b || k.disable(), this
        },
        locked: function() {
          return !i
        },
        fireWith: function(a, b) {
          return !h || c && !i || (b = b || [], b = [a, b.slice ? b.slice() : b], d ? i.push(b) : j(b)), this
        },
        fire: function() {
          return k.fireWith(this, arguments), this
        },
        fired: function() {
          return !!c
        }
      };
    return k
  }, n.extend({
    Deferred: function(a) {
      var b = [
          ["resolve", "done", n.Callbacks("once memory"), "resolved"],
          ["reject", "fail", n.Callbacks("once memory"), "rejected"],
          ["notify", "progress", n.Callbacks("memory")]
        ],
        c = "pending",
        d = {
          state: function() {
            return c
          },
          always: function() {
            return e.done(arguments).fail(arguments), this
          },
          then: function() {
            var a = arguments;
            return n.Deferred(function(c) {
              n.each(b, function(b, f) {
                var g = n.isFunction(a[b]) && a[b];
                e[f[1]](function() {
                  var a = g && g.apply(this, arguments);
                  a && n.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments)
                })
              }), a = null
            }).promise()
          },
          promise: function(a) {
            return null != a ? n.extend(a, d) : d
          }
        },
        e = {};
      return d.pipe = d.then, n.each(b, function(a, f) {
        var g = f[2],
          h = f[3];
        d[f[1]] = g.add, h && g.add(function() {
          c = h
        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
          return e[f[0] + "With"](this === e ? d : this, arguments), this
        }, e[f[0] + "With"] = g.fireWith
      }), d.promise(e), a && a.call(e, e), e
    },
    when: function(a) {
      var b = 0,
        c = d.call(arguments),
        e = c.length,
        f = 1 !== e || a && n.isFunction(a.promise) ? e : 0,
        g = 1 === f ? a : n.Deferred(),
        h = function(a, b, c) {
          return function(e) {
            b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c)
          }
        },
        i, j, k;
      if (e > 1)
        for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) c[b] && n.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
      return f || g.resolveWith(k, c), g.promise()
    }
  });
  var H;
  n.fn.ready = function(a) {
    return n.ready.promise().done(a), this
  }, n.extend({
    isReady: !1,
    readyWait: 1,
    holdReady: function(a) {
      a ? n.readyWait++ : n.ready(!0)
    },
    ready: function(a) {
      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (H.resolveWith(l, [n]), n.fn.triggerHandler && (n(l).triggerHandler("ready"), n(l).off("ready"))))
    }
  });

  function I() {
    l.removeEventListener("DOMContentLoaded", I, !1), a.removeEventListener("load", I, !1), n.ready()
  }
  n.ready.promise = function(b) {
    return H || (H = n.Deferred(), "complete" === l.readyState ? setTimeout(n.ready) : (l.addEventListener("DOMContentLoaded", I, !1), a.addEventListener("load", I, !1))), H.promise(b)
  }, n.ready.promise();
  var J = n.access = function(a, b, c, d, e, f, g) {
    var h = 0,
      i = a.length,
      j = null == c;
    if ("object" === n.type(c)) {
      e = !0;
      for (h in c) n.access(a, b, h, c[h], !0, f, g)
    } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
        return j.call(n(a), c)
      })), b))
      for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
    return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
  };
  n.acceptData = function(a) {
    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType
  };

  function K() {
    Object.defineProperty(this.cache = {}, 0, {
      get: function() {
        return {}
      }
    }), this.expando = n.expando + K.uid++
  }
  K.uid = 1, K.accepts = n.acceptData, K.prototype = {
    key: function(a) {
      if (!K.accepts(a)) return 0;
      var b = {},
        c = a[this.expando];
      if (!c) {
        c = K.uid++;
        try {
          b[this.expando] = {
            value: c
          }, Object.defineProperties(a, b)
        } catch (d) {
          b[this.expando] = c, n.extend(a, b)
        }
      }
      return this.cache[c] || (this.cache[c] = {}), c
    },
    set: function(a, b, c) {
      var d, e = this.key(a),
        f = this.cache[e];
      if ("string" == typeof b) f[b] = c;
      else if (n.isEmptyObject(f)) n.extend(this.cache[e], b);
      else
        for (d in b) f[d] = b[d];
      return f
    },
    get: function(a, b) {
      var c = this.cache[this.key(a)];
      return void 0 === b ? c : c[b]
    },
    access: function(a, b, c) {
      var d;
      return void 0 === b || b && "string" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b)
    },
    remove: function(a, b) {
      var c, d, e, f = this.key(a),
        g = this.cache[f];
      if (void 0 === b) this.cache[f] = {};
      else {
        n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in g ? d = [b, e] : (d = e, d = d in g ? [d] : d.match(E) || [])), c = d.length;
        while (c--) delete g[d[c]]
      }
    },
    hasData: function(a) {
      return !n.isEmptyObject(this.cache[a[this.expando]] || {})
    },
    discard: function(a) {
      a[this.expando] && delete this.cache[a[this.expando]]
    }
  };
  var L = new K,
    M = new K,
    N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    O = /([A-Z])/g;

  function P(a, b, c) {
    var d;
    if (void 0 === c && 1 === a.nodeType)
      if (d = "data-" + b.replace(O, "-$1").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
        try {
          c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : N.test(c) ? n.parseJSON(c) : c
        } catch (e) {}
        M.set(a, b, c)
      } else c = void 0;
    return c
  }
  n.extend({
    hasData: function(a) {
      return M.hasData(a) || L.hasData(a)
    },
    data: function(a, b, c) {
      return M.access(a, b, c)
    },
    removeData: function(a, b) {
      M.remove(a, b)
    },
    _data: function(a, b, c) {
      return L.access(a, b, c)
    },
    _removeData: function(a, b) {
      L.remove(a, b)
    }
  }), n.fn.extend({
    data: function(a, b) {
      var c, d, e, f = this[0],
        g = f && f.attributes;
      if (void 0 === a) {
        if (this.length && (e = M.get(f), 1 === f.nodeType && !L.get(f, "hasDataAttrs"))) {
          c = g.length;
          while (c--) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = n.camelCase(d.slice(5)), P(f, d, e[d])));
          L.set(f, "hasDataAttrs", !0)
        }
        return e
      }
      return "object" == typeof a ? this.each(function() {
        M.set(this, a)
      }) : J(this, function(b) {
        var c, d = n.camelCase(a);
        if (f && void 0 === b) {
          if (c = M.get(f, a), void 0 !== c) return c;
          if (c = M.get(f, d), void 0 !== c) return c;
          if (c = P(f, d, void 0), void 0 !== c) return c
        } else this.each(function() {
          var c = M.get(this, d);
          M.set(this, d, b), -1 !== a.indexOf("-") && void 0 !== c && M.set(this, a, b)
        })
      }, null, b, arguments.length > 1, null, !0)
    },
    removeData: function(a) {
      return this.each(function() {
        M.remove(this, a)
      })
    }
  }), n.extend({
    queue: function(a, b, c) {
      var d;
      return a ? (b = (b || "fx") + "queue", d = L.get(a, b), c && (!d || n.isArray(c) ? d = L.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0
    },
    dequeue: function(a, b) {
      b = b || "fx";
      var c = n.queue(a, b),
        d = c.length,
        e = c.shift(),
        f = n._queueHooks(a, b),
        g = function() {
          n.dequeue(a, b)
        };
      "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()
    },
    _queueHooks: function(a, b) {
      var c = b + "queueHooks";
      return L.get(a, c) || L.access(a, c, {
        empty: n.Callbacks("once memory").add(function() {
          L.remove(a, [b + "queue", c])
        })
      })
    }
  }), n.fn.extend({
    queue: function(a, b) {
      var c = 2;
      return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function() {
        var c = n.queue(this, a, b);
        n._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && n.dequeue(this, a)
      })
    },
    dequeue: function(a) {
      return this.each(function() {
        n.dequeue(this, a)
      })
    },
    clearQueue: function(a) {
      return this.queue(a || "fx", [])
    },
    promise: function(a, b) {
      var c, d = 1,
        e = n.Deferred(),
        f = this,
        g = this.length,
        h = function() {
          --d || e.resolveWith(f, [f])
        };
      "string" != typeof a && (b = a, a = void 0), a = a || "fx";
      while (g--) c = L.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
      return h(), e.promise(b)
    }
  });
  var Q = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    R = ["Top", "Right", "Bottom", "Left"],
    S = function(a, b) {
      return a = b || a, "none" === n.css(a, "display") || !n.contains(a.ownerDocument, a)
    },
    T = /^(?:checkbox|radio)$/i;
  ! function() {
    var a = l.createDocumentFragment(),
      b = a.appendChild(l.createElement("div")),
      c = l.createElement("input");
    c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue
  }();
  var U = "undefined";
  k.focusinBubbles = "onfocusin" in a;
  var V = /^key/,
    W = /^(?:mouse|pointer|contextmenu)|click/,
    X = /^(?:focusinfocus|focusoutblur)$/,
    Y = /^([^.]*)(?:\.(.+)|)$/;

  function Z() {
    return !0
  }

  function $() {
    return !1
  }

  function _() {
    try {
      return l.activeElement
    } catch (a) {}
  }
  n.event = {
    global: {},
    add: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = L.get(a);
      if (r) {
        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function(b) {
          return typeof n !== U && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0
        }), b = (b || "").match(E) || [""], j = b.length;
        while (j--) h = Y.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({
          type: o,
          origType: q,
          data: d,
          handler: c,
          guid: c.guid,
          selector: e,
          needsContext: e && n.expr.match.needsContext.test(e),
          namespace: p.join(".")
        }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g, !1)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0)
      }
    },
    remove: function(a, b, c, d, e) {
      var f, g, h, i, j, k, l, m, o, p, q, r = L.hasData(a) && L.get(a);
      if (r && (i = r.events)) {
        b = (b || "").match(E) || [""], j = b.length;
        while (j--)
          if (h = Y.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length;
            while (f--) k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
            g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o])
          } else
            for (o in i) n.event.remove(a, o + b[j], c, d, !0);
        n.isEmptyObject(i) && (delete r.handle, L.remove(a, "events"))
      }
    },
    trigger: function(b, c, d, e) {
      var f, g, h, i, k, m, o, p = [d || l],
        q = j.call(b, "type") ? b.type : b,
        r = j.call(b, "namespace") ? b.namespace.split(".") : [];
      if (g = h = d = d || l, 3 !== d.nodeType && 8 !== d.nodeType && !X.test(q + n.event.triggered) && (q.indexOf(".") >= 0 && (r = q.split("."), q = r.shift(), r.sort()), k = q.indexOf(":") < 0 && "on" + q, b = b[n.expando] ? b : new n.Event(q, "object" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = r.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + r.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, e || !o.trigger || o.trigger.apply(d, c) !== !1)) {
        if (!e && !o.noBubble && !n.isWindow(d)) {
          for (i = o.delegateType || q, X.test(i + q) || (g = g.parentNode); g; g = g.parentNode) p.push(g), h = g;
          h === (d.ownerDocument || l) && p.push(h.defaultView || h.parentWindow || a)
        }
        f = 0;
        while ((g = p[f++]) && !b.isPropagationStopped()) b.type = f > 1 ? i : o.bindType || q, m = (L.get(g, "events") || {})[b.type] && L.get(g, "handle"), m && m.apply(g, c), m = k && g[k], m && m.apply && n.acceptData(g) && (b.result = m.apply(g, c), b.result === !1 && b.preventDefault());
        return b.type = q, e || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !n.acceptData(d) || k && n.isFunction(d[q]) && !n.isWindow(d) && (h = d[k], h && (d[k] = null), n.event.triggered = q, d[q](), n.event.triggered = void 0, h && (d[k] = h)), b.result
      }
    },
    dispatch: function(a) {
      a = n.event.fix(a);
      var b, c, e, f, g, h = [],
        i = d.call(arguments),
        j = (L.get(this, "events") || {})[a.type] || [],
        k = n.event.special[a.type] || {};
      if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
        h = n.event.handlers.call(this, a, j), b = 0;
        while ((f = h[b++]) && !a.isPropagationStopped()) {
          a.currentTarget = f.elem, c = 0;
          while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped())(!a.namespace_re || a.namespace_re.test(g.namespace)) && (a.handleObj = g, a.data = g.data, e = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (a.result = e) === !1 && (a.preventDefault(), a.stopPropagation()))
        }
        return k.postDispatch && k.postDispatch.call(this, a), a.result
      }
    },
    handlers: function(a, b) {
      var c, d, e, f, g = [],
        h = b.delegateCount,
        i = a.target;
      if (h && i.nodeType && (!a.button || "click" !== a.type))
        for (; i !== this; i = i.parentNode || this)
          if (i.disabled !== !0 || "click" !== a.type) {
            for (d = [], c = 0; h > c; c++) f = b[c], e = f.selector + " ", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) >= 0 : n.find(e, this, null, [i]).length), d[e] && d.push(f);
            d.length && g.push({
              elem: i,
              handlers: d
            })
          }
      return h < b.length && g.push({
        elem: this,
        handlers: b.slice(h)
      }), g
    },
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(a, b) {
        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function(a, b) {
        var c, d, e, f = b.button;
        return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || l, d = c.documentElement, e = c.body, a.pageX = b.clientX + (d && d.scrollLeft || e && e.scrollLeft || 0) - (d && d.clientLeft || e && e.clientLeft || 0), a.pageY = b.clientY + (d && d.scrollTop || e && e.scrollTop || 0) - (d && d.clientTop || e && e.clientTop || 0)), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a
      }
    },
    fix: function(a) {
      if (a[n.expando]) return a;
      var b, c, d, e = a.type,
        f = a,
        g = this.fixHooks[e];
      g || (this.fixHooks[e] = g = W.test(e) ? this.mouseHooks : V.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new n.Event(f), b = d.length;
      while (b--) c = d[b], a[c] = f[c];
      return a.target || (a.target = l), 3 === a.target.nodeType && (a.target = a.target.parentNode), g.filter ? g.filter(a, f) : a
    },
    special: {
      load: {
        noBubble: !0
      },
      focus: {
        trigger: function() {
          return this !== _() && this.focus ? (this.focus(), !1) : void 0
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          return this === _() && this.blur ? (this.blur(), !1) : void 0
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          return "checkbox" === this.type && this.click && n.nodeName(this, "input") ? (this.click(), !1) : void 0
        },
        _default: function(a) {
          return n.nodeName(a.target, "a")
        }
      },
      beforeunload: {
        postDispatch: function(a) {
          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)
        }
      }
    },
    simulate: function(a, b, c, d) {
      var e = n.extend(new n.Event, c, {
        type: a,
        isSimulated: !0,
        originalEvent: {}
      });
      d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault()
    }
  }, n.removeEvent = function(a, b, c) {
    a.removeEventListener && a.removeEventListener(b, c, !1)
  }, n.Event = function(a, b) {
    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? Z : $) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void(this[n.expando] = !0)) : new n.Event(a, b)
  }, n.Event.prototype = {
    isDefaultPrevented: $,
    isPropagationStopped: $,
    isImmediatePropagationStopped: $,
    preventDefault: function() {
      var a = this.originalEvent;
      this.isDefaultPrevented = Z, a && a.preventDefault && a.preventDefault()
    },
    stopPropagation: function() {
      var a = this.originalEvent;
      this.isPropagationStopped = Z, a && a.stopPropagation && a.stopPropagation()
    },
    stopImmediatePropagation: function() {
      var a = this.originalEvent;
      this.isImmediatePropagationStopped = Z, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), this.stopPropagation()
    }
  }, n.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(a, b) {
    n.event.special[a] = {
      delegateType: b,
      bindType: b,
      handle: function(a) {
        var c, d = this,
          e = a.relatedTarget,
          f = a.handleObj;
        return (!e || e !== d && !n.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
      }
    }
  }), k.focusinBubbles || n.each({
    focus: "focusin",
    blur: "focusout"
  }, function(a, b) {
    var c = function(a) {
      n.event.simulate(b, a.target, n.event.fix(a), !0)
    };
    n.event.special[b] = {
      setup: function() {
        var d = this.ownerDocument || this,
          e = L.access(d, b);
        e || d.addEventListener(a, c, !0), L.access(d, b, (e || 0) + 1)
      },
      teardown: function() {
        var d = this.ownerDocument || this,
          e = L.access(d, b) - 1;
        e ? L.access(d, b, e) : (d.removeEventListener(a, c, !0), L.remove(d, b))
      }
    }
  }), n.fn.extend({
    on: function(a, b, c, d, e) {
      var f, g;
      if ("object" == typeof a) {
        "string" != typeof b && (c = c || b, b = void 0);
        for (g in a) this.on(g, b, c, a[g], e);
        return this
      }
      if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = $;
      else if (!d) return this;
      return 1 === e && (f = d, d = function(a) {
        return n().off(a), f.apply(this, arguments)
      }, d.guid = f.guid || (f.guid = n.guid++)), this.each(function() {
        n.event.add(this, a, d, c, b)
      })
    },
    one: function(a, b, c, d) {
      return this.on(a, b, c, d, 1)
    },
    off: function(a, b, c) {
      var d, e;
      if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
      if ("object" == typeof a) {
        for (e in a) this.off(e, b, a[e]);
        return this
      }
      return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = $), this.each(function() {
        n.event.remove(this, a, c, b)
      })
    },
    trigger: function(a, b) {
      return this.each(function() {
        n.event.trigger(a, b, this)
      })
    },
    triggerHandler: function(a, b) {
      var c = this[0];
      return c ? n.event.trigger(a, b, c, !0) : void 0
    }
  });
  var ab = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    bb = /<([\w:]+)/,
    cb = /<|&#?\w+;/,
    db = /<(?:script|style|link)/i,
    eb = /checked\s*(?:[^=]|=\s*.checked.)/i,
    fb = /^$|\/(?:java|ecma)script/i,
    gb = /^true\/(.*)/,
    hb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    ib = {
      option: [1, "<select multiple='multiple'>", "</select>"],
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
  ib.optgroup = ib.option, ib.tbody = ib.tfoot = ib.colgroup = ib.caption = ib.thead, ib.th = ib.td;

  function jb(a, b) {
    return n.nodeName(a, "table") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a
  }

  function kb(a) {
    return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a
  }

  function lb(a) {
    var b = gb.exec(a.type);
    return b ? a.type = b[1] : a.removeAttribute("type"), a
  }

  function mb(a, b) {
    for (var c = 0, d = a.length; d > c; c++) L.set(a[c], "globalEval", !b || L.get(b[c], "globalEval"))
  }

  function nb(a, b) {
    var c, d, e, f, g, h, i, j;
    if (1 === b.nodeType) {
      if (L.hasData(a) && (f = L.access(a), g = L.set(b, f), j = f.events)) {
        delete g.handle, g.events = {};
        for (e in j)
          for (c = 0, d = j[e].length; d > c; c++) n.event.add(b, e, j[e][c])
      }
      M.hasData(a) && (h = M.access(a), i = n.extend({}, h), M.set(b, i))
    }
  }

  function ob(a, b) {
    var c = a.getElementsByTagName ? a.getElementsByTagName(b || "*") : a.querySelectorAll ? a.querySelectorAll(b || "*") : [];
    return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c
  }

  function pb(a, b) {
    var c = b.nodeName.toLowerCase();
    "input" === c && T.test(a.type) ? b.checked = a.checked : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue)
  }
  n.extend({
    clone: function(a, b, c) {
      var d, e, f, g, h = a.cloneNode(!0),
        i = n.contains(a.ownerDocument, a);
      if (!(k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a)))
        for (g = ob(h), f = ob(a), d = 0, e = f.length; e > d; d++) pb(f[d], g[d]);
      if (b)
        if (c)
          for (f = f || ob(a), g = g || ob(h), d = 0, e = f.length; e > d; d++) nb(f[d], g[d]);
        else nb(a, h);
      return g = ob(h, "script"), g.length > 0 && mb(g, !i && ob(a, "script")), h
    },
    buildFragment: function(a, b, c, d) {
      for (var e, f, g, h, i, j, k = b.createDocumentFragment(), l = [], m = 0, o = a.length; o > m; m++)
        if (e = a[m], e || 0 === e)
          if ("object" === n.type(e)) n.merge(l, e.nodeType ? [e] : e);
          else if (cb.test(e)) {
        f = f || k.appendChild(b.createElement("div")), g = (bb.exec(e) || ["", ""])[1].toLowerCase(), h = ib[g] || ib._default, f.innerHTML = h[1] + e.replace(ab, "<$1></$2>") + h[2], j = h[0];
        while (j--) f = f.lastChild;
        n.merge(l, f.childNodes), f = k.firstChild, f.textContent = ""
      } else l.push(b.createTextNode(e));
      k.textContent = "", m = 0;
      while (e = l[m++])
        if ((!d || -1 === n.inArray(e, d)) && (i = n.contains(e.ownerDocument, e), f = ob(k.appendChild(e), "script"), i && mb(f), c)) {
          j = 0;
          while (e = f[j++]) fb.test(e.type || "") && c.push(e)
        }
      return k
    },
    cleanData: function(a) {
      for (var b, c, d, e, f = n.event.special, g = 0; void 0 !== (c = a[g]); g++) {
        if (n.acceptData(c) && (e = c[L.expando], e && (b = L.cache[e]))) {
          if (b.events)
            for (d in b.events) f[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);
          L.cache[e] && delete L.cache[e]
        }
        delete M.cache[c[M.expando]]
      }
    }
  }), n.fn.extend({
    text: function(a) {
      return J(this, function(a) {
        return void 0 === a ? n.text(this) : this.empty().each(function() {
          (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a)
        })
      }, null, a, arguments.length)
    },
    append: function() {
      return this.domManip(arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = jb(this, a);
          b.appendChild(a)
        }
      })
    },
    prepend: function() {
      return this.domManip(arguments, function(a) {
        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
          var b = jb(this, a);
          b.insertBefore(a, b.firstChild)
        }
      })
    },
    before: function() {
      return this.domManip(arguments, function(a) {
        this.parentNode && this.parentNode.insertBefore(a, this)
      })
    },
    after: function() {
      return this.domManip(arguments, function(a) {
        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
      })
    },
    remove: function(a, b) {
      for (var c, d = a ? n.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || n.cleanData(ob(c)), c.parentNode && (b && n.contains(c.ownerDocument, c) && mb(ob(c, "script")), c.parentNode.removeChild(c));
      return this
    },
    empty: function() {
      for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (n.cleanData(ob(a, !1)), a.textContent = "");
      return this
    },
    clone: function(a, b) {
      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {
        return n.clone(this, a, b)
      })
    },
    html: function(a) {
      return J(this, function(a) {
        var b = this[0] || {},
          c = 0,
          d = this.length;
        if (void 0 === a && 1 === b.nodeType) return b.innerHTML;
        if ("string" == typeof a && !db.test(a) && !ib[(bb.exec(a) || ["", ""])[1].toLowerCase()]) {
          a = a.replace(ab, "<$1></$2>");
          try {
            for (; d > c; c++) b = this[c] || {}, 1 === b.nodeType && (n.cleanData(ob(b, !1)), b.innerHTML = a);
            b = 0
          } catch (e) {}
        }
        b && this.empty().append(a)
      }, null, a, arguments.length)
    },
    replaceWith: function() {
      var a = arguments[0];
      return this.domManip(arguments, function(b) {
        a = this.parentNode, n.cleanData(ob(this)), a && a.replaceChild(b, this)
      }), a && (a.length || a.nodeType) ? this : this.remove()
    },
    detach: function(a) {
      return this.remove(a, !0)
    },
    domManip: function(a, b) {
      a = e.apply([], a);
      var c, d, f, g, h, i, j = 0,
        l = this.length,
        m = this,
        o = l - 1,
        p = a[0],
        q = n.isFunction(p);
      if (q || l > 1 && "string" == typeof p && !k.checkClone && eb.test(p)) return this.each(function(c) {
        var d = m.eq(c);
        q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b)
      });
      if (l && (c = n.buildFragment(a, this[0].ownerDocument, !1, this), d = c.firstChild, 1 === c.childNodes.length && (c = d), d)) {
        for (f = n.map(ob(c, "script"), kb), g = f.length; l > j; j++) h = c, j !== o && (h = n.clone(h, !0, !0), g && n.merge(f, ob(h, "script"))), b.call(this[j], h, j);
        if (g)
          for (i = f[f.length - 1].ownerDocument, n.map(f, lb), j = 0; g > j; j++) h = f[j], fb.test(h.type || "") && !L.access(h, "globalEval") && n.contains(i, h) && (h.src ? n._evalUrl && n._evalUrl(h.src) : n.globalEval(h.textContent.replace(hb, "")))
      }
      return this
    }
  }), n.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(a, b) {
    n.fn[a] = function(a) {
      for (var c, d = [], e = n(a), g = e.length - 1, h = 0; g >= h; h++) c = h === g ? this : this.clone(!0), n(e[h])[b](c), f.apply(d, c.get());
      return this.pushStack(d)
    }
  });
  var qb, rb = {};

  function sb(b, c) {
    var d, e = n(c.createElement(b)).appendTo(c.body),
      f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : n.css(e[0], "display");
    return e.detach(), f
  }

  function tb(a) {
    var b = l,
      c = rb[a];
    return c || (c = sb(a, b), "none" !== c && c || (qb = (qb || n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = qb[0].contentDocument, b.write(), b.close(), c = sb(a, b), qb.detach()), rb[a] = c), c
  }
  var ub = /^margin/,
    vb = new RegExp("^(" + Q + ")(?!px)[a-z%]+$", "i"),
    wb = function(b) {
      return b.ownerDocument.defaultView.opener ? b.ownerDocument.defaultView.getComputedStyle(b, null) : a.getComputedStyle(b, null)
    };

  function xb(a, b, c) {
    var d, e, f, g, h = a.style;
    return c = c || wb(a), c && (g = c.getPropertyValue(b) || c[b]), c && ("" !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), vb.test(g) && ub.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + "" : g
  }

  function yb(a, b) {
    return {
      get: function() {
        return a() ? void delete this.get : (this.get = b).apply(this, arguments)
      }
    }
  }! function() {
    var b, c, d = l.documentElement,
      e = l.createElement("div"),
      f = l.createElement("div");
    if (f.style) {
      f.style.backgroundClip = "content-box", f.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === f.style.backgroundClip, e.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute", e.appendChild(f);

      function g() {
        f.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", f.innerHTML = "", d.appendChild(e);
        var g = a.getComputedStyle(f, null);
        b = "1%" !== g.top, c = "4px" === g.width, d.removeChild(e)
      }
      a.getComputedStyle && n.extend(k, {
        pixelPosition: function() {
          return g(), b
        },
        boxSizingReliable: function() {
          return null == c && g(), c
        },
        reliableMarginRight: function() {
          var b, c = f.appendChild(l.createElement("div"));
          return c.style.cssText = f.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", c.style.marginRight = c.style.width = "0", f.style.width = "1px", d.appendChild(e), b = !parseFloat(a.getComputedStyle(c, null).marginRight), d.removeChild(e), f.removeChild(c), b
        }
      })
    }
  }(), n.swap = function(a, b, c, d) {
    var e, f, g = {};
    for (f in b) g[f] = a.style[f], a.style[f] = b[f];
    e = c.apply(a, d || []);
    for (f in b) a.style[f] = g[f];
    return e
  };
  var zb = /^(none|table(?!-c[ea]).+)/,
    Ab = new RegExp("^(" + Q + ")(.*)$", "i"),
    Bb = new RegExp("^([+-])=(" + Q + ")", "i"),
    Cb = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
    Db = {
      letterSpacing: "0",
      fontWeight: "400"
    },
    Eb = ["Webkit", "O", "Moz", "ms"];

  function Fb(a, b) {
    if (b in a) return b;
    var c = b[0].toUpperCase() + b.slice(1),
      d = b,
      e = Eb.length;
    while (e--)
      if (b = Eb[e] + c, b in a) return b;
    return d
  }

  function Gb(a, b, c) {
    var d = Ab.exec(b);
    return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b
  }

  function Hb(a, b, c, d, e) {
    for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += n.css(a, c + R[f], !0, e)), d ? ("content" === c && (g -= n.css(a, "padding" + R[f], !0, e)), "margin" !== c && (g -= n.css(a, "border" + R[f] + "Width", !0, e))) : (g += n.css(a, "padding" + R[f], !0, e), "padding" !== c && (g += n.css(a, "border" + R[f] + "Width", !0, e)));
    return g
  }

  function Ib(a, b, c) {
    var d = !0,
      e = "width" === b ? a.offsetWidth : a.offsetHeight,
      f = wb(a),
      g = "border-box" === n.css(a, "boxSizing", !1, f);
    if (0 >= e || null == e) {
      if (e = xb(a, b, f), (0 > e || null == e) && (e = a.style[b]), vb.test(e)) return e;
      d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0
    }
    return e + Hb(a, b, c || (g ? "border" : "content"), d, f) + "px"
  }

  function Jb(a, b) {
    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = L.get(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && S(d) && (f[g] = L.access(d, "olddisplay", tb(d.nodeName)))) : (e = S(d), "none" === c && e || L.set(d, "olddisplay", e ? c : n.css(d, "display"))));
    for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
    return a
  }
  n.extend({
    cssHooks: {
      opacity: {
        get: function(a, b) {
          if (b) {
            var c = xb(a, "opacity");
            return "" === c ? "1" : c
          }
        }
      }
    },
    cssNumber: {
      columnCount: !0,
      fillOpacity: !0,
      flexGrow: !0,
      flexShrink: !0,
      fontWeight: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0
    },
    cssProps: {
      "float": "cssFloat"
    },
    style: function(a, b, c, d) {
      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
        var e, f, g, h = n.camelCase(b),
          i = a.style;
        return b = n.cssProps[h] || (n.cssProps[h] = Fb(i, h)), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, "string" === f && (e = Bb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b)), f = "number"), null != c && c === c && ("number" !== f || n.cssNumber[h] || (c += "px"), k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0)
      }
    },
    css: function(a, b, c, d) {
      var e, f, g, h = n.camelCase(b);
      return b = n.cssProps[h] || (n.cssProps[h] = Fb(a.style, h)), g = n.cssHooks[b] || n.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = xb(a, b, d)), "normal" === e && b in Db && (e = Db[b]), "" === c || c ? (f = parseFloat(e), c === !0 || n.isNumeric(f) ? f || 0 : e) : e
    }
  }), n.each(["height", "width"], function(a, b) {
    n.cssHooks[b] = {
      get: function(a, c, d) {
        return c ? zb.test(n.css(a, "display")) && 0 === a.offsetWidth ? n.swap(a, Cb, function() {
          return Ib(a, b, d)
        }) : Ib(a, b, d) : void 0
      },
      set: function(a, c, d) {
        var e = d && wb(a);
        return Gb(a, c, d ? Hb(a, b, d, "border-box" === n.css(a, "boxSizing", !1, e), e) : 0)
      }
    }
  }), n.cssHooks.marginRight = yb(k.reliableMarginRight, function(a, b) {
    return b ? n.swap(a, {
      display: "inline-block"
    }, xb, [a, "marginRight"]) : void 0
  }), n.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(a, b) {
    n.cssHooks[a + b] = {
      expand: function(c) {
        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++) e[a + R[d] + b] = f[d] || f[d - 2] || f[0];
        return e
      }
    }, ub.test(a) || (n.cssHooks[a + b].set = Gb)
  }), n.fn.extend({
    css: function(a, b) {
      return J(this, function(a, b, c) {
        var d, e, f = {},
          g = 0;
        if (n.isArray(b)) {
          for (d = wb(a), e = b.length; e > g; g++) f[b[g]] = n.css(a, b[g], !1, d);
          return f
        }
        return void 0 !== c ? n.style(a, b, c) : n.css(a, b)
      }, a, b, arguments.length > 1)
    },
    show: function() {
      return Jb(this, !0)
    },
    hide: function() {
      return Jb(this)
    },
    toggle: function(a) {
      return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
        S(this) ? n(this).show() : n(this).hide()
      })
    }
  });

  function Kb(a, b, c, d, e) {
    return new Kb.prototype.init(a, b, c, d, e)
  }
  n.Tween = Kb, Kb.prototype = {
    constructor: Kb,
    init: function(a, b, c, d, e, f) {
      this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? "" : "px")
    },
    cur: function() {
      var a = Kb.propHooks[this.prop];
      return a && a.get ? a.get(this) : Kb.propHooks._default.get(this)
    },
    run: function(a) {
      var b, c = Kb.propHooks[this.prop];
      return this.pos = b = this.options.duration ? n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Kb.propHooks._default.set(this), this
    }
  }, Kb.prototype.init.prototype = Kb.prototype, Kb.propHooks = {
    _default: {
      get: function(a) {
        var b;
        return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = n.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0) : a.elem[a.prop]
      },
      set: function(a) {
        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[n.cssProps[a.prop]] || n.cssHooks[a.prop]) ? n.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now
      }
    }
  }, Kb.propHooks.scrollTop = Kb.propHooks.scrollLeft = {
    set: function(a) {
      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
    }
  }, n.easing = {
    linear: function(a) {
      return a
    },
    swing: function(a) {
      return .5 - Math.cos(a * Math.PI) / 2
    }
  }, n.fx = Kb.prototype.init, n.fx.step = {};
  var Lb, Mb, Nb = /^(?:toggle|show|hide)$/,
    Ob = new RegExp("^(?:([+-])=|)(" + Q + ")([a-z%]*)$", "i"),
    Pb = /queueHooks$/,
    Qb = [Vb],
    Rb = {
      "*": [function(a, b) {
        var c = this.createTween(a, b),
          d = c.cur(),
          e = Ob.exec(b),
          f = e && e[3] || (n.cssNumber[a] ? "" : "px"),
          g = (n.cssNumber[a] || "px" !== f && +d) && Ob.exec(n.css(c.elem, a)),
          h = 1,
          i = 20;
        if (g && g[3] !== f) {
          f = f || g[3], e = e || [], g = +d || 1;
          do h = h || ".5", g /= h, n.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i)
        }
        return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c
      }]
    };

  function Sb() {
    return setTimeout(function() {
      Lb = void 0
    }), Lb = n.now()
  }

  function Tb(a, b) {
    var c, d = 0,
      e = {
        height: a
      };
    for (b = b ? 1 : 0; 4 > d; d += 2 - b) c = R[d], e["margin" + c] = e["padding" + c] = a;
    return b && (e.opacity = e.width = a), e
  }

  function Ub(a, b, c) {
    for (var d, e = (Rb[b] || []).concat(Rb["*"]), f = 0, g = e.length; g > f; f++)
      if (d = e[f].call(c, b, a)) return d
  }

  function Vb(a, b, c) {
    var d, e, f, g, h, i, j, k, l = this,
      m = {},
      o = a.style,
      p = a.nodeType && S(a),
      q = L.get(a, "fxshow");
    c.queue || (h = n._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {
      h.unqueued || i()
    }), h.unqueued++, l.always(function() {
      l.always(function() {
        h.unqueued--, n.queue(a, "fx").length || h.empty.fire()
      })
    })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, "display"), k = "none" === j ? L.get(a, "olddisplay") || tb(a.nodeName) : j, "inline" === k && "none" === n.css(a, "float") && (o.display = "inline-block")), c.overflow && (o.overflow = "hidden", l.always(function() {
      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2]
    }));
    for (d in b)
      if (e = b[d], Nb.exec(e)) {
        if (delete b[d], f = f || "toggle" === e, e === (p ? "hide" : "show")) {
          if ("show" !== e || !q || void 0 === q[d]) continue;
          p = !0
        }
        m[d] = q && q[d] || n.style(a, d)
      } else j = void 0;
    if (n.isEmptyObject(m)) "inline" === ("none" === j ? tb(a.nodeName) : j) && (o.display = j);
    else {
      q ? "hidden" in q && (p = q.hidden) : q = L.access(a, "fxshow", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function() {
        n(a).hide()
      }), l.done(function() {
        var b;
        L.remove(a, "fxshow");
        for (b in m) n.style(a, b, m[b])
      });
      for (d in m) g = Ub(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0))
    }
  }

  function Wb(a, b) {
    var c, d, e, f, g;
    for (c in a)
      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && "expand" in g) {
        f = g.expand(f), delete a[d];
        for (c in f) c in a || (a[c] = f[c], b[c] = e)
      } else b[d] = e
  }

  function Xb(a, b, c) {
    var d, e, f = 0,
      g = Qb.length,
      h = n.Deferred().always(function() {
        delete i.elem
      }),
      i = function() {
        if (e) return !1;
        for (var b = Lb || Sb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
        return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1)
      },
      j = h.promise({
        elem: a,
        props: n.extend({}, b),
        opts: n.extend(!0, {
          specialEasing: {}
        }, c),
        originalProperties: b,
        originalOptions: c,
        startTime: Lb || Sb(),
        duration: c.duration,
        tweens: [],
        createTween: function(b, c) {
          var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
          return j.tweens.push(d), d
        },
        stop: function(b) {
          var c = 0,
            d = b ? j.tweens.length : 0;
          if (e) return this;
          for (e = !0; d > c; c++) j.tweens[c].run(1);
          return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this
        }
      }),
      k = j.props;
    for (Wb(k, j.opts.specialEasing); g > f; f++)
      if (d = Qb[f].call(j, a, k, j.opts)) return d;
    return n.map(k, Ub, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, {
      elem: a,
      anim: j,
      queue: j.opts.queue
    })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)
  }
  n.Animation = n.extend(Xb, {
      tweener: function(a, b) {
        n.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" ");
        for (var c, d = 0, e = a.length; e > d; d++) c = a[d], Rb[c] = Rb[c] || [], Rb[c].unshift(b)
      },
      prefilter: function(a, b) {
        b ? Qb.unshift(a) : Qb.push(a)
      }
    }), n.speed = function(a, b, c) {
      var d = a && "object" == typeof a ? n.extend({}, a) : {
        complete: c || !c && b || n.isFunction(a) && a,
        duration: a,
        easing: c && b || b && !n.isFunction(b) && b
      };
      return d.duration = n.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function() {
        n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue)
      }, d
    }, n.fn.extend({
      fadeTo: function(a, b, c, d) {
        return this.filter(S).css("opacity", 0).show().end().animate({
          opacity: b
        }, a, c, d)
      },
      animate: function(a, b, c, d) {
        var e = n.isEmptyObject(a),
          f = n.speed(b, c, d),
          g = function() {
            var b = Xb(this, n.extend({}, a), f);
            (e || L.get(this, "finish")) && b.stop(!0)
          };
        return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
      },
      stop: function(a, b, c) {
        var d = function(a) {
          var b = a.stop;
          delete a.stop, b(c)
        };
        return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function() {
          var b = !0,
            e = null != a && a + "queueHooks",
            f = n.timers,
            g = L.get(this);
          if (e) g[e] && g[e].stop && d(g[e]);
          else
            for (e in g) g[e] && g[e].stop && Pb.test(e) && d(g[e]);
          for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
          (b || !c) && n.dequeue(this, a)
        })
      },
      finish: function(a) {
        return a !== !1 && (a = a || "fx"), this.each(function() {
          var b, c = L.get(this),
            d = c[a + "queue"],
            e = c[a + "queueHooks"],
            f = n.timers,
            g = d ? d.length : 0;
          for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
          for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
          delete c.finish
        })
      }
    }), n.each(["toggle", "show", "hide"], function(a, b) {
      var c = n.fn[b];
      n.fn[b] = function(a, d, e) {
        return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(Tb(b, !0), a, d, e)
      }
    }), n.each({
      slideDown: Tb("show"),
      slideUp: Tb("hide"),
      slideToggle: Tb("toggle"),
      fadeIn: {
        opacity: "show"
      },
      fadeOut: {
        opacity: "hide"
      },
      fadeToggle: {
        opacity: "toggle"
      }
    }, function(a, b) {
      n.fn[a] = function(a, c, d) {
        return this.animate(b, a, c, d)
      }
    }), n.timers = [], n.fx.tick = function() {
      var a, b = 0,
        c = n.timers;
      for (Lb = n.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);
      c.length || n.fx.stop(), Lb = void 0
    }, n.fx.timer = function(a) {
      n.timers.push(a), a() ? n.fx.start() : n.timers.pop()
    }, n.fx.interval = 13, n.fx.start = function() {
      Mb || (Mb = setInterval(n.fx.tick, n.fx.interval))
    }, n.fx.stop = function() {
      clearInterval(Mb), Mb = null
    }, n.fx.speeds = {
      slow: 600,
      fast: 200,
      _default: 400
    }, n.fn.delay = function(a, b) {
      return a = n.fx ? n.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
        var d = setTimeout(b, a);
        c.stop = function() {
          clearTimeout(d)
        }
      })
    },
    function() {
      var a = l.createElement("input"),
        b = l.createElement("select"),
        c = b.appendChild(l.createElement("option"));
      a.type = "checkbox", k.checkOn = "" !== a.value, k.optSelected = c.selected, b.disabled = !0, k.optDisabled = !c.disabled, a = l.createElement("input"), a.value = "t", a.type = "radio", k.radioValue = "t" === a.value
    }();
  var Yb, Zb, $b = n.expr.attrHandle;
  n.fn.extend({
    attr: function(a, b) {
      return J(this, n.attr, a, b, arguments.length > 1)
    },
    removeAttr: function(a) {
      return this.each(function() {
        n.removeAttr(this, a)
      })
    }
  }), n.extend({
    attr: function(a, b, c) {
      var d, e, f = a.nodeType;
      if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === U ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), d = n.attrHooks[b] || (n.expr.match.bool.test(b) ? Zb : Yb)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = n.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void n.removeAttr(a, b))
    },
    removeAttr: function(a, b) {
      var c, d, e = 0,
        f = b && b.match(E);
      if (f && 1 === a.nodeType)
        while (c = f[e++]) d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c)
    },
    attrHooks: {
      type: {
        set: function(a, b) {
          if (!k.radioValue && "radio" === b && n.nodeName(a, "input")) {
            var c = a.value;
            return a.setAttribute("type", b), c && (a.value = c), b
          }
        }
      }
    }
  }), Zb = {
    set: function(a, b, c) {
      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c
    }
  }, n.each(n.expr.match.bool.source.match(/\w+/g), function(a, b) {
    var c = $b[b] || n.find.attr;
    $b[b] = function(a, b, d) {
      var e, f;
      return d || (f = $b[b], $b[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, $b[b] = f), e
    }
  });
  var _b = /^(?:input|select|textarea|button)$/i;
  n.fn.extend({
    prop: function(a, b) {
      return J(this, n.prop, a, b, arguments.length > 1)
    },
    removeProp: function(a) {
      return this.each(function() {
        delete this[n.propFix[a] || a]
      })
    }
  }), n.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function(a, b, c) {
      var d, e, f, g = a.nodeType;
      if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !n.isXMLDoc(a), f && (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
    },
    propHooks: {
      tabIndex: {
        get: function(a) {
          return a.hasAttribute("tabindex") || _b.test(a.nodeName) || a.href ? a.tabIndex : -1
        }
      }
    }
  }), k.optSelected || (n.propHooks.selected = {
    get: function(a) {
      var b = a.parentNode;
      return b && b.parentNode && b.parentNode.selectedIndex, null
    }
  }), n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    n.propFix[this.toLowerCase()] = this
  });
  var ac = /[\t\r\n\f]/g;
  n.fn.extend({
    addClass: function(a) {
      var b, c, d, e, f, g, h = "string" == typeof a && a,
        i = 0,
        j = this.length;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).addClass(a.call(this, b, this.className))
      });
      if (h)
        for (b = (a || "").match(E) || []; j > i; i++)
          if (c = this[i], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ac, " ") : " ")) {
            f = 0;
            while (e = b[f++]) d.indexOf(" " + e + " ") < 0 && (d += e + " ");
            g = n.trim(d), c.className !== g && (c.className = g)
          }
      return this
    },
    removeClass: function(a) {
      var b, c, d, e, f, g, h = 0 === arguments.length || "string" == typeof a && a,
        i = 0,
        j = this.length;
      if (n.isFunction(a)) return this.each(function(b) {
        n(this).removeClass(a.call(this, b, this.className))
      });
      if (h)
        for (b = (a || "").match(E) || []; j > i; i++)
          if (c = this[i], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ac, " ") : "")) {
            f = 0;
            while (e = b[f++])
              while (d.indexOf(" " + e + " ") >= 0) d = d.replace(" " + e + " ", " ");
            g = a ? n.trim(d) : "", c.className !== g && (c.className = g)
          }
      return this
    },
    toggleClass: function(a, b) {
      var c = typeof a;
      return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(n.isFunction(a) ? function(c) {
        n(this).toggleClass(a.call(this, c, this.className, b), b)
      } : function() {
        if ("string" === c) {
          var b, d = 0,
            e = n(this),
            f = a.match(E) || [];
          while (b = f[d++]) e.hasClass(b) ? e.removeClass(b) : e.addClass(b)
        } else(c === U || "boolean" === c) && (this.className && L.set(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : L.get(this, "__className__") || "")
      })
    },
    hasClass: function(a) {
      for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++)
        if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(ac, " ").indexOf(b) >= 0) return !0;
      return !1
    }
  });
  var bc = /\r/g;
  n.fn.extend({
    val: function(a) {
      var b, c, d, e = this[0]; {
        if (arguments.length) return d = n.isFunction(a), this.each(function(c) {
          var e;
          1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : n.isArray(e) && (e = n.map(e, function(a) {
            return null == a ? "" : a + ""
          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e))
        });
        if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(bc, "") : null == c ? "" : c)
      }
    }
  }), n.extend({
    valHooks: {
      option: {
        get: function(a) {
          var b = n.find.attr(a, "value");
          return null != b ? b : n.trim(n.text(a))
        }
      },
      select: {
        get: function(a) {
          for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)
            if (c = d[i], !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && n.nodeName(c.parentNode, "optgroup"))) {
              if (b = n(c).val(), f) return b;
              g.push(b)
            }
          return g
        },
        set: function(a, b) {
          var c, d, e = a.options,
            f = n.makeArray(b),
            g = e.length;
          while (g--) d = e[g], (d.selected = n.inArray(d.value, f) >= 0) && (c = !0);
          return c || (a.selectedIndex = -1), f
        }
      }
    }
  }), n.each(["radio", "checkbox"], function() {
    n.valHooks[this] = {
      set: function(a, b) {
        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) >= 0 : void 0
      }
    }, k.checkOn || (n.valHooks[this].get = function(a) {
      return null === a.getAttribute("value") ? "on" : a.value
    })
  }), n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
    n.fn[b] = function(a, c) {
      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
    }
  }), n.fn.extend({
    hover: function(a, b) {
      return this.mouseenter(a).mouseleave(b || a)
    },
    bind: function(a, b, c) {
      return this.on(a, null, b, c)
    },
    unbind: function(a, b) {
      return this.off(a, null, b)
    },
    delegate: function(a, b, c, d) {
      return this.on(b, a, c, d)
    },
    undelegate: function(a, b, c) {
      return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
    }
  });
  var cc = n.now(),
    dc = /\?/;
  n.parseJSON = function(a) {
    return JSON.parse(a + "")
  }, n.parseXML = function(a) {
    var b, c;
    if (!a || "string" != typeof a) return null;
    try {
      c = new DOMParser, b = c.parseFromString(a, "text/xml")
    } catch (d) {
      b = void 0
    }
    return (!b || b.getElementsByTagName("parsererror").length) && n.error("Invalid XML: " + a), b
  };
  var ec = /#.*$/,
    fc = /([?&])_=[^&]*/,
    gc = /^(.*?):[ \t]*([^\r\n]*)$/gm,
    hc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    ic = /^(?:GET|HEAD)$/,
    jc = /^\/\//,
    kc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    lc = {},
    mc = {},
    nc = "*/".concat("*"),
    oc = a.location.href,
    pc = kc.exec(oc.toLowerCase()) || [];

  function qc(a) {
    return function(b, c) {
      "string" != typeof b && (c = b, b = "*");
      var d, e = 0,
        f = b.toLowerCase().match(E) || [];
      if (n.isFunction(c))
        while (d = f[e++]) "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
    }
  }

  function rc(a, b, c, d) {
    var e = {},
      f = a === mc;

    function g(h) {
      var i;
      return e[h] = !0, n.each(a[h] || [], function(a, h) {
        var j = h(b, c, d);
        return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1)
      }), i
    }
    return g(b.dataTypes[0]) || !e["*"] && g("*")
  }

  function sc(a, b) {
    var c, d, e = n.ajaxSettings.flatOptions || {};
    for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
    return d && n.extend(!0, a, d), a
  }

  function tc(a, b, c) {
    var d, e, f, g, h = a.contents,
      i = a.dataTypes;
    while ("*" === i[0]) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
    if (d)
      for (e in h)
        if (h[e] && h[e].test(d)) {
          i.unshift(e);
          break
        }
    if (i[0] in c) f = i[0];
    else {
      for (e in c) {
        if (!i[0] || a.converters[e + " " + i[0]]) {
          f = e;
          break
        }
        g || (g = e)
      }
      f = f || g
    }
    return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0
  }

  function uc(a, b, c, d) {
    var e, f, g, h, i, j = {},
      k = a.dataTypes.slice();
    if (k[1])
      for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
    f = k.shift();
    while (f)
      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
        if ("*" === f) f = i;
        else if ("*" !== i && i !== f) {
      if (g = j[i + " " + f] || j["* " + f], !g)
        for (e in j)
          if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
            break
          }
      if (g !== !0)
        if (g && a["throws"]) b = g(b);
        else try {
          b = g(b)
        } catch (l) {
          return {
            state: "parsererror",
            error: g ? l : "No conversion from " + i + " to " + f
          }
        }
    }
    return {
      state: "success",
      data: b
    }
  }
  n.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: oc,
      type: "GET",
      isLocal: hc.test(pc[1]),
      global: !0,
      processData: !0,
      async: !0,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": nc,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": !0,
        "text json": n.parseJSON,
        "text xml": n.parseXML
      },
      flatOptions: {
        url: !0,
        context: !0
      }
    },
    ajaxSetup: function(a, b) {
      return b ? sc(sc(a, n.ajaxSettings), b) : sc(n.ajaxSettings, a)
    },
    ajaxPrefilter: qc(lc),
    ajaxTransport: qc(mc),
    ajax: function(a, b) {
      "object" == typeof a && (b = a, a = void 0), b = b || {};
      var c, d, e, f, g, h, i, j, k = n.ajaxSetup({}, b),
        l = k.context || k,
        m = k.context && (l.nodeType || l.jquery) ? n(l) : n.event,
        o = n.Deferred(),
        p = n.Callbacks("once memory"),
        q = k.statusCode || {},
        r = {},
        s = {},
        t = 0,
        u = "canceled",
        v = {
          readyState: 0,
          getResponseHeader: function(a) {
            var b;
            if (2 === t) {
              if (!f) {
                f = {};
                while (b = gc.exec(e)) f[b[1].toLowerCase()] = b[2]
              }
              b = f[a.toLowerCase()]
            }
            return null == b ? null : b
          },
          getAllResponseHeaders: function() {
            return 2 === t ? e : null
          },
          setRequestHeader: function(a, b) {
            var c = a.toLowerCase();
            return t || (a = s[c] = s[c] || a, r[a] = b), this
          },
          overrideMimeType: function(a) {
            return t || (k.mimeType = a), this
          },
          statusCode: function(a) {
            var b;
            if (a)
              if (2 > t)
                for (b in a) q[b] = [q[b], a[b]];
              else v.always(a[v.status]);
            return this
          },
          abort: function(a) {
            var b = a || u;
            return c && c.abort(b), x(0, b), this
          }
        };
      if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || oc) + "").replace(ec, "").replace(jc, pc[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = n.trim(k.dataType || "*").toLowerCase().match(E) || [""], null == k.crossDomain && (h = kc.exec(k.url.toLowerCase()), k.crossDomain = !(!h || h[1] === pc[1] && h[2] === pc[2] && (h[3] || ("http:" === h[1] ? "80" : "443")) === (pc[3] || ("http:" === pc[1] ? "80" : "443")))), k.data && k.processData && "string" != typeof k.data && (k.data = n.param(k.data, k.traditional)), rc(lc, k, b, v), 2 === t) return v;
      i = n.event && k.global, i && 0 === n.active++ && n.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !ic.test(k.type), d = k.url, k.hasContent || (k.data && (d = k.url += (dc.test(d) ? "&" : "?") + k.data, delete k.data), k.cache === !1 && (k.url = fc.test(d) ? d.replace(fc, "$1_=" + cc++) : d + (dc.test(d) ? "&" : "?") + "_=" + cc++)), k.ifModified && (n.lastModified[d] && v.setRequestHeader("If-Modified-Since", n.lastModified[d]), n.etag[d] && v.setRequestHeader("If-None-Match", n.etag[d])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + nc + "; q=0.01" : "") : k.accepts["*"]);
      for (j in k.headers) v.setRequestHeader(j, k.headers[j]);
      if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();
      u = "abort";
      for (j in {
          success: 1,
          error: 1,
          complete: 1
        }) v[j](k[j]);
      if (c = rc(mc, k, b, v)) {
        v.readyState = 1, i && m.trigger("ajaxSend", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function() {
          v.abort("timeout")
        }, k.timeout));
        try {
          t = 1, c.send(r, x)
        } catch (w) {
          if (!(2 > t)) throw w;
          x(-1, w)
        }
      } else x(-1, "No Transport");

      function x(a, b, f, h) {
        var j, r, s, u, w, x = b;
        2 !== t && (t = 2, g && clearTimeout(g), c = void 0, e = h || "", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, f && (u = tc(k, v, f)), u = uc(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (n.lastModified[d] = w), w = v.getResponseHeader("etag"), w && (n.etag[d] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, i && m.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), i && (m.trigger("ajaxComplete", [v, k]), --n.active || n.event.trigger("ajaxStop")))
      }
      return v
    },
    getJSON: function(a, b, c) {
      return n.get(a, b, c, "json")
    },
    getScript: function(a, b) {
      return n.get(a, void 0, b, "script")
    }
  }), n.each(["get", "post"], function(a, b) {
    n[b] = function(a, c, d, e) {
      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax({
        url: a,
        type: b,
        dataType: e,
        data: c,
        success: d
      })
    }
  }), n._evalUrl = function(a) {
    return n.ajax({
      url: a,
      type: "GET",
      dataType: "script",
      async: !1,
      global: !1,
      "throws": !0
    })
  }, n.fn.extend({
    wrapAll: function(a) {
      var b;
      return n.isFunction(a) ? this.each(function(b) {
        n(this).wrapAll(a.call(this, b))
      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
        var a = this;
        while (a.firstElementChild) a = a.firstElementChild;
        return a
      }).append(this)), this)
    },
    wrapInner: function(a) {
      return this.each(n.isFunction(a) ? function(b) {
        n(this).wrapInner(a.call(this, b))
      } : function() {
        var b = n(this),
          c = b.contents();
        c.length ? c.wrapAll(a) : b.append(a)
      })
    },
    wrap: function(a) {
      var b = n.isFunction(a);
      return this.each(function(c) {
        n(this).wrapAll(b ? a.call(this, c) : a)
      })
    },
    unwrap: function() {
      return this.parent().each(function() {
        n.nodeName(this, "body") || n(this).replaceWith(this.childNodes)
      }).end()
    }
  }), n.expr.filters.hidden = function(a) {
    return a.offsetWidth <= 0 && a.offsetHeight <= 0
  }, n.expr.filters.visible = function(a) {
    return !n.expr.filters.hidden(a)
  };
  var vc = /%20/g,
    wc = /\[\]$/,
    xc = /\r?\n/g,
    yc = /^(?:submit|button|image|reset|file)$/i,
    zc = /^(?:input|select|textarea|keygen)/i;

  function Ac(a, b, c, d) {
    var e;
    if (n.isArray(b)) n.each(b, function(b, e) {
      c || wc.test(a) ? d(a, e) : Ac(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d)
    });
    else if (c || "object" !== n.type(b)) d(a, b);
    else
      for (e in b) Ac(a + "[" + e + "]", b[e], c, d)
  }
  n.param = function(a, b) {
    var c, d = [],
      e = function(a, b) {
        b = n.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
      };
    if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function() {
      e(this.name, this.value)
    });
    else
      for (c in a) Ac(c, a[c], b, e);
    return d.join("&").replace(vc, "+")
  }, n.fn.extend({
    serialize: function() {
      return n.param(this.serializeArray())
    },
    serializeArray: function() {
      return this.map(function() {
        var a = n.prop(this, "elements");
        return a ? n.makeArray(a) : this
      }).filter(function() {
        var a = this.type;
        return this.name && !n(this).is(":disabled") && zc.test(this.nodeName) && !yc.test(a) && (this.checked || !T.test(a))
      }).map(function(a, b) {
        var c = n(this).val();
        return null == c ? null : n.isArray(c) ? n.map(c, function(a) {
          return {
            name: b.name,
            value: a.replace(xc, "\r\n")
          }
        }) : {
          name: b.name,
          value: c.replace(xc, "\r\n")
        }
      }).get()
    }
  }), n.ajaxSettings.xhr = function() {
    try {
      return new XMLHttpRequest
    } catch (a) {}
  };
  var Bc = 0,
    Cc = {},
    Dc = {
      0: 200,
      1223: 204
    },
    Ec = n.ajaxSettings.xhr();
  a.attachEvent && a.attachEvent("onunload", function() {
    for (var a in Cc) Cc[a]()
  }), k.cors = !!Ec && "withCredentials" in Ec, k.ajax = Ec = !!Ec, n.ajaxTransport(function(a) {
    var b;
    return k.cors || Ec && !a.crossDomain ? {
      send: function(c, d) {
        var e, f = a.xhr(),
          g = ++Bc;
        if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields)
          for (e in a.xhrFields) f[e] = a.xhrFields[e];
        a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
        for (e in c) f.setRequestHeader(e, c[e]);
        b = function(a) {
          return function() {
            b && (delete Cc[g], b = f.onload = f.onerror = null, "abort" === a ? f.abort() : "error" === a ? d(f.status, f.statusText) : d(Dc[f.status] || f.status, f.statusText, "string" == typeof f.responseText ? {
              text: f.responseText
            } : void 0, f.getAllResponseHeaders()))
          }
        }, f.onload = b(), f.onerror = b("error"), b = Cc[g] = b("abort");
        try {
          f.send(a.hasContent && a.data || null)
        } catch (h) {
          if (b) throw h
        }
      },
      abort: function() {
        b && b()
      }
    } : void 0
  }), n.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /(?:java|ecma)script/
    },
    converters: {
      "text script": function(a) {
        return n.globalEval(a), a
      }
    }
  }), n.ajaxPrefilter("script", function(a) {
    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET")
  }), n.ajaxTransport("script", function(a) {
    if (a.crossDomain) {
      var b, c;
      return {
        send: function(d, e) {
          b = n("<script>").prop({
            async: !0,
            charset: a.scriptCharset,
            src: a.url
          }).on("load error", c = function(a) {
            b.remove(), c = null, a && e("error" === a.type ? 404 : 200, a.type)
          }), l.head.appendChild(b[0])
        },
        abort: function() {
          c && c()
        }
      }
    }
  });
  var Fc = [],
    Gc = /(=)\?(?=&|$)|\?\?/;
  n.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var a = Fc.pop() || n.expando + "_" + cc++;
      return this[a] = !0, a
    }
  }), n.ajaxPrefilter("json jsonp", function(b, c, d) {
    var e, f, g, h = b.jsonp !== !1 && (Gc.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && Gc.test(b.data) && "data");
    return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Gc, "$1" + e) : b.jsonp !== !1 && (b.url += (dc.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
      return g || n.error(e + " was not called"), g[0]
    }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
      g = arguments
    }, d.always(function() {
      a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Fc.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0
    }), "script") : void 0
  }), n.parseHTML = function(a, b, c) {
    if (!a || "string" != typeof a) return null;
    "boolean" == typeof b && (c = b, b = !1), b = b || l;
    var d = v.exec(a),
      e = !c && [];
    return d ? [b.createElement(d[1])] : (d = n.buildFragment([a], b, e), e && e.length && n(e).remove(), n.merge([], d.childNodes))
  };
  var Hc = n.fn.load;
  n.fn.load = function(a, b, c) {
    if ("string" != typeof a && Hc) return Hc.apply(this, arguments);
    var d, e, f, g = this,
      h = a.indexOf(" ");
    return h >= 0 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && n.ajax({
      url: a,
      type: e,
      dataType: "html",
      data: b
    }).done(function(a) {
      f = arguments, g.html(d ? n("<div>").append(n.parseHTML(a)).find(d) : a)
    }).complete(c && function(a, b) {
      g.each(c, f || [a.responseText, b, a])
    }), this
  }, n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
    n.fn[b] = function(a) {
      return this.on(b, a)
    }
  }), n.expr.filters.animated = function(a) {
    return n.grep(n.timers, function(b) {
      return a === b.elem
    }).length
  };
  var Ic = a.document.documentElement;

  function Jc(a) {
    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView
  }
  n.offset = {
    setOffset: function(a, b, c) {
      var d, e, f, g, h, i, j, k = n.css(a, "position"),
        l = n(a),
        m = {};
      "static" === k && (a.style.position = "relative"), h = l.offset(), f = n.css(a, "top"), i = n.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
    }
  }, n.fn.extend({
    offset: function(a) {
      if (arguments.length) return void 0 === a ? this : this.each(function(b) {
        n.offset.setOffset(this, a, b)
      });
      var b, c, d = this[0],
        e = {
          top: 0,
          left: 0
        },
        f = d && d.ownerDocument;
      if (f) return b = f.documentElement, n.contains(b, d) ? (typeof d.getBoundingClientRect !== U && (e = d.getBoundingClientRect()), c = Jc(f), {
        top: e.top + c.pageYOffset - b.clientTop,
        left: e.left + c.pageXOffset - b.clientLeft
      }) : e
    },
    position: function() {
      if (this[0]) {
        var a, b, c = this[0],
          d = {
            top: 0,
            left: 0
          };
        return "fixed" === n.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], "html") || (d = a.offset()), d.top += n.css(a[0], "borderTopWidth", !0), d.left += n.css(a[0], "borderLeftWidth", !0)), {
          top: b.top - d.top - n.css(c, "marginTop", !0),
          left: b.left - d.left - n.css(c, "marginLeft", !0)
        }
      }
    },
    offsetParent: function() {
      return this.map(function() {
        var a = this.offsetParent || Ic;
        while (a && !n.nodeName(a, "html") && "static" === n.css(a, "position")) a = a.offsetParent;
        return a || Ic
      })
    }
  }), n.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(b, c) {
    var d = "pageYOffset" === c;
    n.fn[b] = function(e) {
      return J(this, function(b, e, f) {
        var g = Jc(b);
        return void 0 === f ? g ? g[c] : b[e] : void(g ? g.scrollTo(d ? a.pageXOffset : f, d ? f : a.pageYOffset) : b[e] = f)
      }, b, e, arguments.length, null)
    }
  }), n.each(["top", "left"], function(a, b) {
    n.cssHooks[b] = yb(k.pixelPosition, function(a, c) {
      return c ? (c = xb(a, b), vb.test(c) ? n(a).position()[b] + "px" : c) : void 0
    })
  }), n.each({
    Height: "height",
    Width: "width"
  }, function(a, b) {
    n.each({
      padding: "inner" + a,
      content: b,
      "": "outer" + a
    }, function(c, d) {
      n.fn[d] = function(d, e) {
        var f = arguments.length && (c || "boolean" != typeof d),
          g = c || (d === !0 || e === !0 ? "margin" : "border");
        return J(this, function(b, c, d) {
          var e;
          return n.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g)
        }, b, f ? d : void 0, f, null)
      }
    })
  }), n.fn.size = function() {
    return this.length
  }, n.fn.andSelf = n.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
    return n
  });
  var Kc = a.jQuery,
    Lc = a.$;
  return n.noConflict = function(b) {
    return a.$ === n && (a.$ = Lc), b && a.jQuery === n && (a.jQuery = Kc), n
  }, typeof b === U && (a.jQuery = a.$ = n), n
});
! function(e) {
  "function" == typeof define && define.amd ? define(["jquery"], e) : "object" == typeof exports ? module.exports = e(require("jquery")) : e(jQuery)
}(function(e) {
  function n(e) {
    return u.raw ? e : encodeURIComponent(e)
  }

  function o(e) {
    return u.raw ? e : decodeURIComponent(e)
  }

  function i(e) {
    return n(u.json ? JSON.stringify(e) : String(e))
  }

  function t(e) {
    0 === e.indexOf('"') && (e = e.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, "\\"));
    try {
      return e = decodeURIComponent(e.replace(c, " ")), u.json ? JSON.parse(e) : e
    } catch (n) {}
  }

  function r(n, o) {
    var i = u.raw ? n : t(n);
    return e.isFunction(o) ? o(i) : i
  }
  var c = /\+/g,
    u = e.cookie = function(t, c, s) {
      if (arguments.length > 1 && !e.isFunction(c)) {
        if (s = e.extend({}, u.defaults, s), "number" == typeof s.expires) {
          var a = s.expires,
            d = s.expires = new Date;
          d.setMilliseconds(d.getMilliseconds() + 864e5 * a)
        }
        return document.cookie = [n(t), "=", i(c), s.expires ? "; expires=" + s.expires.toUTCString() : "", s.path ? "; path=" + s.path : "", s.domain ? "; domain=" + s.domain : "", s.secure ? "; secure" : ""].join("")
      }
      for (var f = t ? void 0 : {}, p = document.cookie ? document.cookie.split("; ") : [], l = 0, m = p.length; m > l; l++) {
        var x = p[l].split("="),
          g = o(x.shift()),
          j = x.join("=");
        if (t === g) {
          f = r(j, c);
          break
        }
        t || void 0 === (j = r(j)) || (f[g] = j)
      }
      return f
    };
  u.defaults = {}, e.removeCookie = function(n, o) {
    return e.cookie(n, "", e.extend({}, o, {
      expires: -1
    })), !e.cookie(n)
  }
});

// threejs.org/license
'use strict';
var THREE = {
  REVISION: "70"
};
"object" === typeof module && (module.exports = THREE);
void 0 === Math.sign && (Math.sign = function(a) {
  return 0 > a ? -1 : 0 < a ? 1 : 0
});
THREE.MOUSE = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.UVMapping = 300;
THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;
THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;
THREE.SphericalReflectionMapping = 305;
THREE.RepeatWrapping = 1E3;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGBEFormat = THREE.RGBAFormat;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
THREE.Projector = function() {
  console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
  this.projectVector = function(a, b) {
    console.warn("THREE.Projector: .projectVector() is now vector.project().");
    a.project(b)
  };
  this.unprojectVector = function(a, b) {
    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
    a.unproject(b)
  };
  this.pickingRay = function(a, b) {
    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
  }
};
THREE.CanvasRenderer = function() {
  console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
  this.domElement = document.createElement("canvas");
  this.clear = function() {};
  this.render = function() {};
  this.setClearColor = function() {};
  this.setSize = function() {}
};
THREE.Color = function(a) {
  return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a)
};
THREE.Color.prototype = {
  constructor: THREE.Color,
  r: 1,
  g: 1,
  b: 1,
  set: function(a) {
    a instanceof THREE.Color ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
    return this
  },
  setHex: function(a) {
    a = Math.floor(a);
    this.r = (a >> 16 & 255) / 255;
    this.g = (a >> 8 & 255) / 255;
    this.b = (a & 255) / 255;
    return this
  },
  setRGB: function(a, b, c) {
    this.r = a;
    this.g = b;
    this.b = c;
    return this
  },
  setHSL: function(a, b, c) {
    if (0 === b) this.r = this.g = this.b = c;
    else {
      var d = function(a, b, c) {
        0 > c && (c += 1);
        1 < c && (c -= 1);
        return c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a
      };
      b = .5 >= c ? c * (1 + b) : c + b - c * b;
      c = 2 * c - b;
      this.r = d(c, b, a + 1 / 3);
      this.g = d(c, b, a);
      this.b = d(c, b, a - 1 / 3)
    }
    return this
  },
  setStyle: function(a) {
    if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a)) return a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a), this.r = Math.min(255, parseInt(a[1], 10)) / 255, this.g = Math.min(255, parseInt(a[2], 10)) / 255, this.b = Math.min(255, parseInt(a[3], 10)) / 255, this;
    if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a)) return a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a), this.r = Math.min(100, parseInt(a[1], 10)) / 100, this.g = Math.min(100, parseInt(a[2], 10)) / 100, this.b = Math.min(100, parseInt(a[3], 10)) / 100, this;
    if (/^\#([0-9a-f]{6})$/i.test(a)) return a = /^\#([0-9a-f]{6})$/i.exec(a), this.setHex(parseInt(a[1], 16)), this;
    if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a)) return a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a), this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)), this;
    if (/^(\w+)$/i.test(a)) return this.setHex(THREE.ColorKeywords[a]), this
  },
  copy: function(a) {
    this.r = a.r;
    this.g = a.g;
    this.b = a.b;
    return this
  },
  copyGammaToLinear: function(a) {
    this.r = a.r * a.r;
    this.g = a.g * a.g;
    this.b = a.b * a.b;
    return this
  },
  copyLinearToGamma: function(a) {
    this.r = Math.sqrt(a.r);
    this.g = Math.sqrt(a.g);
    this.b = Math.sqrt(a.b);
    return this
  },
  convertGammaToLinear: function() {
    var a = this.r,
      b = this.g,
      c = this.b;
    this.r = a * a;
    this.g = b * b;
    this.b = c * c;
    return this
  },
  convertLinearToGamma: function() {
    this.r = Math.sqrt(this.r);
    this.g = Math.sqrt(this.g);
    this.b = Math.sqrt(this.b);
    return this
  },
  getHex: function() {
    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
  },
  getHexString: function() {
    return ("000000" + this.getHex().toString(16)).slice(-6)
  },
  getHSL: function(a) {
    a = a || {
      h: 0,
      s: 0,
      l: 0
    };
    var b = this.r,
      c = this.g,
      d = this.b,
      e = Math.max(b, c, d),
      f = Math.min(b, c, d),
      g, h = (f + e) / 2;
    if (f === e) f = g = 0;
    else {
      var k = e - f,
        f = .5 >= h ? k / (e + f) : k / (2 - e - f);
      switch (e) {
        case b:
          g = (c - d) / k + (c < d ? 6 : 0);
          break;
        case c:
          g = (d - b) / k + 2;
          break;
        case d:
          g = (b - c) / k + 4
      }
      g /= 6
    }
    a.h = g;
    a.s = f;
    a.l = h;
    return a
  },
  getStyle: function() {
    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
  },
  offsetHSL: function(a, b, c) {
    var d = this.getHSL();
    d.h += a;
    d.s += b;
    d.l += c;
    this.setHSL(d.h, d.s, d.l);
    return this
  },
  add: function(a) {
    this.r += a.r;
    this.g += a.g;
    this.b += a.b;
    return this
  },
  addColors: function(a, b) {
    this.r = a.r + b.r;
    this.g = a.g + b.g;
    this.b = a.b + b.b;
    return this
  },
  addScalar: function(a) {
    this.r += a;
    this.g += a;
    this.b += a;
    return this
  },
  multiply: function(a) {
    this.r *= a.r;
    this.g *= a.g;
    this.b *= a.b;
    return this
  },
  multiplyScalar: function(a) {
    this.r *= a;
    this.g *= a;
    this.b *= a;
    return this
  },
  lerp: function(a, b) {
    this.r += (a.r - this.r) * b;
    this.g += (a.g - this.g) * b;
    this.b += (a.b - this.b) * b;
    return this
  },
  equals: function(a) {
    return a.r === this.r && a.g === this.g && a.b === this.b
  },
  fromArray: function(a) {
    this.r = a[0];
    this.g = a[1];
    this.b = a[2];
    return this
  },
  toArray: function() {
    return [this.r, this.g, this.b]
  },
  clone: function() {
    return (new THREE.Color).setRGB(this.r, this.g, this.b)
  }
};
THREE.ColorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
THREE.Quaternion = function(a, b, c, d) {
  this._x = a || 0;
  this._y = b || 0;
  this._z = c || 0;
  this._w = void 0 !== d ? d : 1
};
THREE.Quaternion.prototype = {
  constructor: THREE.Quaternion,
  _x: 0,
  _y: 0,
  _z: 0,
  _w: 0,
  get x() {
    return this._x
  },
  set x(a) {
    this._x = a;
    this.onChangeCallback()
  },
  get y() {
    return this._y
  },
  set y(a) {
    this._y = a;
    this.onChangeCallback()
  },
  get z() {
    return this._z
  },
  set z(a) {
    this._z = a;
    this.onChangeCallback()
  },
  get w() {
    return this._w
  },
  set w(a) {
    this._w = a;
    this.onChangeCallback()
  },
  set: function(a, b, c, d) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._w = d;
    this.onChangeCallback();
    return this
  },
  copy: function(a) {
    this._x = a.x;
    this._y = a.y;
    this._z = a.z;
    this._w = a.w;
    this.onChangeCallback();
    return this
  },
  setFromEuler: function(a, b) {
    if (!1 === a instanceof THREE.Euler) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    var c = Math.cos(a._x / 2),
      d = Math.cos(a._y / 2),
      e = Math.cos(a._z / 2),
      f = Math.sin(a._x / 2),
      g = Math.sin(a._y / 2),
      h = Math.sin(a._z / 2);
    "XYZ" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "YXZ" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "ZXY" === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "ZYX" === a.order ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "YZX" === a.order ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : "XZY" === a.order && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h);
    if (!1 !== b) this.onChangeCallback();
    return this
  },
  setFromAxisAngle: function(a, b) {
    var c = b / 2,
      d = Math.sin(c);
    this._x = a.x * d;
    this._y = a.y * d;
    this._z = a.z * d;
    this._w = Math.cos(c);
    this.onChangeCallback();
    return this
  },
  setFromRotationMatrix: function(a) {
    var b = a.elements,
      c = b[0];
    a = b[4];
    var d = b[8],
      e = b[1],
      f = b[5],
      g = b[9],
      h = b[2],
      k = b[6],
      b = b[10],
      n = c + f + b;
    0 < n ? (c = .5 / Math.sqrt(n + 1), this._w = .25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = .25 * c);
    this.onChangeCallback();
    return this
  },
  setFromUnitVectors: function() {
    var a, b;
    return function(c, d) {
      void 0 === a && (a = new THREE.Vector3);
      b = c.dot(d) + 1;
      1E-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d);
      this._x = a.x;
      this._y = a.y;
      this._z = a.z;
      this._w = b;
      this.normalize();
      return this
    }
  }(),
  inverse: function() {
    this.conjugate().normalize();
    return this
  },
  conjugate: function() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this.onChangeCallback();
    return this
  },
  dot: function(a) {
    return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
  },
  lengthSq: function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
  },
  length: function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
  },
  normalize: function() {
    var a = this.length();
    0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
    this.onChangeCallback();
    return this
  },
  multiply: function(a, b) {
    return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
  },
  multiplyQuaternions: function(a, b) {
    var c = a._x,
      d = a._y,
      e = a._z,
      f = a._w,
      g = b._x,
      h = b._y,
      k = b._z,
      n = b._w;
    this._x = c * n + f * g + d * k - e * h;
    this._y = d * n + f * h + e * g - c * k;
    this._z = e * n + f * k + c * h - d * g;
    this._w = f * n - c * g - d * h - e * k;
    this.onChangeCallback();
    return this
  },
  multiplyVector3: function(a) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return a.applyQuaternion(this)
  },
  slerp: function(a, b) {
    if (0 === b) return this;
    if (1 === b) return this.copy(a);
    var c = this._x,
      d = this._y,
      e = this._z,
      f = this._w,
      g = f * a._w + c * a._x + d * a._y + e * a._z;
    0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
    if (1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this;
    var h = Math.acos(g),
      k = Math.sqrt(1 - g * g);
    if (.001 > Math.abs(k)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
    g = Math.sin((1 - b) * h) / k;
    h = Math.sin(b * h) / k;
    this._w = f * g + this._w * h;
    this._x = c * g + this._x * h;
    this._y = d * g + this._y * h;
    this._z = e * g + this._z * h;
    this.onChangeCallback();
    return this
  },
  equals: function(a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
  },
  fromArray: function(a, b) {
    void 0 === b && (b = 0);
    this._x = a[b];
    this._y = a[b + 1];
    this._z = a[b + 2];
    this._w = a[b + 3];
    this.onChangeCallback();
    return this
  },
  toArray: function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this._x;
    a[b + 1] = this._y;
    a[b + 2] = this._z;
    a[b + 3] = this._w;
    return a
  },
  onChange: function(a) {
    this.onChangeCallback = a;
    return this
  },
  onChangeCallback: function() {},
  clone: function() {
    return new THREE.Quaternion(this._x, this._y, this._z, this._w)
  }
};
THREE.Quaternion.slerp = function(a, b, c, d) {
  return c.copy(a).slerp(b, d)
};
THREE.Vector2 = function(a, b) {
  this.x = a || 0;
  this.y = b || 0
};
THREE.Vector2.prototype = {
  constructor: THREE.Vector2,
  set: function(a, b) {
    this.x = a;
    this.y = b;
    return this
  },
  setX: function(a) {
    this.x = a;
    return this
  },
  setY: function(a) {
    this.y = a;
    return this
  },
  setComponent: function(a, b) {
    switch (a) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      default:
        throw Error("index is out of range: " + a);
    }
  },
  getComponent: function(a) {
    switch (a) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw Error("index is out of range: " + a);
    }
  },
  copy: function(a) {
    this.x = a.x;
    this.y = a.y;
    return this
  },
  add: function(a, b) {
    if (void 0 !== b) return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    return this
  },
  addVectors: function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this
  },
  addScalar: function(a) {
    this.x += a;
    this.y += a;
    return this
  },
  sub: function(a, b) {
    if (void 0 !== b) return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    return this
  },
  subVectors: function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this
  },
  multiply: function(a) {
    this.x *= a.x;
    this.y *= a.y;
    return this
  },
  multiplyScalar: function(a) {
    this.x *= a;
    this.y *= a;
    return this
  },
  divide: function(a) {
    this.x /= a.x;
    this.y /= a.y;
    return this
  },
  divideScalar: function(a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a) : this.y = this.x = 0;
    return this
  },
  min: function(a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    return this
  },
  max: function(a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    return this
  },
  clamp: function(a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    return this
  },
  clampScalar: function() {
    var a, b;
    return function(c, d) {
      void 0 === a && (a = new THREE.Vector2, b = new THREE.Vector2);
      a.set(c, c);
      b.set(d, d);
      return this.clamp(a, b)
    }
  }(),
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this
  },
  roundToZero: function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    return this
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    return this
  },
  dot: function(a) {
    return this.x * a.x + this.y * a.y
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  },
  normalize: function() {
    return this.divideScalar(this.length())
  },
  distanceTo: function(a) {
    return Math.sqrt(this.distanceToSquared(a))
  },
  distanceToSquared: function(a) {
    var b = this.x - a.x;
    a = this.y - a.y;
    return b * b + a * a
  },
  setLength: function(a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this
  },
  lerp: function(a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    return this
  },
  equals: function(a) {
    return a.x === this.x && a.y === this.y
  },
  fromArray: function(a, b) {
    void 0 === b && (b = 0);
    this.x = a[b];
    this.y = a[b + 1];
    return this
  },
  toArray: function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.x;
    a[b + 1] = this.y;
    return a
  },
  fromAttribute: function(a, b, c) {
    void 0 === c && (c = 0);
    b = b * a.itemSize + c;
    this.x = a.array[b];
    this.y = a.array[b + 1];
    return this
  },
  clone: function() {
    return new THREE.Vector2(this.x, this.y)
  }
};
THREE.Vector3 = function(a, b, c) {
  this.x = a || 0;
  this.y = b || 0;
  this.z = c || 0
};
THREE.Vector3.prototype = {
  constructor: THREE.Vector3,
  set: function(a, b, c) {
    this.x = a;
    this.y = b;
    this.z = c;
    return this
  },
  setX: function(a) {
    this.x = a;
    return this
  },
  setY: function(a) {
    this.y = a;
    return this
  },
  setZ: function(a) {
    this.z = a;
    return this
  },
  setComponent: function(a, b) {
    switch (a) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      case 2:
        this.z = b;
        break;
      default:
        throw Error("index is out of range: " + a);
    }
  },
  getComponent: function(a) {
    switch (a) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw Error("index is out of range: " + a);
    }
  },
  copy: function(a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    return this
  },
  add: function(a, b) {
    if (void 0 !== b) return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    return this
  },
  addScalar: function(a) {
    this.x += a;
    this.y += a;
    this.z += a;
    return this
  },
  addVectors: function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this
  },
  sub: function(a, b) {
    if (void 0 !== b) return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    return this
  },
  subVectors: function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this
  },
  multiply: function(a, b) {
    if (void 0 !== b) return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
    this.x *= a.x;
    this.y *= a.y;
    this.z *= a.z;
    return this
  },
  multiplyScalar: function(a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    return this
  },
  multiplyVectors: function(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this
  },
  applyEuler: function() {
    var a;
    return function(b) {
      !1 === b instanceof THREE.Euler && console.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.");
      void 0 === a && (a = new THREE.Quaternion);
      this.applyQuaternion(a.setFromEuler(b));
      return this
    }
  }(),
  applyAxisAngle: function() {
    var a;
    return function(b, c) {
      void 0 === a && (a = new THREE.Quaternion);
      this.applyQuaternion(a.setFromAxisAngle(b, c));
      return this
    }
  }(),
  applyMatrix3: function(a) {
    var b = this.x,
      c = this.y,
      d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[3] * c + a[6] * d;
    this.y = a[1] * b + a[4] * c + a[7] * d;
    this.z = a[2] * b + a[5] * c + a[8] * d;
    return this
  },
  applyMatrix4: function(a) {
    var b = this.x,
      c = this.y,
      d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
    this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
    this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
    return this
  },
  applyProjection: function(a) {
    var b = this.x,
      c = this.y,
      d = this.z;
    a = a.elements;
    var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
    this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
    this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
    this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
    return this
  },
  applyQuaternion: function(a) {
    var b = this.x,
      c = this.y,
      d = this.z,
      e = a.x,
      f = a.y,
      g = a.z;
    a = a.w;
    var h = a * b + f * d - g * c,
      k = a * c + g * b - e * d,
      n = a * d + e * c - f * b,
      b = -e * b - f * c - g * d;
    this.x = h * a + b * -e + k * -g - n * -f;
    this.y = k * a + b * -f + n * -e - h * -g;
    this.z = n * a + b * -g + h * -f - k * -e;
    return this
  },
  project: function() {
    var a;
    return function(b) {
      void 0 === a && (a = new THREE.Matrix4);
      a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld));
      return this.applyProjection(a)
    }
  }(),
  unproject: function() {
    var a;
    return function(b) {
      void 0 === a && (a = new THREE.Matrix4);
      a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix));
      return this.applyProjection(a)
    }
  }(),
  transformDirection: function(a) {
    var b = this.x,
      c = this.y,
      d = this.z;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d;
    this.y = a[1] * b + a[5] * c + a[9] * d;
    this.z = a[2] * b + a[6] * c + a[10] * d;
    this.normalize();
    return this
  },
  divide: function(a) {
    this.x /= a.x;
    this.y /= a.y;
    this.z /= a.z;
    return this
  },
  divideScalar: function(a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;
    return this
  },
  min: function(a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    this.z > a.z && (this.z = a.z);
    return this
  },
  max: function(a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    this.z < a.z && (this.z = a.z);
    return this
  },
  clamp: function(a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
    return this
  },
  clampScalar: function() {
    var a, b;
    return function(c, d) {
      void 0 === a && (a = new THREE.Vector3, b = new THREE.Vector3);
      a.set(c, c, c);
      b.set(d, d, d);
      return this.clamp(a, b)
    }
  }(),
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this
  },
  roundToZero: function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    return this
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this
  },
  dot: function(a) {
    return this.x * a.x + this.y * a.y + this.z * a.z
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  },
  lengthManhattan: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
  },
  normalize: function() {
    return this.divideScalar(this.length())
  },
  setLength: function(a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this
  },
  lerp: function(a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    return this
  },
  cross: function(a, b) {
    if (void 0 !== b) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
    var c = this.x,
      d = this.y,
      e = this.z;
    this.x = d * a.z - e * a.y;
    this.y = e * a.x - c * a.z;
    this.z = c * a.y - d * a.x;
    return this
  },
  crossVectors: function(a, b) {
    var c = a.x,
      d = a.y,
      e = a.z,
      f = b.x,
      g = b.y,
      h = b.z;
    this.x = d * h - e * g;
    this.y = e * f - c * h;
    this.z = c * g - d * f;
    return this
  },
  projectOnVector: function() {
    var a, b;
    return function(c) {
      void 0 === a && (a = new THREE.Vector3);
      a.copy(c).normalize();
      b = this.dot(a);
      return this.copy(a).multiplyScalar(b)
    }
  }(),
  projectOnPlane: function() {
    var a;
    return function(b) {
      void 0 === a && (a = new THREE.Vector3);
      a.copy(this).projectOnVector(b);
      return this.sub(a)
    }
  }(),
  reflect: function() {
    var a;
    return function(b) {
      void 0 === a && (a = new THREE.Vector3);
      return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
    }
  }(),
  angleTo: function(a) {
    a = this.dot(a) / (this.length() * a.length());
    return Math.acos(THREE.Math.clamp(a, -1, 1))
  },
  distanceTo: function(a) {
    return Math.sqrt(this.distanceToSquared(a))
  },
  distanceToSquared: function(a) {
    var b = this.x - a.x,
      c = this.y - a.y;
    a = this.z - a.z;
    return b * b + c * c + a * a
  },
  setEulerFromRotationMatrix: function(a, b) {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
  },
  setEulerFromQuaternion: function(a, b) {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
  },
  getPositionFromMatrix: function(a) {
    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
    return this.setFromMatrixPosition(a)
  },
  getScaleFromMatrix: function(a) {
    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
    return this.setFromMatrixScale(a)
  },
  getColumnFromMatrix: function(a, b) {
    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
    return this.setFromMatrixColumn(a, b)
  },
  setFromMatrixPosition: function(a) {
    this.x = a.elements[12];
    this.y = a.elements[13];
    this.z = a.elements[14];
    return this
  },
  setFromMatrixScale: function(a) {
    var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length(),
      c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
    a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
    this.x = b;
    this.y = c;
    this.z = a;
    return this
  },
  setFromMatrixColumn: function(a, b) {
    var c = 4 * a,
      d = b.elements;
    this.x = d[c];
    this.y = d[c + 1];
    this.z = d[c + 2];
    return this
  },
  equals: function(a) {
    return a.x === this.x && a.y === this.y && a.z === this.z
  },
  fromArray: function(a, b) {
    void 0 === b && (b = 0);
    this.x = a[b];
    this.y = a[b + 1];
    this.z = a[b + 2];
    return this
  },
  toArray: function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.x;
    a[b + 1] = this.y;
    a[b + 2] = this.z;
    return a
  },
  fromAttribute: function(a, b, c) {
    void 0 === c && (c = 0);
    b = b * a.itemSize + c;
    this.x = a.array[b];
    this.y = a.array[b + 1];
    this.z = a.array[b + 2];
    return this
  },
  clone: function() {
    return new THREE.Vector3(this.x, this.y, this.z)
  }
};
THREE.Vector4 = function(a, b, c, d) {
  this.x = a || 0;
  this.y = b || 0;
  this.z = c || 0;
  this.w = void 0 !== d ? d : 1
};
THREE.Vector4.prototype = {
  constructor: THREE.Vector4,
  set: function(a, b, c, d) {
    this.x = a;
    this.y = b;
    this.z = c;
    this.w = d;
    return this
  },
  setX: function(a) {
    this.x = a;
    return this
  },
  setY: function(a) {
    this.y = a;
    return this
  },
  setZ: function(a) {
    this.z = a;
    return this
  },
  setW: function(a) {
    this.w = a;
    return this
  },
  setComponent: function(a, b) {
    switch (a) {
      case 0:
        this.x = b;
        break;
      case 1:
        this.y = b;
        break;
      case 2:
        this.z = b;
        break;
      case 3:
        this.w = b;
        break;
      default:
        throw Error("index is out of range: " + a);
    }
  },
  getComponent: function(a) {
    switch (a) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw Error("index is out of range: " + a);
    }
  },
  copy: function(a) {
    this.x = a.x;
    this.y = a.y;
    this.z = a.z;
    this.w = void 0 !== a.w ? a.w : 1;
    return this
  },
  add: function(a, b) {
    if (void 0 !== b) return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
    this.x += a.x;
    this.y += a.y;
    this.z += a.z;
    this.w += a.w;
    return this
  },
  addScalar: function(a) {
    this.x += a;
    this.y += a;
    this.z += a;
    this.w += a;
    return this
  },
  addVectors: function(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this
  },
  sub: function(a, b) {
    if (void 0 !== b) return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
    this.x -= a.x;
    this.y -= a.y;
    this.z -= a.z;
    this.w -= a.w;
    return this
  },
  subVectors: function(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this
  },
  multiplyScalar: function(a) {
    this.x *= a;
    this.y *= a;
    this.z *= a;
    this.w *= a;
    return this
  },
  applyMatrix4: function(a) {
    var b = this.x,
      c = this.y,
      d = this.z,
      e = this.w;
    a = a.elements;
    this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
    this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
    this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
    this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
    return this
  },
  divideScalar: function(a) {
    0 !== a ? (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a) : (this.z = this.y = this.x = 0, this.w = 1);
    return this
  },
  setAxisAngleFromQuaternion: function(a) {
    this.w = 2 * Math.acos(a.w);
    var b = Math.sqrt(1 - a.w * a.w);
    1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
    return this
  },
  setAxisAngleFromRotationMatrix: function(a) {
    var b, c, d;
    a = a.elements;
    var e = a[0];
    d = a[4];
    var f = a[8],
      g = a[1],
      h = a[5],
      k = a[9];
    c = a[2];
    b = a[6];
    var n = a[10];
    if (.01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(k - b)) {
      if (.1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(k + b) && .1 > Math.abs(e + h + n - 3)) return this.set(1, 0, 0, 0), this;
      a = Math.PI;
      e = (e + 1) / 2;
      h = (h + 1) / 2;
      n = (n + 1) / 2;
      d = (d + g) / 4;
      f = (f + c) / 4;
      k = (k + b) / 4;
      e > h && e > n ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > n ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), b = d / c, d = k / c) : .01 > n ? (c = b = .707106781, d = 0) : (d = Math.sqrt(n), b = f / d, c = k / d);
      this.set(b, c, d, a);
      return this
    }
    a = Math.sqrt((b - k) * (b - k) + (f - c) * (f - c) + (g - d) * (g - d));.001 > Math.abs(a) && (a = 1);
    this.x = (b - k) / a;
    this.y = (f - c) / a;
    this.z = (g - d) / a;
    this.w = Math.acos((e + h + n - 1) / 2);
    return this
  },
  min: function(a) {
    this.x > a.x && (this.x = a.x);
    this.y > a.y && (this.y = a.y);
    this.z > a.z && (this.z = a.z);
    this.w > a.w && (this.w = a.w);
    return this
  },
  max: function(a) {
    this.x < a.x && (this.x = a.x);
    this.y < a.y && (this.y = a.y);
    this.z < a.z && (this.z = a.z);
    this.w < a.w && (this.w = a.w);
    return this
  },
  clamp: function(a, b) {
    this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
    this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
    this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
    this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);
    return this
  },
  clampScalar: function() {
    var a, b;
    return function(c, d) {
      void 0 === a && (a = new THREE.Vector4, b = new THREE.Vector4);
      a.set(c, c, c, c);
      b.set(d, d, d, d);
      return this.clamp(a, b)
    }
  }(),
  floor: function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this
  },
  ceil: function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this
  },
  round: function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this
  },
  roundToZero: function() {
    this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
    return this
  },
  negate: function() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this
  },
  dot: function(a) {
    return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
  },
  lengthSq: function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
  },
  length: function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
  },
  lengthManhattan: function() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
  },
  normalize: function() {
    return this.divideScalar(this.length())
  },
  setLength: function(a) {
    var b = this.length();
    0 !== b && a !== b && this.multiplyScalar(a / b);
    return this
  },
  lerp: function(a, b) {
    this.x += (a.x - this.x) * b;
    this.y += (a.y - this.y) * b;
    this.z += (a.z - this.z) * b;
    this.w += (a.w - this.w) * b;
    return this
  },
  equals: function(a) {
    return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
  },
  fromArray: function(a, b) {
    void 0 === b && (b = 0);
    this.x = a[b];
    this.y = a[b + 1];
    this.z = a[b + 2];
    this.w = a[b + 3];
    return this
  },
  toArray: function(a, b) {
    void 0 === a && (a = []);
    void 0 === b && (b = 0);
    a[b] = this.x;
    a[b + 1] = this.y;
    a[b + 2] = this.z;
    a[b + 3] = this.w;
    return a
  },
  fromAttribute: function(a, b, c) {
    void 0 === c && (c = 0);
    b = b * a.itemSize + c;
    this.x = a.array[b];
    this.y = a.array[b + 1];
    this.z = a.array[b + 2];
    this.w = a.array[b + 3];
    return this
  },
  clone: function() {
    return new THREE.Vector4(this.x, this.y, this.z, this.w)
  }
};
THREE.Euler = function(a, b, c, d) {
  this._x = a || 0;
  this._y = b || 0;
  this._z = c || 0;
  this._order = d || THREE.Euler.DefaultOrder
};
THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
THREE.Euler.DefaultOrder = "XYZ";
THREE.Euler.prototype = {
  constructor: THREE.Euler,
  _x: 0,
  _y: 0,
  _z: 0,
  _order: THREE.Euler.DefaultOrder,
  get x() {
    return this._x
  },
  set x(a) {
    this._x = a;
    this.onChangeCallback()
  },
  get y() {
    return this._y
  },
  set y(a) {
    this._y = a;
    this.onChangeCallback()
  },
  get z() {
    return this._z
  },
  set z(a) {
    this._z = a;
    this.onChangeCallback()
  },
  get order() {
    return this._order
  },
  set order(a) {
    this._order = a;
    this.onChangeCallback()
  },
  set: function(a, b, c, d) {
    this._x = a;
    this._y = b;
    this._z = c;
    this._order = d || this._order;
    this.onChangeCallback();
    return this
  },
  copy: function(a) {
    this._x = a._x;
    this._y = a._y;
    this._z = a._z;
    this._order = a._order;
    this.onChangeCallback();
    return this
  },
  setFromRotationMatrix: function(a, b, c) {
    var d = THREE.Math.clamp,
      e = a.elements;
    a = e[0];
    var f = e[4],
      g = e[8],
      h = e[1],
      k = e[5],
      n = e[9],
      p = e[2],
      q = e[6],
      e = e[10];
    b = b || this._order;
    "XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-n, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(q, k), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(n, -1, 1)), .99999 > Math.abs(n) ? (this._y = Math.atan2(g, e), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-p, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(q, -1, 1)), .99999 > Math.abs(q) ? (this._y = Math.atan2(-p, e), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(p, -1, 1)), .99999 > Math.abs(p) ? (this._x = Math.atan2(q, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, k))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-n, k), this._y = Math.atan2(-p, a)) : (this._x = 0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(q, k), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-n, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
    this._order = b;
    if (!1 !== c) this.onChangeCallback();
    return this
  },
  setFromQuaternion: function() {
    var a;
    return function(b, c, d) {
      void 0 === a && (a = new THREE.Matrix4);
      a.makeRotationFromQuaternion(b);
      this.setFromRotationMatrix(a, c, d);
      return this
    }
  }(),
  setFromVector3: function(a, b) {
    return this.set(a.x, a.y, a.z, b || this._order)
  },
  reorder: function() {
    var a = new THREE.Quaternion;
    return function(b) {
      a.setFromEuler(this);
      this.setFromQuaternion(a, b)
    }
  }(),
  equals: function(a) {
    return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
  },
  fromArray: function(a) {
    this._x = a[0];
    this._y = a[1];
    this._z = a[2];
    void 0 !== a[3] && (this._order = a[3]);
    this.onChangeCallback();
    return this
  },
  toArray: function() {
    return [this._x, this._y, this._z, this._order]
  },
  toVector3: function(a) {
    return a ? a.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z)
  },
  onChange: function(a) {
    this.onChangeCallback = a;
    return this
  },
  onChangeCallback: function() {},
  clone: function() {
    return new THREE.Euler(this._x, this._y, this._z, this._order)
  }
};
THREE.Line3 = function(a, b) {
  this.start = void 0 !== a ? a : new THREE.Vector3;
  this.end = void 0 !== b ? b : new THREE.Vector3
};
THREE.Line3.prototype = {
  constructor: THREE.Line3,
  set: function(a, b) {
    this.start.copy(a);
    this.end.copy(b);
    return this
  },
  copy: function(a) {
    this.start.copy(a.start);
    this.end.copy(a.end);
    return this
  },
  center: function(a) {
    return (a || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
  },
  delta: function(a) {
    return (a || new THREE.Vector3).subVectors(this.end, this.start)
  },
  distanceSq: function() {
    return this.start.distanceToSquared(this.end)
  },
  distance: function() {
    return this.start.distanceTo(this.end)
  },
  at: function(a, b) {
    var c = b || new THREE.Vector3;
    return this.delta(c).multiplyScalar(a).add(this.start)
  },
  closestPointToPointParameter: function() {
    var a = new THREE.Vector3,
      b = new THREE.Vector3;
    return function(c, d) {
      a.subVectors(c, this.start);
      b.subVectors(this.end, this.start);
      var e = b.dot(b),
        e = b.dot(a) / e;
      d && (e = THREE.Math.clamp(e, 0, 1));
      return e
    }
  }(),
  closestPointToPoint: function(a, b, c) {
    a = this.closestPointToPointParameter(a, b);
    c = c || new THREE.Vector3;
    return this.delta(c).multiplyScalar(a).add(this.start)
  },
  applyMatrix4: function(a) {
    this.start.applyMatrix4(a);
    this.end.applyMatrix4(a);
    return this
  },
  equals: function(a) {
    return a.start.equals(this.start) && a.end.equals(this.end)
  },
  clone: function() {
    return (new THREE.Line3).copy(this)
  }
};
THREE.Box2 = function(a, b) {
  this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
  this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity)
};
THREE.Box2.prototype = {
  constructor: THREE.Box2,
  set: function(a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this
  },
  setFromPoints: function(a) {
    this.makeEmpty();
    for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
    return this
  },
  setFromCenterAndSize: function() {
    var a = new THREE.Vector2;
    return function(b, c) {
      var d = a.copy(c).multiplyScalar(.5);
      this.min.copy(b).sub(d);
      this.max.copy(b).add(d);
      return this
    }
  }(),
  copy: function(a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this
  },
  makeEmpty: function() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this
  },
  empty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y
  },
  center: function(a) {
    return (a || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
  },
  size: function(a) {
    return (a || new THREE.Vector2).subVectors(this.max, this.min)
  },
  expandByPoint: function(a) {
    this.min.min(a);
    this.max.max(a);
    return this
  },
  expandByVector: function(a) {
    this.min.sub(a);
    this.max.add(a);
    return this
  },
  expandByScalar: function(a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this
  },
  containsPoint: function(a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
  },
  containsBox: function(a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1
  },
  getParameter: function(a, b) {
    return (b || new THREE.Vector2).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
  },
  isIntersectionBox: function(a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
  },
  clampPoint: function(a, b) {
    return (b || new THREE.Vector2).copy(a).clamp(this.min, this.max)
  },
  distanceToPoint: function() {
    var a = new THREE.Vector2;
    return function(b) {
      return a.copy(b).clamp(this.min, this.max).sub(b).length()
    }
  }(),
  intersect: function(a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this
  },
  union: function(a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this
  },
  translate: function(a) {
    this.min.add(a);
    this.max.add(a);
    return this
  },
  equals: function(a) {
    return a.min.equals(this.min) && a.max.equals(this.max)
  },
  clone: function() {
    return (new THREE.Box2).copy(this)
  }
};
THREE.Box3 = function(a, b) {
  this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
  this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity)
};
THREE.Box3.prototype = {
  constructor: THREE.Box3,
  set: function(a, b) {
    this.min.copy(a);
    this.max.copy(b);
    return this
  },
  setFromPoints: function(a) {
    this.makeEmpty();
    for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
    return this
  },
  setFromCenterAndSize: function() {
    var a = new THREE.Vector3;
    return function(b, c) {
      var d = a.copy(c).multiplyScalar(.5);
      this.min.copy(b).sub(d);
      this.max.copy(b).add(d);
      return this
    }
  }(),
  setFromObject: function() {
    var a = new THREE.Vector3;
    return function(b) {
      var c = this;
      b.updateMatrixWorld(!0);
      this.makeEmpty();
      b.traverse(function(b) {
        var e = b.geometry;
        if (void 0 !== e)
          if (e instanceof THREE.Geometry)
            for (var f = e.vertices, e = 0, g = f.length; e < g; e++) a.copy(f[e]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a);
          else if (e instanceof THREE.BufferGeometry && void 0 !== e.attributes.position)
          for (f = e.attributes.position.array, e = 0, g = f.length; e < g; e += 3) a.set(f[e], f[e + 1], f[e + 2]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a)
      });
      return this
    }
  }(),
  copy: function(a) {
    this.min.copy(a.min);
    this.max.copy(a.max);
    return this
  },
  makeEmpty: function() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this
  },
  empty: function() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
  },
  center: function(a) {
    return (a || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
  },
  size: function(a) {
    return (a || new THREE.Vector3).subVectors(this.max, this.min)
  },
  expandByPoint: function(a) {
    this.min.min(a);
    this.max.max(a);
    return this
  },
  expandByVector: function(a) {
    this.min.sub(a);
    this.max.add(a);
    return this
  },
  expandByScalar: function(a) {
    this.min.addScalar(-a);
    this.max.addScalar(a);
    return this
  },
  containsPoint: function(a) {
    return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
  },
  containsBox: function(a) {
    return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1
  },
  getParameter: function(a, b) {
    return (b || new THREE.Vector3).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
  },
  isIntersectionBox: function(a) {
    return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
  },
  clampPoint: function(a, b) {
    return (b || new THREE.Vector3).copy(a).clamp(this.min, this.max)
  },
  distanceToPoint: function() {
    var a = new THREE.Vector3;
    return function(b) {
      return a.copy(b).clamp(this.min, this.max).sub(b).length()
    }
  }(),
  getBoundingSphere: function() {
    var a = new THREE.Vector3;
    return function(b) {
      b = b || new THREE.Sphere;
      b.center = this.center();
      b.radius = .5 * this.size(a).length();
      return b
    }
  }(),
  intersect: function(a) {
    this.min.max(a.min);
    this.max.min(a.max);
    return this
  },
  union: function(a) {
    this.min.min(a.min);
    this.max.max(a.max);
    return this
  },
  applyMatrix4: function() {
    var a = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
    return function(b) {
      a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);
      a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
      a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
      a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
      a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
      a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
      a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
      a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
      this.makeEmpty();
      this.setFromPoints(a);
      return this
    }
  }(),
  translate: function(a) {
    this.min.add(a);
    this.max.add(a);
    return this
  },
  equals: function(a) {
    return a.min.equals(this.min) && a.max.equals(this.max)
  },
  clone: function() {
    return (new THREE.Box3).copy(this)
  }
};
THREE.Matrix3 = function() {
  this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
};
THREE.Matrix3.prototype = {
  constructor: THREE.Matrix3,
  set: function(a, b, c, d, e, f, g, h, k) {
    var n = this.elements;
    n[0] = a;
    n[3] = b;
    n[6] = c;
    n[1] = d;
    n[4] = e;
    n[7] = f;
    n[2] = g;
    n[5] = h;
    n[8] = k;
    return this
  },
  identity: function() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this
  },
  copy: function(a) {
    a = a.elements;
    this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
    return this
  },
  multiplyVector3: function(a) {
    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
    return a.applyMatrix3(this)
  },
  multiplyVector3Array: function(a) {
    console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
    return this.applyToVector3Array(a)
  },
  applyToVector3Array: function() {
    var a = new THREE.Vector3;
    return function(b, c, d) {
      void 0 === c && (c = 0);
      void 0 === d && (d = b.length);
      for (var e = 0; e < d; e += 3, c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix3(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
      return b
    }
  }(),
  multiplyScalar: function(a) {
    var b = this.elements;
    b[0] *= a;
    b[3] *= a;
    b[6] *= a;
    b[1] *= a;
    b[4] *= a;
    b[7] *= a;
    b[2] *= a;
    b[5] *= a;
    b[8] *= a;
    return this
  },
  determinant: function() {
    var a = this.elements,
      b = a[0],
      c = a[1],
      d = a[2],
      e = a[3],
      f = a[4],
      g = a[5],
      h = a[6],
      k = a[7],
      a = a[8];
    return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h
  },
  getInverse: function(a, b) {
    var c = a.elements,
      d = this.elements;
    d[0] = c[10] * c[5] - c[6] * c[9];
    d[1] = -c[10] * c[1] + c[2] * c[9];
    d[2] = c[6] * c[1] - c[2] * c[5];
    d[3] = -c[10] * c[4] + c[6] * c[8];
    d[4] = c[10] * c[0] - c[2] * c[8];
    d[5] = -c[6] * c[0] + c[2] * c[4];
    d[6] = c[9] * c[4] - c[5] * c[8];
    d[7] = -c[9] * c[0] + c[1] * c[8];
    d[8] = c[5] * c[0] - c[1] * c[4];
    c = c[0] * d[0] + c[1] * d[3] + c[2] * d[6];
    if (0 === c) {
      if (b) throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
      console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0");
      this.identity();
      return this
    }
    this.multiplyScalar(1 / c);
    return this
  },
  transpose: function() {
    var a, b = this.elements;
    a = b[1];
    b[1] = b[3];
    b[3] = a;
    a = b[2];
    b[2] = b[6];
    b[6] = a;
    a = b[5];
    b[5] = b[7];
    b[7] = a;
    return this
  },
  flattenToArrayOffset: function(a, b) {
    var c = this.elements;
    a[b] = c[0];
    a[b + 1] = c[1];
    a[b + 2] = c[2];
    a[b + 3] = c[3];
    a[b + 4] = c[4];
    a[b + 5] = c[5];
    a[b + 6] = c[6];
    a[b + 7] = c[7];
    a[b + 8] = c[8];
    return a
  },
  getNormalMatrix: function(a) {
    this.getInverse(a).transpose();
    return this
  },
  transposeIntoArray: function(a) {
    var b = this.elements;
    a[0] = b[0];
    a[1] = b[3];
    a[2] = b[6];
    a[3] = b[1];
    a[4] = b[4];
    a[5] = b[7];
    a[6] = b[2];
    a[7] = b[5];
    a[8] = b[8];
    return this
  },
  fromArray: function(a) {
    this.elements.set(a);
    return this
  },
  toArray: function() {
    var a = this.elements;
    return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]]
  },
  clone: function() {
    return (new THREE.Matrix3).fromArray(this.elements)
  }
};
THREE.Matrix4 = function() {
  this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
};
THREE.Matrix4.prototype = {
  constructor: THREE.Matrix4,
  set: function(a, b, c, d, e, f, g, h, k, n, p, q, m, t, s, r) {
    var u = this.elements;
    u[0] = a;
    u[4] = b;
    u[8] = c;
    u[12] = d;
    u[1] = e;
    u[5] = f;
    u[9] = g;
    u[13] = h;
    u[2] = k;
    u[6] = n;
    u[10] = p;
    u[14] = q;
    u[3] = m;
    u[7] = t;
    u[11] = s;
    u[15] = r;
    return this
  },
  identity: function() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this
  },
  copy: function(a) {
    this.elements.set(a.elements);
    return this
  },
  extractPosition: function(a) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(a)
  },
  copyPosition: function(a) {
    var b = this.elements;
    a = a.elements;
    b[12] = a[12];
    b[13] = a[13];
    b[14] = a[14];
    return this
  },
  extractBasis: function(a, b, c) {
    var d = this.elements;
    a.set(d[0], d[1], d[2]);
    b.set(d[4], d[5], d[6]);
    c.set(d[8], d[9], d[10]);
    return this
  },
  makeBasis: function(a, b, c) {
    this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
    return this
  },
  extractRotation: function() {
    var a = new THREE.Vector3;
    return function(b) {
      var c = this.elements;
      b = b.elements;
      var d = 1 / a.set(b[0], b[1], b[2]).length(),
        e = 1 / a.set(b[4], b[5], b[6]).length(),
        f = 1 / a.set(b[8], b[9], b[10]).length();
      c[0] = b[0] * d;
      c[1] = b[1] * d;
      c[2] = b[2] * d;
      c[4] = b[4] * e;
      c[5] = b[5] * e;
      c[6] = b[6] * e;
      c[8] = b[8] * f;
      c[9] = b[9] * f;
      c[10] = b[10] * f;
      return this
    }
  }(),
  makeRotationFromEuler: function(a) {
    !1 === a instanceof THREE.Euler && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
    var b = this.elements,
      c = a.x,
      d = a.y,
      e = a.z,
      f = Math.cos(c),
      c = Math.sin(c),
      g = Math.cos(d),
      d = Math.sin(d),
      h = Math.cos(e),
      e = Math.sin(e);
    if ("XYZ" === a.order) {
      a = f * h;
      var k = f * e,
        n = c * h,
        p = c * e;
      b[0] = g * h;
      b[4] = -g * e;
      b[8] = d;
      b[1] = k + n * d;
      b[5] = a - p * d;
      b[9] = -c * g;
      b[2] = p - a * d;
      b[6] = n + k * d;
      b[10] = f * g
    } else "YXZ" === a.order ? (a = g * h, k = g * e, n = d * h, p = d * e, b[0] = a + p * c, b[4] = n * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = k * c - n, b[6] = p + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, k = g * e, n = d * h, p = d * e, b[0] = a - p * c, b[4] = -f * e, b[8] = n + k * c, b[1] = k + n * c, b[5] = f * h, b[9] = p - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, k = f * e, n = c * h, p = c * e, b[0] = g * h, b[4] = n * d - k, b[8] = a * d + p, b[1] = g * e, b[5] = p * d + a, b[9] = k * d - n, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, k = f * d, n = c * g, p = c * d, b[0] = g * h, b[4] = p - a * e, b[8] = n * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + n, b[10] = a - p * e) : "XZY" === a.order && (a = f * g, k = f * d, n = c * g, p = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + p, b[5] = f * h, b[9] = k * e - n, b[2] = n * e - k, b[6] = c * h, b[10] = p * e + a);
    b[3] = 0;
    b[7] = 0;
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return this
  },
  setRotationFromQuaternion: function(a) {
    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
    return this.makeRotationFromQuaternion(a)
  },
  makeRotationFromQuaternion: function(a) {
    var b = this.elements,
      c = a.x,
      d = a.y,
      e = a.z,
      f = a.w,
      g = c + c,
      h = d + d,
      k = e + e;
    a = c * g;
    var n = c * h,
      c = c * k,
      p = d * h,
      d = d * k,
      e = e * k,
      g = f * g,
      h = f * h,
      f = f * k;
    b[0] = 1 - (p + e);
    b[4] = n - f;
    b[8] = c + h;
    b[1] = n + f;
    b[5] = 1 - (a + e);
    b[9] = d - g;
    b[2] = c - h;
    b[6] = d + g;
    b[10] = 1 - (a + p);
    b[3] = 0;
    b[7] = 0;
    b[11] = 0;
    b[12] = 0;
    b[13] = 0;
    b[14] = 0;
    b[15] = 1;
    return this
  },
  lookAt: function() {
    var a = new THREE.Vector3,
      b = new THREE.Vector3,
      c = new THREE.Vector3;
    return function(d, e, f) {
      var g = this.elements;
      c.subVectors(d, e).normalize();
      0 === c.length() && (c.z = 1);
      a.crossVectors(f, c).normalize();
      0 === a.length() && (c.x += 1E-4, a.crossVectors(f, c).normalize());
      b.crossVectors(c, a);
      g[0] = a.x;
      g[4] = b.x;
      g[8] = c.x;
      g[1] = a.y;
      g[5] = b.y;
      g[9] = c.y;
      g[2] = a.z;
      g[6] = b.z;
      g[10] = c.z;
      return this
    }
  }(),
  multiply: function(a, b) {
    return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
  },
  multiplyMatrices: function(a, b) {
    var c = a.elements,
      d = b.elements,
      e = this.elements,
      f = c[0],
      g = c[4],
      h = c[8],
      k = c[12],
      n = c[1],
      p = c[5],
      q = c[9],
      m = c[13],
      t = c[2],
      s = c[6],
      r = c[10],
      u = c[14],
      v = c[3],
      y = c[7],
      C = c[11],
      c = c[15],
      x = d[0],
      F = d[4],
      z = d[8],
      G = d[12],
      E = d[1],
      w = d[5],
      D = d[9],
      A = d[13],
      U = d[2],
      M = d[6],
      K = d[10],
      L = d[14],
      N = d[3],
      T = d[7],
      Q = d[11],
      d = d[15];
    e[0] = f * x + g * E + h * U + k * N;
    e[4] = f * F + g * w + h * M + k * T;
    e[8] = f * z + g * D + h * K + k * Q;
    e[12] = f * G + g * A + h * L + k * d;
    e[1] = n * x + p * E + q * U + m * N;
    e[5] = n * F + p * w + q * M + m * T;
    e[9] = n * z + p * D + q * K + m * Q;
    e[13] = n * G + p * A + q * L + m * d;
    e[2] = t * x + s * E + r * U + u * N;
    e[6] = t * F + s * w + r * M + u * T;
    e[10] = t * z + s * D + r * K + u * Q;
    e[14] = t * G + s * A + r * L + u * d;
    e[3] = v * x + y * E + C * U + c * N;
    e[7] = v * F + y * w + C * M + c * T;
    e[11] = v * z + y * D + C * K + c * Q;
    e[15] = v * G + y * A + C * L + c * d;
    return this
  },
  multiplyToArray: function(a, b, c) {
    var d = this.elements;
    this.multiplyMatrices(a, b);
    c[0] = d[0];
    c[1] = d[1];
    c[2] = d[2];
    c[3] = d[3];
    c[4] = d[4];
    c[5] = d[5];
    c[6] = d[6];
    c[7] = d[7];
    c[8] = d[8];
    c[9] = d[9];
    c[10] = d[10];
    c[11] = d[11];
    c[12] = d[12];
    c[13] = d[13];
    c[14] = d[14];
    c[15] = d[15];
    return this
  },
  multiplyScalar: function(a) {
    var b = this.elements;
    b[0] *= a;
    b[4] *= a;
    b[8] *= a;
    b[12] *= a;
    b[1] *= a;
    b[5] *= a;
    b[9] *= a;
    b[13] *= a;
    b[2] *= a;
    b[6] *= a;
    b[10] *= a;
    b[14] *= a;
    b[3] *= a;
    b[7] *= a;
    b[11] *= a;
    b[15] *= a;
    return this
  },
  multiplyVector3: function(a) {
    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
    return a.applyProjection(this)
  },
  multiplyVector4: function(a) {
    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this)
  },
  multiplyVector3Array: function(a) {
    console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
    return this.applyToVector3Array(a)
  },
  applyToVector3Array: function() {
    var a = new THREE.Vector3;
    return function(b, c, d) {
      void 0 === c && (c = 0);
      void 0 === d && (d = b.length);
      for (var e = 0; e < d; e += 3, c += 3) a.x = b[c], a.y = b[c + 1], a.z = b[c + 2], a.applyMatrix4(this), b[c] = a.x, b[c + 1] = a.y, b[c + 2] = a.z;
      return b
    }
  }(),
  rotateAxis: function(a) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
    a.transformDirection(this)
  },
  crossVector: function(a) {
    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return a.applyMatrix4(this)
  },
  determinant: function() {
    var a = this.elements,
      b = a[0],
      c = a[4],
      d = a[8],
      e = a[12],
      f = a[1],
      g = a[5],
      h = a[9],
      k = a[13],
      n = a[2],
      p = a[6],
      q = a[10],
      m = a[14];
    return a[3] * (+e * h * p - d * k * p - e * g * q + c * k * q + d * g * m - c * h * m) + a[7] * (+b * h * m - b * k * q + e * f * q - d * f * m + d * k * n - e * h * n) + a[11] * (+b * k * p - b * g * m - e * f * p + c * f * m + e * g * n - c * k * n) + a[15] * (-d * g * n - b * h * p + b * g * q + d * f * p - c * f * q + c * h * n)
  },
  transpose: function() {
    var a = this.elements,
      b;
    b = a[1];
    a[1] = a[4];
    a[4] = b;
    b = a[2];
    a[2] = a[8];
    a[8] = b;
    b = a[6];
    a[6] = a[9];
    a[9] = b;
    b = a[3];
    a[3] = a[12];
    a[12] = b;
    b = a[7];
    a[7] = a[13];
    a[13] = b;
    b = a[11];
    a[11] = a[14];
    a[14] = b;
    return this
  },
  flattenToArrayOffset: function(a, b) {
    var c = this.elements;
    a[b] = c[0];
    a[b + 1] = c[1];
    a[b + 2] = c[2];
    a[b + 3] = c[3];
    a[b + 4] = c[4];
    a[b + 5] = c[5];
    a[b + 6] = c[6];
    a[b + 7] = c[7];
    a[b + 8] = c[8];
    a[b + 9] = c[9];
    a[b + 10] = c[10];
    a[b + 11] = c[11];
    a[b + 12] = c[12];
    a[b + 13] = c[13];
    a[b + 14] = c[14];
    a[b + 15] = c[15];
    return a
  },
  getPosition: function() {
    var a = new THREE.Vector3;
    return function() {
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      var b = this.elements;
      return a.set(b[12], b[13], b[14])
    }
  }(),
  setPosition: function(a) {
    var b = this.elements;
    b[12] = a.x;
    b[13] = a.y;
    b[14] = a.z;
    return this
  },
  getInverse: function(a, b) {
    var c = this.elements,
      d = a.elements,
      e = d[0],
      f = d[4],
      g = d[8],
      h = d[12],
      k = d[1],
      n = d[5],
      p = d[9],
      q = d[13],
      m = d[2],
      t = d[6],
      s = d[10],
      r = d[14],
      u = d[3],
      v = d[7],
      y = d[11],
      d = d[15];
    c[0] = p * r * v - q * s * v + q * t * y - n * r * y - p * t * d + n * s * d;
    c[4] = h * s * v - g * r * v - h * t * y + f * r * y + g * t * d - f * s * d;
    c[8] = g * q * v - h * p * v + h * n * y - f * q * y - g * n * d + f * p * d;
    c[12] = h * p * t - g * q * t - h * n * s + f * q * s + g * n * r - f * p * r;
    c[1] = q * s * u - p * r * u - q * m * y + k * r * y + p * m * d - k * s * d;
    c[5] = g * r * u - h * s * u + h * m * y - e * r * y - g * m * d + e * s * d;
    c[9] = h * p * u - g * q * u - h * k * y + e * q * y + g * k * d - e * p * d;
    c[13] = g * q * m - h * p * m + h * k * s - e * q * s - g * k * r + e * p * r;
    c[2] = n * r * u - q * t * u + q * m * v - k * r * v - n * m * d + k * t * d;
    c[6] = h * t * u - f * r * u - h * m * v + e * r * v + f * m * d - e * t * d;
    c[10] = f * q * u - h * n * u + h * k * v - e * q * v - f * k * d + e * n * d;
    c[14] = h * n * m - f * q * m - h * k * t + e * q * t + f * k * r - e * n * r;
    c[3] = p * t * u - n * s * u - p * m * v + k * s * v + n * m * y - k * t * y;
    c[7] = f * s * u - g * t * u + g * m * v - e * s * v - f * m * y + e * t * y;
    c[11] = g * n * u - f * p * u - g * k * v + e * p * v + f * k * y - e * n * y;
    c[15] = f * p * m - g * n * m + g * k * t - e * p * t - f * k * s + e * n * s;
    c = e * c[0] + k * c[4] + m * c[8] + u * c[12];
    if (0 == c) {
      if (b) throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
      console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0");
      this.identity();
      return this
    }
    this.multiplyScalar(1 / c);
    return this
  },
  translate: function(a) {
    console.warn("THREE.Matrix4: .translate() has been removed.")
  },
  rotateX: function(a) {
    console.warn("THREE.Matrix4: .rotateX() has been removed.")
  },
  rotateY: function(a) {
    console.warn("THREE.Matrix4: .rotateY() has been removed.")
  },
  rotateZ: function(a) {
    console.warn("THREE.Matrix4: .rotateZ() has been removed.")
  },
  rotateByAxis: function(a, b) {
    console.warn("THREE.Matrix4: .rotateByAxis() has been removed.")
  },
  scale: function(a) {
    var b = this.elements,
      c = a.x,
      d = a.y;
    a = a.z;
    b[0] *= c;
    b[4] *= d;
    b[8] *= a;
    b[1] *= c;
    b[5] *= d;
    b[9] *= a;
    b[2] *= c;
    b[6] *= d;
    b[10] *= a;
    b[3] *= c;
    b[7] *= d;
    b[11] *= a;
    return this
  },
  getMaxScaleOnAxis: function() {
    var a = this.elements;
    return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])))
  },
  makeTranslation: function(a, b, c) {
    this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
    return this
  },
  makeRotationX: function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
    return this
  },
  makeRotationY: function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
    return this
  },
  makeRotationZ: function(a) {
    var b = Math.cos(a);
    a = Math.sin(a);
    this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this
  },
  makeRotationAxis: function(a, b) {
    var c = Math.cos(b),
      d = Math.sin(b),
      e = 1 - c,
      f = a.x,
      g = a.y,
      h = a.z,
      k = e * f,
      n = e * g;
    this.set(k * f + c, k * g - d * h, k * h + d * g, 0, k * g + d * h, n * g + c, n * h - d * f, 0, k * h - d * g, n * h + d * f, e * h * h + c, 0, 0, 0, 0, 1);
    return this
  },
  makeScale: function(a, b, c) {
    this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
    return this
  },
  compose: function(a, b, c) {
    this.makeRotationFromQuaternion(b);
    this.scale(c);
    this.setPosition(a);
    return this
  },
  decompose: function() {
    var a = new THREE.Vector3,
      b = new THREE.Matrix4;
    return function(c, d, e) {
      var f = this.elements,
        g = a.set(f[0], f[1], f[2]).length(),
        h = a.set(f[4], f[5], f[6]).length(),
        k = a.set(f[8], f[9], f[10]).length();
      0 > this.determinant() && (g = -g);
      c.x = f[12];
      c.y = f[13];
      c.z = f[14];
      b.elements.set(this.elements);
      c = 1 / g;
      var f = 1 / h,
        n = 1 / k;
      b.elements[0] *= c;
      b.elements[1] *= c;
      b.elements[2] *= c;
      b.elements[4] *= f;
      b.elements[5] *= f;
      b.elements[6] *= f;
      b.elements[8] *= n;
      b.elements[9] *= n;
      b.elements[10] *= n;
      d.setFromRotationMatrix(b);
      e.x = g;
      e.y = h;
      e.z = k;
      return this
    }
  }(),
  makeFrustum: function(a, b, c, d, e, f) {
    var g = this.elements;
    g[0] = 2 * e / (b - a);
    g[4] = 0;
    g[8] = (b + a) / (b - a);
    g[12] = 0;
    g[1] = 0;
    g[5] = 2 * e / (d - c);
    g[9] = (d + c) / (d - c);
    g[13] = 0;
    g[2] = 0;
    g[6] = 0;
    g[10] = -(f + e) / (f - e);
    g[14] = -2 * f * e / (f - e);
    g[3] = 0;
    g[7] = 0;
    g[11] = -1;
    g[15] = 0;
    return this
  },
  makePerspective: function(a, b, c, d) {
    a = c * Math.tan(THREE.Math.degToRad(.5 * a));
    var e = -a;
    return this.makeFrustum(e * b, a * b, e, a, c, d)
  },
  makeOrthographic: function(a, b, c, d, e, f) {
    var g = this.elements,
      h = b - a,
      k = c - d,
      n = f - e;
    g[0] = 2 / h;
    g[4] = 0;
    g[8] = 0;
    g[12] = -((b + a) / h);
    g[1] = 0;
    g[5] = 2 / k;
    g[9] = 0;
    g[13] = -((c + d) / k);
    g[2] = 0;
    g[6] = 0;
    g[10] = -2 / n;
    g[14] = -((f + e) / n);
    g[3] = 0;
    g[7] = 0;
    g[11] = 0;
    g[15] = 1;
    return this
  },
  fromArray: function(a) {
    this.elements.set(a);
    return this
  },
  toArray: function() {
    var a = this.elements;
    return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]]
  },
  clone: function() {
    return (new THREE.Matrix4).fromArray(this.elements)
  }
};
THREE.Ray = function(a, b) {
  this.origin = void 0 !== a ? a : new THREE.Vector3;
  this.direction = void 0 !== b ? b : new THREE.Vector3
};
THREE.Ray.prototype = {
  constructor: THREE.Ray,
  set: function(a, b) {
    this.origin.copy(a);
    this.direction.copy(b);
    return this
  },
  copy: function(a) {
    this.origin.copy(a.origin);
    this.direction.copy(a.direction);
    return this
  },
  at: function(a, b) {
    return (b || new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)
  },
  recast: function() {
    var a = new THREE.Vector3;
    return function(b) {
      this.origin.copy(this.at(b, a));
      return this
    }
  }(),
  closestPointToPoint: function(a, b) {
    var c = b || new THREE.Vector3;
    c.subVectors(a, this.origin);
    var d = c.dot(this.direction);
    return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin)
  },
  distanceToPoint: function() {
    var a = new THREE.Vector3;
    return function(b) {
      var c = a.subVectors(b, this.origin).dot(this.direction);
      if (0 > c) return this.origin.distanceTo(b);
      a.copy(this.direction).multiplyScalar(c).add(this.origin);
      return a.distanceTo(b)
    }
  }(),
  distanceSqToSegment: function() {
    var a = new THREE.Vector3,
      b = new THREE.Vector3,
      c = new THREE.Vector3;
    return function(d, e, f, g) {
      a.copy(d).add(e).multiplyScalar(.5);
      b.copy(e).sub(d).normalize();
      c.copy(this.origin).sub(a);
      var h = .5 * d.distanceTo(e),
        k = -this.direction.dot(b),
        n = c.dot(this.direction),
        p = -c.dot(b),
        q = c.lengthSq(),
        m = Math.abs(1 - k * k),
        t;
      0 < m ? (d = k * p - n, e = k * n - p, t = h * m, 0 <= d ? e >= -t ? e <= t ? (h = 1 / m, d *= h, e *= h, k = d * (d + k * e + 2 * n) + e * (k * d + e + 2 * p) + q) : (e = h, d = Math.max(0, -(k * e + n)), k = -d * d + e * (e + 2 * p) + q) : (e = -h, d = Math.max(0, -(k * e + n)), k = -d * d + e * (e + 2 * p) + q) : e <= -t ? (d = Math.max(0, -(-k * h + n)), e = 0 < d ? -h : Math.min(Math.max(-h, -p), h), k = -d * d + e * (e + 2 * p) + q) : e <= t ? (d = 0, e = Math.min(Math.max(-h, -p), h), k = e * (e + 2 * p) + q) : (d = Math.max(0, -(k * h + n)), e = 0 < d ? h : Math.min(Math.max(-h, -p), h), k = -d * d + e * (e + 2 * p) + q)) : (e = 0 < k ? -h : h, d = Math.max(0, -(k * e + n)), k = -d * d + e * (e + 2 * p) + q);
      f && f.copy(this.direction).multiplyScalar(d).add(this.origin);
      g && g.copy(b).multiplyScalar(e).add(a);
      return k
    }
  }(),
  isIntersectionSphere: function(a) {
    return this.distanceToPoint(a.center) <= a.radius
  },
  intersectSphere: function() {
    var a = new THREE.Vector3;
    return function(b, c) {
      a.subVectors(b.center, this.origin);
      var d = a.dot(this.direction),
        e = a.dot(a) - d * d,
        f = b.radius * b.radius;
      if (e > f) return null;
      f = Math.sqrt(f - e);
      e = d - f;
      d += f;
      return 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c)
    }
  }(),
  isIntersectionPlane: function(a) {
    var b = a.distanceToPoint(this.origin);
    return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
  },
  distanceToPlane: function(a) {
    var b = a.normal.dot(this.direction);
    if (0 == b) return 0 == a.distanceToPoint(this.origin) ? 0 : null;
    a = -(this.origin.dot(a.normal) + a.constant) / b;
    return 0 <= a ? a : null
  },
  intersectPlane: function(a, b) {
    var c = this.distanceToPlane(a);
    return null === c ? null : this.at(c, b)
  },
  isIntersectionBox: function() {
    var a = new THREE.Vector3;
    return function(b) {
      return null !== this.intersectBox(b, a)
    }
  }(),
  intersectBox: function(a, b) {
    var c, d, e, f, g;
    d = 1 / this.direction.x;
    f = 1 / this.direction.y;
    g = 1 / this.direction.z;
    var h = this.origin;
    0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x);
    0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y);
    if (c > f || e > d) return null;
    if (e > c || c !== c) c = e;
    if (f < d || d !== d) d = f;
    0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z);
    if (c > g || e > d) return null;
    if (e > c || c !== c) c = e;
    if (g < d || d !== d) d = g;
    return 0 > d ? null : this.at(0 <= c ? c : d, b)
  },
  intersectTriangle: function() {
    var a = new THREE.Vector3,
      b = new THREE.Vector3,
      c = new THREE.Vector3,
      d = new THREE.Vector3;
    return function(e, f, g, h, k) {
      b.subVectors(f, e);
      c.subVectors(g, e);
      d.crossVectors(b, c);
      f = this.direction.dot(d);
      if (0 < f) {
        if (h) return null;
        h = 1
      } else if (0 > f) h = -1, f = -f;
      else return null;
      a.subVectors(this.origin, e);
      e = h * this.direction.dot(c.crossVectors(a, c));
      if (0 > e) return null;
      g = h * this.direction.dot(b.cross(a));
      if (0 > g || e + g > f) return null;
      e = -h * a.dot(d);
      return 0 > e ? null : this.at(e / f, k)
    }
  }(),
  applyMatrix4: function(a) {
    this.direction.add(this.origin).applyMatrix4(a);
    this.origin.applyMatrix4(a);
    this.direction.sub(this.origin);
    this.direction.normalize();
    return this
  },
  equals: function(a) {
    return a.origin.equals(this.origin) && a.direction.equals(this.direction)
  },
  clone: function() {
    return (new THREE.Ray).copy(this)
  }
};
THREE.Sphere = function(a, b) {
  this.center = void 0 !== a ? a : new THREE.Vector3;
  this.radius = void 0 !== b ? b : 0
};
THREE.Sphere.prototype = {
  constructor: THREE.Sphere,
  set: function(a, b) {
    this.center.copy(a);
    this.radius = b;
    return this
  },
  setFromPoints: function() {
    var a = new THREE.Box3;
    return function(b, c) {
      var d = this.center;
      void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
      for (var e = 0, f = 0, g = b.length; f < g; f++) e = Math.max(e, d.distanceToSquared(b[f]));
      this.radius = Math.sqrt(e);
      return this
    }
  }(),
  copy: function(a) {
    this.center.copy(a.center);
    this.radius = a.radius;
    return this
  },
  empty: function() {
    return 0 >= this.radius
  },
  containsPoint: function(a) {
    return a.distanceToSquared(this.center) <= this.radius * this.radius
  },
  distanceToPoint: function(a) {
    return a.distanceTo(this.center) - this.radius
  },
  intersectsSphere: function(a) {
    var b = this.radius + a.radius;
    return a.center.distanceToSquared(this.center) <= b * b
  },
  clampPoint: function(a, b) {
    var c = this.center.distanceToSquared(a),
      d = b || new THREE.Vector3;
    d.copy(a);
    c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center));
    return d
  },
  getBoundingBox: function(a) {
    a = a || new THREE.Box3;
    a.set(this.center, this.center);
    a.expandByScalar(this.radius);
    return a
  },
  applyMatrix4: function(a) {
    this.center.applyMatrix4(a);
    this.radius *= a.getMaxScaleOnAxis();
    return this
  },
  translate: function(a) {
    this.center.add(a);
    return this
  },
  equals: function(a) {
    return a.center.equals(this.center) && a.radius === this.radius
  },
  clone: function() {
    return (new THREE.Sphere).copy(this)
  }
};
THREE.Frustum = function(a, b, c, d, e, f) {
  this.planes = [void 0 !== a ? a : new THREE.Plane, void 0 !== b ? b : new THREE.Plane, void 0 !== c ? c : new THREE.Plane, void 0 !== d ? d : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== f ? f : new THREE.Plane]
};
THREE.Frustum.prototype = {
  constructor: THREE.Frustum,
  set: function(a, b, c, d, e, f) {
    var g = this.planes;
    g[0].copy(a);
    g[1].copy(b);
    g[2].copy(c);
    g[3].copy(d);
    g[4].copy(e);
    g[5].copy(f);
    return this
  },
  copy: function(a) {
    for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
    return this
  },
  setFromMatrix: function(a) {
    var b = this.planes,
      c = a.elements;
    a = c[0];
    var d = c[1],
      e = c[2],
      f = c[3],
      g = c[4],
      h = c[5],
      k = c[6],
      n = c[7],
      p = c[8],
      q = c[9],
      m = c[10],
      t = c[11],
      s = c[12],
      r = c[13],
      u = c[14],
      c = c[15];
    b[0].setComponents(f - a, n - g, t - p, c - s).normalize();
    b[1].setComponents(f + a, n + g, t + p, c + s).normalize();
    b[2].setComponents(f + d, n + h, t + q, c + r).normalize();
    b[3].setComponents(f - d, n - h, t - q, c - r).normalize();
    b[4].setComponents(f - e, n - k, t - m, c - u).normalize();
    b[5].setComponents(f + e, n + k, t + m, c + u).normalize();
    return this
  },
  intersectsObject: function() {
    var a = new THREE.Sphere;
    return function(b) {
      var c = b.geometry;
      null === c.boundingSphere && c.computeBoundingSphere();
      a.copy(c.boundingSphere);
      a.applyMatrix4(b.matrixWorld);
      return this.intersectsSphere(a)
    }
  }(),
  intersectsSphere: function(a) {
    var b = this.planes,
      c = a.center;
    a = -a.radius;
    for (var d = 0; 6 > d; d++)
      if (b[d].distanceToPoint(c) < a) return !1;
    return !0
  },
  intersectsBox: function() {
    var a = new THREE.Vector3,
      b = new THREE.Vector3;
    return function(c) {
      for (var d = this.planes, e = 0; 6 > e; e++) {
        var f = d[e];
        a.x = 0 < f.normal.x ? c.min.x : c.max.x;
        b.x = 0 < f.normal.x ? c.max.x : c.min.x;
        a.y = 0 < f.normal.y ? c.min.y : c.max.y;
        b.y = 0 < f.normal.y ? c.max.y : c.min.y;
        a.z = 0 < f.normal.z ? c.min.z : c.max.z;
        b.z = 0 < f.normal.z ? c.max.z : c.min.z;
        var g = f.distanceToPoint(a),
          f = f.distanceToPoint(b);
        if (0 > g && 0 > f) return !1
      }
      return !0
    }
  }(),
  containsPoint: function(a) {
    for (var b = this.planes, c = 0; 6 > c; c++)
      if (0 > b[c].distanceToPoint(a)) return !1;
    return !0
  },
  clone: function() {
    return (new THREE.Frustum).copy(this)
  }
};
THREE.Plane = function(a, b) {
  this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
  this.constant = void 0 !== b ? b : 0
};
THREE.Plane.prototype = {
  constructor: THREE.Plane,
  set: function(a, b) {
    this.normal.copy(a);
    this.constant = b;
    return this
  },
  setComponents: function(a, b, c, d) {
    this.normal.set(a, b, c);
    this.constant = d;
    return this
  },
  setFromNormalAndCoplanarPoint: function(a, b) {
    this.normal.copy(a);
    this.constant = -b.dot(this.normal);
    return this
  },
  setFromCoplanarPoints: function() {
    var a = new THREE.Vector3,
      b = new THREE.Vector3;
    return function(c, d, e) {
      d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
      this.setFromNormalAndCoplanarPoint(d, c);
      return this
    }
  }(),
  copy: function(a) {
    this.normal.copy(a.normal);
    this.constant = a.constant;
    return this
  },
  normalize: function() {
    var a = 1 / this.normal.length();
    this.normal.multiplyScalar(a);
    this.constant *= a;
    return this
  },
  negate: function() {
    this.constant *= -1;
    this.normal.negate();
    return this
  },
  distanceToPoint: function(a) {
    return this.normal.dot(a) + this.constant
  },
  distanceToSphere: function(a) {
    return this.distanceToPoint(a.center) - a.radius
  },
  projectPoint: function(a, b) {
    return this.orthoPoint(a, b).sub(a).negate()
  },
  orthoPoint: function(a, b) {
    var c = this.distanceToPoint(a);
    return (b || new THREE.Vector3).copy(this.normal).multiplyScalar(c)
  },
  isIntersectionLine: function(a) {
    var b = this.distanceToPoint(a.start);
    a = this.distanceToPoint(a.end);
    return 0 > b && 0 < a || 0 > a && 0 < b
  },
  intersectLine: function() {
    var a = new THREE.Vector3;
    return function(b, c) {
      var d = c || new THREE.Vector3,
        e = b.delta(a),
        f = this.normal.dot(e);
      if (0 == f) {
        if (0 == this.distanceToPoint(b.start)) return d.copy(b.start)
      } else return f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)
    }
  }(),
  coplanarPoint: function(a) {
    return (a || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
  },
  applyMatrix4: function() {
    var a = new THREE.Vector3,
      b = new THREE.Vector3,
      c = new THREE.Matrix3;
    return function(d, e) {
      var f = e || c.getNormalMatrix(d),
        f = a.copy(this.normal).applyMatrix3(f),
        g = this.coplanarPoint(b);
      g.applyMatrix4(d);
      this.setFromNormalAndCoplanarPoint(f, g);
      return this
    }
  }(),
  translate: function(a) {
    this.constant -= a.dot(this.normal);
    return this
  },
  equals: function(a) {
    return a.normal.equals(this.normal) && a.constant == this.constant
  },
  clone: function() {
    return (new THREE.Plane).copy(this)
  }
};
THREE.Math = {
  generateUUID: function() {
    var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
      b = Array(36),
      c = 0,
      d;
    return function() {
      for (var e = 0; 36 > e; e++) 8 == e || 13 == e || 18 == e || 23 == e ? b[e] = "-" : 14 == e ? b[e] = "4" : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 == e ? d & 3 | 8 : d]);
      return b.join("")
    }
  }(),
  clamp: function(a, b, c) {
    return a < b ? b : a > c ? c : a
  },
  clampBottom: function(a, b) {
    return a < b ? b : a
  },
  mapLinear: function(a, b, c, d, e) {
    return d + (a - b) * (e - d) / (c - b)
  },
  smoothstep: function(a, b, c) {
    if (a <= b) return 0;
    if (a >= c) return 1;
    a = (a - b) / (c - b);
    return a * a * (3 - 2 * a)
  },
  smootherstep: function(a, b, c) {
    if (a <= b) return 0;
    if (a >= c) return 1;
    a = (a - b) / (c - b);
    return a * a * a * (a * (6 * a - 15) + 10)
  },
  random16: function() {
    return (65280 * Math.random() + 255 * Math.random()) / 65535
  },
  randInt: function(a, b) {
    return Math.floor(this.randFloat(a, b))
  },
  randFloat: function(a, b) {
    return a + Math.random() * (b - a)
  },
  randFloatSpread: function(a) {
    return a * (.5 - Math.random())
  },
  degToRad: function() {
    var a = Math.PI / 180;
    return function(b) {
      return b * a
    }
  }(),
  radToDeg: function() {
    var a = 180 / Math.PI;
    return function(b) {
      return b * a
    }
  }(),
  isPowerOfTwo: function(a) {
    return 0 === (a & a - 1) && 0 !== a
  }
};
THREE.Spline = function(a) {
  function b(a, b, c, d, e, f, g) {
    a = .5 * (c - a);
    d = .5 * (d - b);
    return (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b
  }
  this.points = a;
  var c = [],
    d = {
      x: 0,
      y: 0,
      z: 0
    },
    e, f, g, h, k, n, p, q, m;
  this.initFromArray = function(a) {
    this.points = [];
    for (var b = 0; b < a.length; b++) this.points[b] = {
      x: a[b][0],
      y: a[b][1],
      z: a[b][2]
    }
  };
  this.getPoint = function(a) {
    e = (this.points.length - 1) * a;
    f = Math.floor(e);
    g = e - f;
    c[0] = 0 === f ? f : f - 1;
    c[1] = f;
    c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;
    c[3] = f > this.points.length - 3 ? this.points.length - 1 : f + 2;
    n = this.points[c[0]];
    p = this.points[c[1]];
    q = this.points[c[2]];
    m = this.points[c[3]];
    h = g * g;
    k = g * h;
    d.x = b(n.x, p.x, q.x, m.x, g, h, k);
    d.y = b(n.y, p.y, q.y, m.y, g, h, k);
    d.z = b(n.z, p.z, q.z, m.z, g, h, k);
    return d
  };
  this.getControlPointsArray = function() {
    var a, b, c = this.points.length,
      d = [];
    for (a = 0; a < c; a++) b = this.points[a], d[a] = [b.x, b.y, b.z];
    return d
  };
  this.getLength = function(a) {
    var b, c, d, e = b = b = 0,
      f = new THREE.Vector3,
      g = new THREE.Vector3,
      h = [],
      k = 0;
    h[0] = 0;
    a || (a = 100);
    c = this.points.length * a;
    f.copy(this.points[0]);
    for (a = 1; a < c; a++) b = a / c, d = this.getPoint(b), g.copy(d), k += g.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b != e && (h[b] = k, e = b);
    h[h.length] = k;
    return {
      chunks: h,
      total: k
    }
  };
  this.reparametrizeByArcLength = function(a) {
    var b, c, d, e, f, g, h = [],
      k = new THREE.Vector3,
      m = this.getLength();
    h.push(k.copy(this.points[0]).clone());
    for (b = 1; b < this.points.length; b++) {
      c = m.chunks[b] - m.chunks[b - 1];
      g = Math.ceil(a * c / m.total);
      e = (b - 1) / (this.points.length - 1);
      f = b / (this.points.length - 1);
      for (c = 1; c < g - 1; c++) d = e + 1 / g * c * (f - e), d = this.getPoint(d), h.push(k.copy(d).clone());
      h.push(k.copy(this.points[b]).clone())
    }
    this.points = h
  }
};
THREE.Triangle = function(a, b, c) {
  this.a = void 0 !== a ? a : new THREE.Vector3;
  this.b = void 0 !== b ? b : new THREE.Vector3;
  this.c = void 0 !== c ? c : new THREE.Vector3
};
THREE.Triangle.normal = function() {
  var a = new THREE.Vector3;
  return function(b, c, d, e) {
    e = e || new THREE.Vector3;
    e.subVectors(d, c);
    a.subVectors(b, c);
    e.cross(a);
    b = e.lengthSq();
    return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
  }
}();
THREE.Triangle.barycoordFromPoint = function() {
  var a = new THREE.Vector3,
    b = new THREE.Vector3,
    c = new THREE.Vector3;
  return function(d, e, f, g, h) {
    a.subVectors(g, e);
    b.subVectors(f, e);
    c.subVectors(d, e);
    d = a.dot(a);
    e = a.dot(b);
    f = a.dot(c);
    var k = b.dot(b);
    g = b.dot(c);
    var n = d * k - e * e;
    h = h || new THREE.Vector3;
    if (0 == n) return h.set(-2, -1, -1);
    n = 1 / n;
    k = (k * f - e * g) * n;
    d = (d * g - e * f) * n;
    return h.set(1 - k - d, d, k)
  }
}();
THREE.Triangle.containsPoint = function() {
  var a = new THREE.Vector3;
  return function(b, c, d, e) {
    b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);
    return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
  }
}();
THREE.Triangle.prototype = {
  constructor: THREE.Triangle,
  set: function(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this
  },
  setFromPointsAndIndices: function(a, b, c, d) {
    this.a.copy(a[b]);
    this.b.copy(a[c]);
    this.c.copy(a[d]);
    return this
  },
  copy: function(a) {
    this.a.copy(a.a);
    this.b.copy(a.b);
    this.c.copy(a.c);
    return this
  },
  area: function() {
    var a = new THREE.Vector3,
      b = new THREE.Vector3;
    return function() {
      a.subVectors(this.c, this.b);
      b.subVectors(this.a, this.b);
      return .5 * a.cross(b).length()
    }
  }(),
  midpoint: function(a) {
    return (a || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
  },
  normal: function(a) {
    return THREE.Triangle.normal(this.a, this.b, this.c, a)
  },
  plane: function(a) {
    return (a || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
  },
  barycoordFromPoint: function(a, b) {
    return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b)
  },
  containsPoint: function(a) {
    return THREE.Triangle.containsPoint(a, this.a, this.b, this.c)
  },
  equals: function(a) {
    return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
  },
  clone: function() {
    return (new THREE.Triangle).copy(this)
  }
};
THREE.Clock = function(a) {
  this.autoStart = void 0 !== a ? a : !0;
  this.elapsedTime = this.oldTime = this.startTime = 0;
  this.running = !1
};
THREE.Clock.prototype = {
  constructor: THREE.Clock,
  start: function() {
    this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
    this.running = !0
  },
  stop: function() {
    this.getElapsedTime();
    this.running = !1
  },
  getElapsedTime: function() {
    this.getDelta();
    return this.elapsedTime
  },
  getDelta: function() {
    var a = 0;
    this.autoStart && !this.running && this.start();
    if (this.running) {
      var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now(),
        a = .001 * (b - this.oldTime);
      this.oldTime = b;
      this.elapsedTime += a
    }
    return a
  }
};
THREE.EventDispatcher = function() {};
THREE.EventDispatcher.prototype = {
  constructor: THREE.EventDispatcher,
  apply: function(a) {
    a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
  },
  addEventListener: function(a, b) {
    void 0 === this._listeners && (this._listeners = {});
    var c = this._listeners;
    void 0 === c[a] && (c[a] = []); - 1 === c[a].indexOf(b) && c[a].push(b)
  },
  hasEventListener: function(a, b) {
    if (void 0 === this._listeners) return !1;
    var c = this._listeners;
    return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1
  },
  removeEventListener: function(a, b) {
    if (void 0 !== this._listeners) {
      var c = this._listeners[a];
      if (void 0 !== c) {
        var d = c.indexOf(b); - 1 !== d && c.splice(d, 1)
      }
    }
  },
  dispatchEvent: function(a) {
    if (void 0 !== this._listeners) {
      var b = this._listeners[a.type];
      if (void 0 !== b) {
        a.target = this;
        for (var c = [], d = b.length, e = 0; e < d; e++) c[e] = b[e];
        for (e = 0; e < d; e++) c[e].call(this, a)
      }
    }
  }
};
(function(a) {
  a.Raycaster = function(b, c, f, g) {
    this.ray = new a.Ray(b, c);
    this.near = f || 0;
    this.far = g || Infinity;
    this.params = {
      Sprite: {},
      Mesh: {},
      PointCloud: {
        threshold: 1
      },
      LOD: {},
      Line: {}
    }
  };
  var b = function(a, b) {
      return a.distance - b.distance
    },
    c = function(a, b, f, g) {
      a.raycast(b, f);
      if (!0 === g) {
        a = a.children;
        g = 0;
        for (var h = a.length; g < h; g++) c(a[g], b, f, !0)
      }
    };
  a.Raycaster.prototype = {
    constructor: a.Raycaster,
    precision: 1E-4,
    linePrecision: 1,
    set: function(a, b) {
      this.ray.set(a, b)
    },
    setFromCamera: function(b, c) {
      c instanceof a.PerspectiveCamera ? (this.ray.origin.copy(c.position), this.ray.direction.set(b.x, b.y, .5).unproject(c).sub(c.position).normalize()) : c instanceof a.OrthographicCamera ? (this.ray.origin.set(b.x, b.y, -1).unproject(c), this.ray.direction.set(0, 0, -1).transformDirection(c.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
    },
    intersectObject: function(a, e) {
      var f = [];
      c(a, this, f, e);
      f.sort(b);
      return f
    },
    intersectObjects: function(a, e) {
      var f = [];
      if (!1 === a instanceof Array) return console.log("THREE.Raycaster.intersectObjects: objects is not an Array."), f;
      for (var g = 0, h = a.length; g < h; g++) c(a[g], this, f, e);
      f.sort(b);
      return f
    }
  }
})(THREE);
THREE.Object3D = function() {
  Object.defineProperty(this, "id", {
    value: THREE.Object3DIdCount++
  });
  this.uuid = THREE.Math.generateUUID();
  this.name = "";
  this.type = "Object3D";
  this.parent = void 0;
  this.children = [];
  this.up = THREE.Object3D.DefaultUp.clone();
  var a = new THREE.Vector3,
    b = new THREE.Euler,
    c = new THREE.Quaternion,
    d = new THREE.Vector3(1, 1, 1);
  b.onChange(function() {
    c.setFromEuler(b, !1)
  });
  c.onChange(function() {
    b.setFromQuaternion(c, void 0, !1)
  });
  Object.defineProperties(this, {
    position: {
      enumerable: !0,
      value: a
    },
    rotation: {
      enumerable: !0,
      value: b
    },
    quaternion: {
      enumerable: !0,
      value: c
    },
    scale: {
      enumerable: !0,
      value: d
    }
  });
  this.rotationAutoUpdate = !0;
  this.matrix = new THREE.Matrix4;
  this.matrixWorld = new THREE.Matrix4;
  this.matrixAutoUpdate = !0;
  this.matrixWorldNeedsUpdate = !1;
  this.visible = !0;
  this.receiveShadow = this.castShadow = !1;
  this.frustumCulled = !0;
  this.userData = {}
};
THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
THREE.Object3D.prototype = {
  constructor: THREE.Object3D,
  get eulerOrder() {
    console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order.");
    return this.rotation.order
  },
  set eulerOrder(a) {
    console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order.");
    this.rotation.order = a
  },
  get useQuaternion() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
  },
  set useQuaternion(a) {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
  },
  applyMatrix: function(a) {
    this.matrix.multiplyMatrices(a, this.matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale)
  },
  setRotationFromAxisAngle: function(a, b) {
    this.quaternion.setFromAxisAngle(a, b)
  },
  setRotationFromEuler: function(a) {
    this.quaternion.setFromEuler(a, !0)
  },
  setRotationFromMatrix: function(a) {
    this.quaternion.setFromRotationMatrix(a)
  },
  setRotationFromQuaternion: function(a) {
    this.quaternion.copy(a)
  },
  rotateOnAxis: function() {
    var a = new THREE.Quaternion;
    return function(b, c) {
      a.setFromAxisAngle(b, c);
      this.quaternion.multiply(a);
      return this
    }
  }(),
  rotateX: function() {
    var a = new THREE.Vector3(1, 0, 0);
    return function(b) {
      return this.rotateOnAxis(a, b)
    }
  }(),
  rotateY: function() {
    var a = new THREE.Vector3(0, 1, 0);
    return function(b) {
      return this.rotateOnAxis(a, b)
    }
  }(),
  rotateZ: function() {
    var a = new THREE.Vector3(0, 0, 1);
    return function(b) {
      return this.rotateOnAxis(a, b)
    }
  }(),
  translateOnAxis: function() {
    var a = new THREE.Vector3;
    return function(b, c) {
      a.copy(b).applyQuaternion(this.quaternion);
      this.position.add(a.multiplyScalar(c));
      return this
    }
  }(),
  translate: function(a, b) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(b, a)
  },
  translateX: function() {
    var a = new THREE.Vector3(1, 0, 0);
    return function(b) {
      return this.translateOnAxis(a, b)
    }
  }(),
  translateY: function() {
    var a = new THREE.Vector3(0, 1, 0);
    return function(b) {
      return this.translateOnAxis(a, b)
    }
  }(),
  translateZ: function() {
    var a = new THREE.Vector3(0, 0, 1);
    return function(b) {
      return this.translateOnAxis(a, b)
    }
  }(),
  localToWorld: function(a) {
    return a.applyMatrix4(this.matrixWorld)
  },
  worldToLocal: function() {
    var a = new THREE.Matrix4;
    return function(b) {
      return b.applyMatrix4(a.getInverse(this.matrixWorld))
    }
  }(),
  lookAt: function() {
    var a = new THREE.Matrix4;
    return function(b) {
      a.lookAt(b, this.position, this.up);
      this.quaternion.setFromRotationMatrix(a)
    }
  }(),
  add: function(a) {
    if (1 < arguments.length) {
      for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
      return this
    }
    if (a === this) return console.error("THREE.Object3D.add:", a, "can't be added as a child of itself."), this;
    a instanceof THREE.Object3D ? (void 0 !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({
      type: "added"
    }), this.children.push(a)) : console.error("THREE.Object3D.add:", a, "is not an instance of THREE.Object3D.");
    return this
  },
  remove: function(a) {
    if (1 < arguments.length)
      for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
    b = this.children.indexOf(a); - 1 !== b && (a.parent = void 0, a.dispatchEvent({
      type: "removed"
    }), this.children.splice(b, 1))
  },
  getChildByName: function(a, b) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(a, b)
  },
  getObjectById: function(a, b) {
    return this.getObjectByProperty("id", a, b)
  },
  getObjectByName: function(a, b) {
    return this.getObjectByProperty("name", a, b)
  },
  getObjectByProperty: function(a, b, c) {
    if (this[a] === b) return this;
    for (var d = 0, e = this.children.length; d < e; d++) {
      var f = this.children[d].getObjectByProperty(a, b, c);
      if (void 0 !== f) return f
    }
  },
  getWorldPosition: function(a) {
    a = a || new THREE.Vector3;
    this.updateMatrixWorld(!0);
    return a.setFromMatrixPosition(this.matrixWorld)
  },
  getWorldQuaternion: function() {
    var a = new THREE.Vector3,
      b = new THREE.Vector3;
    return function(c) {
      c = c || new THREE.Quaternion;
      this.updateMatrixWorld(!0);
      this.matrixWorld.decompose(a, c, b);
      return c
    }
  }(),
  getWorldRotation: function() {
    var a = new THREE.Quaternion;
    return function(b) {
      b = b || new THREE.Euler;
      this.getWorldQuaternion(a);
      return b.setFromQuaternion(a, this.rotation.order, !1)
    }
  }(),
  getWorldScale: function() {
    var a = new THREE.Vector3,
      b = new THREE.Quaternion;
    return function(c) {
      c = c || new THREE.Vector3;
      this.updateMatrixWorld(!0);
      this.matrixWorld.decompose(a, b, c);
      return c
    }
  }(),
  getWorldDirection: function() {
    var a = new THREE.Quaternion;
    return function(b) {
      b = b || new THREE.Vector3;
      this.getWorldQuaternion(a);
      return b.set(0, 0, 1).applyQuaternion(a)
    }
  }(),
  raycast: function() {},
  traverse: function(a) {
    a(this);
    for (var b = 0, c = this.children.length; b < c; b++) this.children[b].traverse(a)
  },
  traverseVisible: function(a) {
    if (!1 !== this.visible) {
      a(this);
      for (var b = 0, c = this.children.length; b < c; b++) this.children[b].traverseVisible(a)
    }
  },
  traverseAncestors: function(a) {
    this.parent && (a(this.parent), this.parent.traverseAncestors(a))
  },
  updateMatrix: function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = !0
  },
  updateMatrixWorld: function(a) {
    !0 === this.matrixAutoUpdate && this.updateMatrix();
    if (!0 === this.matrixWorldNeedsUpdate || !0 === a) void 0 === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
    for (var b = 0, c = this.children.length; b < c; b++) this.children[b].updateMatrixWorld(a)
  },
  toJSON: function() {
    var a = {
        metadata: {
          version: 4.3,
          type: "Object",
          generator: "ObjectExporter"
        }
      },
      b = {},
      c = function(c) {
        void 0 === a.geometries && (a.geometries = []);
        if (void 0 === b[c.uuid]) {
          var d = c.toJSON();
          delete d.metadata;
          b[c.uuid] = d;
          a.geometries.push(d)
        }
        return c.uuid
      },
      d = {},
      e = function(b) {
        void 0 === a.materials && (a.materials = []);
        if (void 0 === d[b.uuid]) {
          var c = b.toJSON();
          delete c.metadata;
          d[b.uuid] = c;
          a.materials.push(c)
        }
        return b.uuid
      },
      f = function(a) {
        var b = {};
        b.uuid = a.uuid;
        b.type = a.type;
        "" !== a.name && (b.name = a.name);
        "{}" !== JSON.stringify(a.userData) && (b.userData = a.userData);
        !0 !== a.visible && (b.visible = a.visible);
        a instanceof THREE.PerspectiveCamera ? (b.fov = a.fov, b.aspect = a.aspect, b.near = a.near, b.far = a.far) : a instanceof THREE.OrthographicCamera ? (b.left = a.left, b.right = a.right, b.top = a.top, b.bottom = a.bottom, b.near = a.near, b.far = a.far) : a instanceof THREE.AmbientLight ? b.color = a.color.getHex() : a instanceof THREE.DirectionalLight ? (b.color = a.color.getHex(), b.intensity = a.intensity) : a instanceof THREE.PointLight ? (b.color = a.color.getHex(), b.intensity = a.intensity, b.distance = a.distance) : a instanceof THREE.SpotLight ? (b.color = a.color.getHex(), b.intensity = a.intensity, b.distance = a.distance, b.angle = a.angle, b.exponent = a.exponent) : a instanceof THREE.HemisphereLight ? (b.color = a.color.getHex(), b.groundColor = a.groundColor.getHex()) : a instanceof THREE.Mesh ? (b.geometry = c(a.geometry), b.material = e(a.material)) : a instanceof THREE.Line ? (b.geometry = c(a.geometry), b.material = e(a.material)) : a instanceof THREE.Sprite && (b.material = e(a.material));
        b.matrix = a.matrix.toArray();
        if (0 < a.children.length) {
          b.children = [];
          for (var d = 0; d < a.children.length; d++) b.children.push(f(a.children[d]))
        }
        return b
      };
    a.object = f(this);
    return a
  },
  clone: function(a, b) {
    void 0 === a && (a = new THREE.Object3D);
    void 0 === b && (b = !0);
    a.name = this.name;
    a.up.copy(this.up);
    a.position.copy(this.position);
    a.quaternion.copy(this.quaternion);
    a.scale.copy(this.scale);
    a.rotationAutoUpdate = this.rotationAutoUpdate;
    a.matrix.copy(this.matrix);
    a.matrixWorld.copy(this.matrixWorld);
    a.matrixAutoUpdate = this.matrixAutoUpdate;
    a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
    a.visible = this.visible;
    a.castShadow = this.castShadow;
    a.receiveShadow = this.receiveShadow;
    a.frustumCulled = this.frustumCulled;
    a.userData = JSON.parse(JSON.stringify(this.userData));
    if (!0 === b)
      for (var c = 0; c < this.children.length; c++) a.add(this.children[c].clone());
    return a
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Face3 = function(a, b, c, d, e, f) {
  this.a = a;
  this.b = b;
  this.c = c;
  this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3;
  this.vertexNormals = d instanceof Array ? d : [];
  this.color = e instanceof THREE.Color ? e : new THREE.Color;
  this.vertexColors = e instanceof Array ? e : [];
  this.vertexTangents = [];
  this.materialIndex = void 0 !== f ? f : 0
};
THREE.Face3.prototype = {
  constructor: THREE.Face3,
  clone: function() {
    var a = new THREE.Face3(this.a, this.b, this.c);
    a.normal.copy(this.normal);
    a.color.copy(this.color);
    a.materialIndex = this.materialIndex;
    for (var b = 0, c = this.vertexNormals.length; b < c; b++) a.vertexNormals[b] = this.vertexNormals[b].clone();
    b = 0;
    for (c = this.vertexColors.length; b < c; b++) a.vertexColors[b] = this.vertexColors[b].clone();
    b = 0;
    for (c = this.vertexTangents.length; b < c; b++) a.vertexTangents[b] = this.vertexTangents[b].clone();
    return a
  }
};
THREE.Face4 = function(a, b, c, d, e, f, g) {
  console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
  return new THREE.Face3(a, b, c, e, f, g)
};
THREE.BufferAttribute = function(a, b) {
  this.array = a;
  this.itemSize = b;
  this.needsUpdate = !1
};
THREE.BufferAttribute.prototype = {
  constructor: THREE.BufferAttribute,
  get length() {
    return this.array.length
  },
  copyAt: function(a, b, c) {
    a *= this.itemSize;
    c *= b.itemSize;
    for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d]
  },
  set: function(a) {
    this.array.set(a);
    return this
  },
  setX: function(a, b) {
    this.array[a * this.itemSize] = b;
    return this
  },
  setY: function(a, b) {
    this.array[a * this.itemSize + 1] = b;
    return this
  },
  setZ: function(a, b) {
    this.array[a * this.itemSize + 2] = b;
    return this
  },
  setXY: function(a, b, c) {
    a *= this.itemSize;
    this.array[a] = b;
    this.array[a + 1] = c;
    return this
  },
  setXYZ: function(a, b, c, d) {
    a *= this.itemSize;
    this.array[a] = b;
    this.array[a + 1] = c;
    this.array[a + 2] = d;
    return this
  },
  setXYZW: function(a, b, c, d, e) {
    a *= this.itemSize;
    this.array[a] = b;
    this.array[a + 1] = c;
    this.array[a + 2] = d;
    this.array[a + 3] = e;
    return this
  },
  clone: function() {
    return new THREE.BufferAttribute(new this.array.constructor(this.array), this.itemSize)
  }
};
THREE.Int8Attribute = function(a, b) {
  console.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
  return new THREE.BufferAttribute(a, b)
};
THREE.Uint8Attribute = function(a, b) {
  console.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
  return new THREE.BufferAttribute(a, b)
};
THREE.Uint8ClampedAttribute = function(a, b) {
  console.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
  return new THREE.BufferAttribute(a, b)
};
THREE.Int16Attribute = function(a, b) {
  console.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
  return new THREE.BufferAttribute(a, b)
};
THREE.Uint16Attribute = function(a, b) {
  console.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
  return new THREE.BufferAttribute(a, b)
};
THREE.Int32Attribute = function(a, b) {
  console.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
  return new THREE.BufferAttribute(a, b)
};
THREE.Uint32Attribute = function(a, b) {
  console.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
  return new THREE.BufferAttribute(a, b)
};
THREE.Float32Attribute = function(a, b) {
  console.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
  return new THREE.BufferAttribute(a, b)
};
THREE.Float64Attribute = function(a, b) {
  console.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");
  return new THREE.BufferAttribute(a, b)
};
THREE.BufferGeometry = function() {
  Object.defineProperty(this, "id", {
    value: THREE.GeometryIdCount++
  });
  this.uuid = THREE.Math.generateUUID();
  this.name = "";
  this.type = "BufferGeometry";
  this.attributes = {};
  this.attributesKeys = [];
  this.offsets = this.drawcalls = [];
  this.boundingSphere = this.boundingBox = null
};
THREE.BufferGeometry.prototype = {
  constructor: THREE.BufferGeometry,
  addAttribute: function(a, b, c) {
    !1 === b instanceof THREE.BufferAttribute ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.attributes[a] = {
      array: b,
      itemSize: c
    }) : (this.attributes[a] = b, this.attributesKeys = Object.keys(this.attributes))
  },
  getAttribute: function(a) {
    return this.attributes[a]
  },
  addDrawCall: function(a, b, c) {
    this.drawcalls.push({
      start: a,
      count: b,
      index: void 0 !== c ? c : 0
    })
  },
  applyMatrix: function(a) {
    var b = this.attributes.position;
    void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0);
    b = this.attributes.normal;
    void 0 !== b && ((new THREE.Matrix3).getNormalMatrix(a).applyToVector3Array(b.array), b.needsUpdate = !0)
  },
  center: function() {},
  fromGeometry: function(a, b) {
    b = b || {
      vertexColors: THREE.NoColors
    };
    var c = a.vertices,
      d = a.faces,
      e = a.faceVertexUvs,
      f = b.vertexColors,
      g = 0 < e[0].length,
      h = 3 == d[0].vertexNormals.length,
      k = new Float32Array(9 * d.length);
    this.addAttribute("position", new THREE.BufferAttribute(k, 3));
    var n = new Float32Array(9 * d.length);
    this.addAttribute("normal", new THREE.BufferAttribute(n, 3));
    if (f !== THREE.NoColors) {
      var p = new Float32Array(9 * d.length);
      this.addAttribute("color", new THREE.BufferAttribute(p, 3))
    }
    if (!0 === g) {
      var q = new Float32Array(6 * d.length);
      this.addAttribute("uv", new THREE.BufferAttribute(q, 2))
    }
    for (var m = 0, t = 0, s = 0; m < d.length; m++, t += 6, s += 9) {
      var r = d[m],
        u = c[r.a],
        v = c[r.b],
        y = c[r.c];
      k[s] = u.x;
      k[s + 1] = u.y;
      k[s + 2] = u.z;
      k[s + 3] = v.x;
      k[s + 4] = v.y;
      k[s + 5] = v.z;
      k[s + 6] = y.x;
      k[s + 7] = y.y;
      k[s + 8] = y.z;
      !0 === h ? (u = r.vertexNormals[0], v = r.vertexNormals[1], y = r.vertexNormals[2], n[s] = u.x, n[s + 1] = u.y, n[s + 2] = u.z, n[s + 3] = v.x, n[s + 4] = v.y, n[s + 5] = v.z, n[s + 6] = y.x, n[s + 7] = y.y, n[s + 8] = y.z) : (u = r.normal, n[s] = u.x, n[s + 1] = u.y, n[s + 2] = u.z, n[s + 3] = u.x, n[s + 4] = u.y, n[s + 5] = u.z, n[s + 6] = u.x, n[s + 7] = u.y, n[s + 8] = u.z);
      f === THREE.FaceColors ? (r = r.color, p[s] = r.r, p[s + 1] = r.g, p[s + 2] = r.b, p[s + 3] = r.r, p[s + 4] = r.g, p[s + 5] = r.b, p[s + 6] = r.r, p[s + 7] = r.g, p[s + 8] = r.b) : f === THREE.VertexColors && (u = r.vertexColors[0], v = r.vertexColors[1], r = r.vertexColors[2], p[s] = u.r, p[s + 1] = u.g, p[s + 2] = u.b, p[s + 3] = v.r, p[s + 4] = v.g, p[s + 5] = v.b, p[s + 6] = r.r, p[s + 7] = r.g, p[s + 8] = r.b);
      !0 === g && (r = e[0][m][0], u = e[0][m][1], v = e[0][m][2], q[t] = r.x, q[t + 1] = r.y, q[t + 2] = u.x, q[t + 3] = u.y, q[t + 4] = v.x, q[t + 5] = v.y)
    }
    this.computeBoundingSphere();
    return this
  },
  computeBoundingBox: function() {
    var a = new THREE.Vector3;
    return function() {
      null === this.boundingBox && (this.boundingBox = new THREE.Box3);
      var b = this.attributes.position.array;
      if (b) {
        var c = this.boundingBox;
        c.makeEmpty();
        for (var d = 0, e = b.length; d < e; d += 3) a.set(b[d], b[d + 1], b[d + 2]), c.expandByPoint(a)
      }
      if (void 0 === b || 0 === b.length) this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0);
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.')
    }
  }(),
  computeBoundingSphere: function() {
    var a = new THREE.Box3,
      b = new THREE.Vector3;
    return function() {
      null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
      var c = this.attributes.position.array;
      if (c) {
        a.makeEmpty();
        for (var d = this.boundingSphere.center, e = 0, f = c.length; e < f; e += 3) b.set(c[e], c[e + 1], c[e + 2]), a.expandByPoint(b);
        a.center(d);
        for (var g = 0, e = 0, f = c.length; e < f; e += 3) b.set(c[e], c[e + 1], c[e + 2]), g = Math.max(g, d.distanceToSquared(b));
        this.boundingSphere.radius = Math.sqrt(g);
        isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')
      }
    }
  }(),
  computeFaceNormals: function() {},
  computeVertexNormals: function() {
    var a = this.attributes;
    if (a.position) {
      var b = a.position.array;
      if (void 0 === a.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(b.length), 3));
      else
        for (var c = a.normal.array, d = 0, e = c.length; d < e; d++) c[d] = 0;
      var c = a.normal.array,
        f, g, h, k = new THREE.Vector3,
        n = new THREE.Vector3,
        p = new THREE.Vector3,
        q = new THREE.Vector3,
        m = new THREE.Vector3;
      if (a.index)
        for (var t = a.index.array, s = 0 < this.offsets.length ? this.offsets : [{
            start: 0,
            count: t.length,
            index: 0
          }], r = 0, u = s.length; r < u; ++r) {
          e = s[r].start;
          f = s[r].count;
          for (var v = s[r].index, d = e, e = e + f; d < e; d += 3) f = 3 * (v + t[d]), g = 3 * (v + t[d + 1]), h = 3 * (v + t[d + 2]), k.fromArray(b, f), n.fromArray(b, g), p.fromArray(b, h), q.subVectors(p, n), m.subVectors(k, n), q.cross(m), c[f] += q.x, c[f + 1] += q.y, c[f + 2] += q.z, c[g] += q.x, c[g + 1] += q.y, c[g + 2] += q.z, c[h] += q.x, c[h + 1] += q.y, c[h + 2] += q.z
        } else
          for (d = 0, e = b.length; d < e; d += 9) k.fromArray(b, d), n.fromArray(b, d + 3), p.fromArray(b, d + 6), q.subVectors(p, n), m.subVectors(k, n), q.cross(m), c[d] = q.x, c[d + 1] = q.y, c[d + 2] = q.z, c[d + 3] = q.x, c[d + 4] = q.y, c[d + 5] = q.z, c[d + 6] = q.x, c[d + 7] = q.y, c[d + 8] = q.z;
      this.normalizeNormals();
      a.normal.needsUpdate = !0
    }
  },
  computeTangents: function() {
    function a(a, b, c) {
      q.fromArray(d, 3 * a);
      m.fromArray(d, 3 * b);
      t.fromArray(d, 3 * c);
      s.fromArray(f, 2 * a);
      r.fromArray(f, 2 * b);
      u.fromArray(f, 2 * c);
      v = m.x - q.x;
      y = t.x - q.x;
      C = m.y - q.y;
      x = t.y - q.y;
      F = m.z - q.z;
      z = t.z - q.z;
      G = r.x - s.x;
      E = u.x - s.x;
      w = r.y - s.y;
      D = u.y - s.y;
      A = 1 / (G * D - E * w);
      U.set((D * v - w * y) * A, (D * C - w * x) * A, (D * F - w * z) * A);
      M.set((G * y - E * v) * A, (G * x - E * C) * A, (G * z - E * F) * A);
      k[a].add(U);
      k[b].add(U);
      k[c].add(U);
      n[a].add(M);
      n[b].add(M);
      n[c].add(M)
    }

    function b(a) {
      xa.fromArray(e, 3 * a);
      H.copy(xa);
      qa = k[a];
      ga.copy(qa);
      ga.sub(xa.multiplyScalar(xa.dot(qa))).normalize();
      ea.crossVectors(H, qa);
      ya = ea.dot(n[a]);
      $a = 0 > ya ? -1 : 1;
      h[4 * a] = ga.x;
      h[4 * a + 1] = ga.y;
      h[4 * a + 2] = ga.z;
      h[4 * a + 3] = $a
    }
    if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv) console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
    else {
      var c = this.attributes.index.array,
        d = this.attributes.position.array,
        e = this.attributes.normal.array,
        f = this.attributes.uv.array,
        g = d.length / 3;
      void 0 === this.attributes.tangent && this.addAttribute("tangent", new THREE.BufferAttribute(new Float32Array(4 * g), 4));
      for (var h = this.attributes.tangent.array, k = [], n = [], p = 0; p < g; p++) k[p] = new THREE.Vector3, n[p] = new THREE.Vector3;
      var q = new THREE.Vector3,
        m = new THREE.Vector3,
        t = new THREE.Vector3,
        s = new THREE.Vector2,
        r = new THREE.Vector2,
        u = new THREE.Vector2,
        v, y, C, x, F, z, G, E, w, D, A, U = new THREE.Vector3,
        M = new THREE.Vector3,
        K, L, N, T, Q;
      0 === this.drawcalls.length && this.addDrawCall(0, c.length, 0);
      var W = this.drawcalls,
        p = 0;
      for (L = W.length; p < L; ++p) {
        K = W[p].start;
        N = W[p].count;
        var O = W[p].index,
          g = K;
        for (K += N; g < K; g += 3) N = O + c[g], T = O + c[g + 1], Q = O + c[g + 2], a(N, T, Q)
      }
      var ga = new THREE.Vector3,
        ea = new THREE.Vector3,
        xa = new THREE.Vector3,
        H = new THREE.Vector3,
        $a, qa, ya, p = 0;
      for (L = W.length; p < L; ++p)
        for (K = W[p].start, N = W[p].count, O = W[p].index, g = K, K += N; g < K; g += 3) N = O + c[g], T = O + c[g + 1], Q = O + c[g + 2], b(N), b(T), b(Q)
    }
  },
  computeOffsets: function(a) {
    var b = a;
    void 0 === a && (b = 65535);
    Date.now();
    a = this.attributes.index.array;
    for (var c = this.attributes.position.array, d = a.length / 3, e = new Uint16Array(a.length), f = 0, g = 0, h = [{
        start: 0,
        count: 0,
        index: 0
      }], k = h[0], n = 0, p = 0, q = new Int32Array(6), m = new Int32Array(c.length), t = new Int32Array(c.length), s = 0; s < c.length; s++) m[s] = -1, t[s] = -1;
    for (c = 0; c < d; c++) {
      for (var r = p = 0; 3 > r; r++) s = a[3 * c + r], -1 == m[s] ? (q[2 * r] = s, q[2 * r + 1] = -1, p++) : m[s] < k.index ? (q[2 * r] = s, q[2 * r + 1] = -1, n++) : (q[2 * r] = s, q[2 * r + 1] = m[s]);
      if (g + p > k.index + b)
        for (k = {
            start: f,
            count: 0,
            index: g
          }, h.push(k), p = 0; 6 > p; p += 2) r = q[p + 1], -1 < r && r < k.index && (q[p + 1] = -1);
      for (p = 0; 6 > p; p += 2) s = q[p], r = q[p + 1], -1 === r && (r = g++), m[s] = r, t[r] = s, e[f++] = r - k.index, k.count++
    }
    this.reorderBuffers(e, t, g);
    return this.offsets = h
  },
  merge: function(a, b) {
    if (!1 === a instanceof THREE.BufferGeometry) console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
    else {
      void 0 === b && (b = 0);
      var c = this.attributes,
        d;
      for (d in c)
        if (void 0 !== a.attributes[d])
          for (var e = c[d].array, f = a.attributes[d], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++, f++) e[f] = g[h];
      return this
    }
  },
  normalizeNormals: function() {
    for (var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length; e < f; e += 3) b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b
  },
  reorderBuffers: function(a, b, c) {
    var d = {},
      e;
    for (e in this.attributes) "index" != e && (d[e] = new this.attributes[e].array.constructor(this.attributes[e].itemSize * c));
    for (var f = 0; f < c; f++) {
      var g = b[f];
      for (e in this.attributes)
        if ("index" != e)
          for (var h = this.attributes[e].array, k = this.attributes[e].itemSize, n = d[e], p = 0; p < k; p++) n[f * k + p] = h[g * k + p]
    }
    this.attributes.index.array = a;
    for (e in this.attributes) "index" != e && (this.attributes[e].array = d[e], this.attributes[e].numItems = this.attributes[e].itemSize * c)
  },
  toJSON: function() {
    var a = {
        metadata: {
          version: 4,
          type: "BufferGeometry",
          generator: "BufferGeometryExporter"
        },
        uuid: this.uuid,
        type: this.type,
        data: {
          attributes: {}
        }
      },
      b = this.attributes,
      c = this.offsets,
      d = this.boundingSphere,
      e;
    for (e in b) {
      for (var f = b[e], g = [], h = f.array, k = 0, n = h.length; k < n; k++) g[k] = h[k];
      a.data.attributes[e] = {
        itemSize: f.itemSize,
        type: f.array.constructor.name,
        array: g
      }
    }
    0 < c.length && (a.data.offsets = JSON.parse(JSON.stringify(c)));
    null !== d && (a.data.boundingSphere = {
      center: d.center.toArray(),
      radius: d.radius
    });
    return a
  },
  clone: function() {
    var a = new THREE.BufferGeometry,
      b;
    for (b in this.attributes) a.addAttribute(b, this.attributes[b].clone());
    b = 0;
    for (var c = this.offsets.length; b < c; b++) {
      var d = this.offsets[b];
      a.offsets.push({
        start: d.start,
        index: d.index,
        count: d.count
      })
    }
    return a
  },
  dispose: function() {
    this.dispatchEvent({
      type: "dispose"
    })
  }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Geometry = function() {
  Object.defineProperty(this, "id", {
    value: THREE.GeometryIdCount++
  });
  this.uuid = THREE.Math.generateUUID();
  this.name = "";
  this.type = "Geometry";
  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [
    []
  ];
  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];
  this.skinWeights = [];
  this.skinIndices = [];
  this.lineDistances = [];
  this.boundingSphere = this.boundingBox = null;
  this.hasTangents = !1;
  this.dynamic = !0;
  this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
};
THREE.Geometry.prototype = {
  constructor: THREE.Geometry,
  applyMatrix: function(a) {
    for (var b = (new THREE.Matrix3).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
    c = 0;
    for (d = this.faces.length; c < d; c++) {
      a = this.faces[c];
      a.normal.applyMatrix3(b).normalize();
      for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize()
    }
    this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox();
    this.boundingSphere instanceof THREE.Sphere && this.computeBoundingSphere()
  },
  fromBufferGeometry: function(a) {
    for (var b = this, c = a.attributes, d = c.position.array, e = void 0 !== c.index ? c.index.array : void 0, f = void 0 !== c.normal ? c.normal.array : void 0, g = void 0 !== c.color ? c.color.array : void 0, h = void 0 !== c.uv ? c.uv.array : void 0, k = [], n = [], p = c = 0; c < d.length; c += 3, p += 2) b.vertices.push(new THREE.Vector3(d[c], d[c + 1], d[c + 2])), void 0 !== f && k.push(new THREE.Vector3(f[c], f[c + 1], f[c + 2])), void 0 !== g && b.colors.push(new THREE.Color(g[c], g[c + 1], g[c + 2])), void 0 !== h && n.push(new THREE.Vector2(h[p], h[p + 1]));
    p = function(a, c, d) {
      var e = void 0 !== f ? [k[a].clone(), k[c].clone(), k[d].clone()] : [],
        p = void 0 !== g ? [b.colors[a].clone(), b.colors[c].clone(), b.colors[d].clone()] : [];
      b.faces.push(new THREE.Face3(a, c, d, e, p));
      void 0 !== h && b.faceVertexUvs[0].push([n[a].clone(), n[c].clone(), n[d].clone()])
    };
    if (void 0 !== e)
      for (c = 0; c < e.length; c += 3) p(e[c], e[c + 1], e[c + 2]);
    else
      for (c = 0; c < d.length / 3; c += 3) p(c, c + 1, c + 2);
    this.computeFaceNormals();
    null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
    null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
    return this
  },
  center: function() {
    this.computeBoundingBox();
    var a = new THREE.Vector3;
    a.addVectors(this.boundingBox.min, this.boundingBox.max);
    a.multiplyScalar(-.5);
    this.applyMatrix((new THREE.Matrix4).makeTranslation(a.x, a.y, a.z));
    this.computeBoundingBox();
    return a
  },
  computeFaceNormals: function() {
    for (var a = new THREE.Vector3, b = new THREE.Vector3, c = 0, d = this.faces.length; c < d; c++) {
      var e = this.faces[c],
        f = this.vertices[e.a],
        g = this.vertices[e.b];
      a.subVectors(this.vertices[e.c], g);
      b.subVectors(f, g);
      a.cross(b);
      a.normalize();
      e.normal.copy(a)
    }
  },
  computeVertexNormals: function(a) {
    var b, c, d;
    d = Array(this.vertices.length);
    b = 0;
    for (c = this.vertices.length; b < c; b++) d[b] = new THREE.Vector3;
    if (a) {
      var e, f, g, h = new THREE.Vector3,
        k = new THREE.Vector3;
      new THREE.Vector3;
      new THREE.Vector3;
      new THREE.Vector3;
      a = 0;
      for (b = this.faces.length; a < b; a++) c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), k.subVectors(e, f), h.cross(k), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h)
    } else
      for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
    b = 0;
    for (c = this.vertices.length; b < c; b++) d[b].normalize();
    a = 0;
    for (b = this.faces.length; a < b; a++) c = this.faces[a], c.vertexNormals[0] = d[c.a].clone(), c.vertexNormals[1] = d[c.b].clone(), c.vertexNormals[2] = d[c.c].clone()
  },
  computeMorphNormals: function() {
    var a, b, c, d, e;
    c = 0;
    for (d = this.faces.length; c < d; c++)
      for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
    var f = new THREE.Geometry;
    f.faces = this.faces;
    a = 0;
    for (b = this.morphTargets.length; a < b; a++) {
      if (!this.morphNormals[a]) {
        this.morphNormals[a] = {};
        this.morphNormals[a].faceNormals = [];
        this.morphNormals[a].vertexNormals = [];
        e = this.morphNormals[a].faceNormals;
        var g = this.morphNormals[a].vertexNormals,
          h, k;
        c = 0;
        for (d = this.faces.length; c < d; c++) h = new THREE.Vector3, k = {
          a: new THREE.Vector3,
          b: new THREE.Vector3,
          c: new THREE.Vector3
        }, e.push(h), g.push(k)
      }
      g = this.morphNormals[a];
      f.vertices = this.morphTargets[a].vertices;
      f.computeFaceNormals();
      f.computeVertexNormals();
      c = 0;
      for (d = this.faces.length; c < d; c++) e = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(e.normal), k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2])
    }
    c = 0;
    for (d = this.faces.length; c < d; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
  },
  computeTangents: function() {
    var a, b, c, d, e, f, g, h, k, n, p, q, m, t, s, r, u, v = [],
      y = [];
    c = new THREE.Vector3;
    var C = new THREE.Vector3,
      x = new THREE.Vector3,
      F = new THREE.Vector3,
      z = new THREE.Vector3;
    a = 0;
    for (b = this.vertices.length; a < b; a++) v[a] = new THREE.Vector3, y[a] = new THREE.Vector3;
    a = 0;
    for (b = this.faces.length; a < b; a++) e = this.faces[a], f = this.faceVertexUvs[0][a], d = e.a, u = e.b, e = e.c, g = this.vertices[d], h = this.vertices[u], k = this.vertices[e], n = f[0], p = f[1], q = f[2], f = h.x - g.x, m = k.x - g.x, t = h.y - g.y, s = k.y - g.y, h = h.z - g.z, g = k.z - g.z, k = p.x - n.x, r = q.x - n.x, p = p.y - n.y, n = q.y - n.y, q = 1 / (k * n - r * p), c.set((n * f - p * m) * q, (n * t - p * s) * q, (n * h - p * g) * q), C.set((k * m - r * f) * q, (k * s - r * t) * q, (k * g - r * h) * q), v[d].add(c), v[u].add(c), v[e].add(c), y[d].add(C), y[u].add(C), y[e].add(C);
    C = ["a", "b", "c", "d"];
    a = 0;
    for (b = this.faces.length; a < b; a++)
      for (e = this.faces[a], c = 0; c < Math.min(e.vertexNormals.length, 3); c++) z.copy(e.vertexNormals[c]), d = e[C[c]], u = v[d], x.copy(u), x.sub(z.multiplyScalar(z.dot(u))).normalize(), F.crossVectors(e.vertexNormals[c], u), d = F.dot(y[d]), d = 0 > d ? -1 : 1, e.vertexTangents[c] = new THREE.Vector4(x.x, x.y, x.z, d);
    this.hasTangents = !0
  },
  computeLineDistances: function() {
    for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) 0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
  },
  computeBoundingBox: function() {
    null === this.boundingBox && (this.boundingBox = new THREE.Box3);
    this.boundingBox.setFromPoints(this.vertices)
  },
  computeBoundingSphere: function() {
    null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
    this.boundingSphere.setFromPoints(this.vertices)
  },
  merge: function(a, b, c) {
    if (!1 === a instanceof THREE.Geometry) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
    else {
      var d, e = this.vertices.length,
        f = this.vertices,
        g = a.vertices,
        h = this.faces,
        k = a.faces,
        n = this.faceVertexUvs[0];
      a = a.faceVertexUvs[0];
      void 0 === c && (c = 0);
      void 0 !== b && (d = (new THREE.Matrix3).getNormalMatrix(b));
      for (var p = 0, q = g.length; p < q; p++) {
        var m = g[p].clone();
        void 0 !== b && m.applyMatrix4(b);
        f.push(m)
      }
      p = 0;
      for (q = k.length; p < q; p++) {
        var g = k[p],
          t, s = g.vertexNormals,
          r = g.vertexColors,
          m = new THREE.Face3(g.a + e, g.b + e, g.c + e);
        m.normal.copy(g.normal);
        void 0 !== d && m.normal.applyMatrix3(d).normalize();
        b = 0;
        for (f = s.length; b < f; b++) t = s[b].clone(), void 0 !== d && t.applyMatrix3(d).normalize(), m.vertexNormals.push(t);
        m.color.copy(g.color);
        b = 0;
        for (f = r.length; b < f; b++) t = r[b], m.vertexColors.push(t.clone());
        m.materialIndex = g.materialIndex + c;
        h.push(m)
      }
      p = 0;
      for (q = a.length; p < q; p++)
        if (c = a[p], d = [], void 0 !== c) {
          b = 0;
          for (f = c.length; b < f; b++) d.push(c[b].clone());
          n.push(d)
        }
    }
  },
  mergeMesh: function(a) {
    !1 === a instanceof THREE.Mesh ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix))
  },
  mergeVertices: function() {
    var a = {},
      b = [],
      c = [],
      d, e = Math.pow(10, 4),
      f, g;
    f = 0;
    for (g = this.vertices.length; f < g; f++) d = this.vertices[f], d = Math.round(d.x * e) + "_" + Math.round(d.y * e) + "_" + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];
    a = [];
    f = 0;
    for (g = this.faces.length; f < g; f++)
      for (e = this.faces[f], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [e.a, e.b, e.c], d = 0; 3 > d; d++)
        if (e[d] == e[(d + 1) % 3]) {
          a.push(f);
          break
        }
    for (f = a.length - 1; 0 <= f; f--)
      for (e = a[f], this.faces.splice(e, 1), c = 0, g = this.faceVertexUvs.length; c < g; c++) this.faceVertexUvs[c].splice(e, 1);
    f = this.vertices.length - b.length;
    this.vertices = b;
    return f
  },
  toJSON: function() {
    function a(a, b, c) {
      return c ? a | 1 << b : a & ~(1 << b)
    }

    function b(a) {
      var b = a.x.toString() + a.y.toString() + a.z.toString();
      if (void 0 !== n[b]) return n[b];
      n[b] = k.length / 3;
      k.push(a.x, a.y, a.z);
      return n[b]
    }

    function c(a) {
      var b = a.r.toString() + a.g.toString() + a.b.toString();
      if (void 0 !== q[b]) return q[b];
      q[b] = p.length;
      p.push(a.getHex());
      return q[b]
    }

    function d(a) {
      var b = a.x.toString() + a.y.toString();
      if (void 0 !== t[b]) return t[b];
      t[b] = m.length / 2;
      m.push(a.x, a.y);
      return t[b]
    }
    var e = {
      metadata: {
        version: 4,
        type: "BufferGeometry",
        generator: "BufferGeometryExporter"
      },
      uuid: this.uuid,
      type: this.type
    };
    "" !== this.name && (e.name = this.name);
    if (void 0 !== this.parameters) {
      var f = this.parameters,
        g;
      for (g in f) void 0 !== f[g] && (e[g] = f[g]);
      return e
    }
    f = [];
    for (g = 0; g < this.vertices.length; g++) {
      var h = this.vertices[g];
      f.push(h.x, h.y, h.z)
    }
    var h = [],
      k = [],
      n = {},
      p = [],
      q = {},
      m = [],
      t = {};
    for (g = 0; g < this.faces.length; g++) {
      var s = this.faces[g],
        r = void 0 !== this.faceVertexUvs[0][g],
        u = 0 < s.normal.length(),
        v = 0 < s.vertexNormals.length,
        y = 1 !== s.color.r || 1 !== s.color.g || 1 !== s.color.b,
        C = 0 < s.vertexColors.length,
        x = 0,
        x = a(x, 0, 0),
        x = a(x, 1, !1),
        x = a(x, 2, !1),
        x = a(x, 3, r),
        x = a(x, 4, u),
        x = a(x, 5, v),
        x = a(x, 6, y),
        x = a(x, 7, C);
      h.push(x);
      h.push(s.a, s.b, s.c);
      r && (r = this.faceVertexUvs[0][g], h.push(d(r[0]), d(r[1]), d(r[2])));
      u && h.push(b(s.normal));
      v && (u = s.vertexNormals, h.push(b(u[0]), b(u[1]), b(u[2])));
      y && h.push(c(s.color));
      C && (s = s.vertexColors, h.push(c(s[0]), c(s[1]), c(s[2])))
    }
    e.data = {};
    e.data.vertices = f;
    e.data.normals = k;
    0 < p.length && (e.data.colors = p);
    0 < m.length && (e.data.uvs = [m]);
    e.data.faces = h;
    return e
  },
  clone: function() {
    for (var a = new THREE.Geometry, b = this.vertices, c = 0, d = b.length; c < d; c++) a.vertices.push(b[c].clone());
    b = this.faces;
    c = 0;
    for (d = b.length; c < d; c++) a.faces.push(b[c].clone());
    c = 0;
    for (d = this.faceVertexUvs.length; c < d; c++) {
      b = this.faceVertexUvs[c];
      void 0 === a.faceVertexUvs[c] && (a.faceVertexUvs[c] = []);
      for (var e = 0, f = b.length; e < f; e++) {
        for (var g = b[e], h = [], k = 0, n = g.length; k < n; k++) h.push(g[k].clone());
        a.faceVertexUvs[c].push(h)
      }
    }
    return a
  },
  dispose: function() {
    this.dispatchEvent({
      type: "dispose"
    })
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.Camera = function() {
  THREE.Object3D.call(this);
  this.type = "Camera";
  this.matrixWorldInverse = new THREE.Matrix4;
  this.projectionMatrix = new THREE.Matrix4
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.constructor = THREE.Camera;
THREE.Camera.prototype.getWorldDirection = function() {
  var a = new THREE.Quaternion;
  return function(b) {
    b = b || new THREE.Vector3;
    this.getWorldQuaternion(a);
    return b.set(0, 0, -1).applyQuaternion(a)
  }
}();
THREE.Camera.prototype.lookAt = function() {
  var a = new THREE.Matrix4;
  return function(b) {
    a.lookAt(this.position, b, this.up);
    this.quaternion.setFromRotationMatrix(a)
  }
}();
THREE.Camera.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Camera);
  THREE.Object3D.prototype.clone.call(this, a);
  a.matrixWorldInverse.copy(this.matrixWorldInverse);
  a.projectionMatrix.copy(this.projectionMatrix);
  return a
};
THREE.CubeCamera = function(a, b, c) {
  THREE.Object3D.call(this);
  this.type = "CubeCamera";
  var d = new THREE.PerspectiveCamera(90, 1, a, b);
  d.up.set(0, -1, 0);
  d.lookAt(new THREE.Vector3(1, 0, 0));
  this.add(d);
  var e = new THREE.PerspectiveCamera(90, 1, a, b);
  e.up.set(0, -1, 0);
  e.lookAt(new THREE.Vector3(-1, 0, 0));
  this.add(e);
  var f = new THREE.PerspectiveCamera(90, 1, a, b);
  f.up.set(0, 0, 1);
  f.lookAt(new THREE.Vector3(0, 1, 0));
  this.add(f);
  var g = new THREE.PerspectiveCamera(90, 1, a, b);
  g.up.set(0, 0, -1);
  g.lookAt(new THREE.Vector3(0, -1, 0));
  this.add(g);
  var h = new THREE.PerspectiveCamera(90, 1, a, b);
  h.up.set(0, -1, 0);
  h.lookAt(new THREE.Vector3(0, 0, 1));
  this.add(h);
  var k = new THREE.PerspectiveCamera(90, 1, a, b);
  k.up.set(0, -1, 0);
  k.lookAt(new THREE.Vector3(0, 0, -1));
  this.add(k);
  this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, {
    format: THREE.RGBFormat,
    magFilter: THREE.LinearFilter,
    minFilter: THREE.LinearFilter
  });
  this.updateCubeMap = function(a, b) {
    var c = this.renderTarget,
      m = c.generateMipmaps;
    c.generateMipmaps = !1;
    c.activeCubeFace = 0;
    a.render(b, d, c);
    c.activeCubeFace = 1;
    a.render(b, e, c);
    c.activeCubeFace = 2;
    a.render(b, f, c);
    c.activeCubeFace = 3;
    a.render(b, g, c);
    c.activeCubeFace = 4;
    a.render(b, h, c);
    c.generateMipmaps = m;
    c.activeCubeFace = 5;
    a.render(b, k, c)
  }
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
THREE.OrthographicCamera = function(a, b, c, d, e, f) {
  THREE.Camera.call(this);
  this.type = "OrthographicCamera";
  this.zoom = 1;
  this.left = a;
  this.right = b;
  this.top = c;
  this.bottom = d;
  this.near = void 0 !== e ? e : .1;
  this.far = void 0 !== f ? f : 2E3;
  this.updateProjectionMatrix()
};
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
  var a = (this.right - this.left) / (2 * this.zoom),
    b = (this.top - this.bottom) / (2 * this.zoom),
    c = (this.right + this.left) / 2,
    d = (this.top + this.bottom) / 2;
  this.projectionMatrix.makeOrthographic(c - a, c + a, d + b, d - b, this.near, this.far)
};
THREE.OrthographicCamera.prototype.clone = function() {
  var a = new THREE.OrthographicCamera;
  THREE.Camera.prototype.clone.call(this, a);
  a.zoom = this.zoom;
  a.left = this.left;
  a.right = this.right;
  a.top = this.top;
  a.bottom = this.bottom;
  a.near = this.near;
  a.far = this.far;
  a.projectionMatrix.copy(this.projectionMatrix);
  return a
};
THREE.PerspectiveCamera = function(a, b, c, d) {
  THREE.Camera.call(this);
  this.type = "PerspectiveCamera";
  this.zoom = 1;
  this.fov = void 0 !== a ? a : 50;
  this.aspect = void 0 !== b ? b : 1;
  this.near = void 0 !== c ? c : .1;
  this.far = void 0 !== d ? d : 2E3;
  this.updateProjectionMatrix()
};
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;
THREE.PerspectiveCamera.prototype.setLens = function(a, b) {
  void 0 === b && (b = 24);
  this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
  this.updateProjectionMatrix()
};
THREE.PerspectiveCamera.prototype.setViewOffset = function(a, b, c, d, e, f) {
  this.fullWidth = a;
  this.fullHeight = b;
  this.x = c;
  this.y = d;
  this.width = e;
  this.height = f;
  this.updateProjectionMatrix()
};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
  var a = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom));
  if (this.fullWidth) {
    var b = this.fullWidth / this.fullHeight,
      a = Math.tan(THREE.Math.degToRad(.5 * a)) * this.near,
      c = -a,
      d = b * c,
      b = Math.abs(b * a - d),
      c = Math.abs(a - c);
    this.projectionMatrix.makeFrustum(d + this.x * b / this.fullWidth, d + (this.x + this.width) * b / this.fullWidth, a - (this.y + this.height) * c / this.fullHeight, a - this.y * c / this.fullHeight, this.near, this.far)
  } else this.projectionMatrix.makePerspective(a, this.aspect, this.near, this.far)
};
THREE.PerspectiveCamera.prototype.clone = function() {
  var a = new THREE.PerspectiveCamera;
  THREE.Camera.prototype.clone.call(this, a);
  a.zoom = this.zoom;
  a.fov = this.fov;
  a.aspect = this.aspect;
  a.near = this.near;
  a.far = this.far;
  a.projectionMatrix.copy(this.projectionMatrix);
  return a
};
THREE.Light = function(a) {
  THREE.Object3D.call(this);
  this.type = "Light";
  this.color = new THREE.Color(a)
};
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.constructor = THREE.Light;
THREE.Light.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Light);
  THREE.Object3D.prototype.clone.call(this, a);
  a.color.copy(this.color);
  return a
};
THREE.AmbientLight = function(a) {
  THREE.Light.call(this, a);
  this.type = "AmbientLight"
};
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;
THREE.AmbientLight.prototype.clone = function() {
  var a = new THREE.AmbientLight;
  THREE.Light.prototype.clone.call(this, a);
  return a
};
THREE.AreaLight = function(a, b) {
  THREE.Light.call(this, a);
  this.type = "AreaLight";
  this.normal = new THREE.Vector3(0, -1, 0);
  this.right = new THREE.Vector3(1, 0, 0);
  this.intensity = void 0 !== b ? b : 1;
  this.height = this.width = 1;
  this.constantAttenuation = 1.5;
  this.linearAttenuation = .5;
  this.quadraticAttenuation = .1
};
THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
THREE.AreaLight.prototype.constructor = THREE.AreaLight;
THREE.DirectionalLight = function(a, b) {
  THREE.Light.call(this, a);
  this.type = "DirectionalLight";
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D;
  this.intensity = void 0 !== b ? b : 1;
  this.onlyShadow = this.castShadow = !1;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5E3;
  this.shadowCameraLeft = -500;
  this.shadowCameraTop = this.shadowCameraRight = 500;
  this.shadowCameraBottom = -500;
  this.shadowCameraVisible = !1;
  this.shadowBias = 0;
  this.shadowDarkness = .5;
  this.shadowMapHeight = this.shadowMapWidth = 512;
  this.shadowCascade = !1;
  this.shadowCascadeOffset = new THREE.Vector3(0, 0, -1E3);
  this.shadowCascadeCount = 2;
  this.shadowCascadeBias = [0, 0, 0];
  this.shadowCascadeWidth = [512, 512, 512];
  this.shadowCascadeHeight = [512, 512, 512];
  this.shadowCascadeNearZ = [-1, .99, .998];
  this.shadowCascadeFarZ = [.99, .998, 1];
  this.shadowCascadeArray = [];
  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
};
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;
THREE.DirectionalLight.prototype.clone = function() {
  var a = new THREE.DirectionalLight;
  THREE.Light.prototype.clone.call(this, a);
  a.target = this.target.clone();
  a.intensity = this.intensity;
  a.castShadow = this.castShadow;
  a.onlyShadow = this.onlyShadow;
  a.shadowCameraNear = this.shadowCameraNear;
  a.shadowCameraFar = this.shadowCameraFar;
  a.shadowCameraLeft = this.shadowCameraLeft;
  a.shadowCameraRight = this.shadowCameraRight;
  a.shadowCameraTop = this.shadowCameraTop;
  a.shadowCameraBottom = this.shadowCameraBottom;
  a.shadowCameraVisible = this.shadowCameraVisible;
  a.shadowBias = this.shadowBias;
  a.shadowDarkness = this.shadowDarkness;
  a.shadowMapWidth = this.shadowMapWidth;
  a.shadowMapHeight = this.shadowMapHeight;
  a.shadowCascade = this.shadowCascade;
  a.shadowCascadeOffset.copy(this.shadowCascadeOffset);
  a.shadowCascadeCount = this.shadowCascadeCount;
  a.shadowCascadeBias = this.shadowCascadeBias.slice(0);
  a.shadowCascadeWidth = this.shadowCascadeWidth.slice(0);
  a.shadowCascadeHeight = this.shadowCascadeHeight.slice(0);
  a.shadowCascadeNearZ = this.shadowCascadeNearZ.slice(0);
  a.shadowCascadeFarZ = this.shadowCascadeFarZ.slice(0);
  return a
};
THREE.HemisphereLight = function(a, b, c) {
  THREE.Light.call(this, a);
  this.type = "HemisphereLight";
  this.position.set(0, 100, 0);
  this.groundColor = new THREE.Color(b);
  this.intensity = void 0 !== c ? c : 1
};
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;
THREE.HemisphereLight.prototype.clone = function() {
  var a = new THREE.HemisphereLight;
  THREE.Light.prototype.clone.call(this, a);
  a.groundColor.copy(this.groundColor);
  a.intensity = this.intensity;
  return a
};
THREE.PointLight = function(a, b, c) {
  THREE.Light.call(this, a);
  this.type = "PointLight";
  this.intensity = void 0 !== b ? b : 1;
  this.distance = void 0 !== c ? c : 0
};
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.constructor = THREE.PointLight;
THREE.PointLight.prototype.clone = function() {
  var a = new THREE.PointLight;
  THREE.Light.prototype.clone.call(this, a);
  a.intensity = this.intensity;
  a.distance = this.distance;
  return a
};
THREE.SpotLight = function(a, b, c, d, e) {
  THREE.Light.call(this, a);
  this.type = "SpotLight";
  this.position.set(0, 1, 0);
  this.target = new THREE.Object3D;
  this.intensity = void 0 !== b ? b : 1;
  this.distance = void 0 !== c ? c : 0;
  this.angle = void 0 !== d ? d : Math.PI / 3;
  this.exponent = void 0 !== e ? e : 10;
  this.onlyShadow = this.castShadow = !1;
  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5E3;
  this.shadowCameraFov = 50;
  this.shadowCameraVisible = !1;
  this.shadowBias = 0;
  this.shadowDarkness = .5;
  this.shadowMapHeight = this.shadowMapWidth = 512;
  this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null
};
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.constructor = THREE.SpotLight;
THREE.SpotLight.prototype.clone = function() {
  var a = new THREE.SpotLight;
  THREE.Light.prototype.clone.call(this, a);
  a.target = this.target.clone();
  a.intensity = this.intensity;
  a.distance = this.distance;
  a.angle = this.angle;
  a.exponent = this.exponent;
  a.castShadow = this.castShadow;
  a.onlyShadow = this.onlyShadow;
  a.shadowCameraNear = this.shadowCameraNear;
  a.shadowCameraFar = this.shadowCameraFar;
  a.shadowCameraFov = this.shadowCameraFov;
  a.shadowCameraVisible = this.shadowCameraVisible;
  a.shadowBias = this.shadowBias;
  a.shadowDarkness = this.shadowDarkness;
  a.shadowMapWidth = this.shadowMapWidth;
  a.shadowMapHeight = this.shadowMapHeight;
  return a
};
THREE.Cache = function() {
  this.files = {}
};
THREE.Cache.prototype = {
  constructor: THREE.Cache,
  add: function(a, b) {
    this.files[a] = b
  },
  get: function(a) {
    return this.files[a]
  },
  remove: function(a) {
    delete this.files[a]
  },
  clear: function() {
    this.files = {}
  }
};
THREE.Loader = function(a) {
  this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null;
  this.imageLoader = new THREE.ImageLoader;
  this.onLoadStart = function() {};
  this.onLoadProgress = function() {};
  this.onLoadComplete = function() {}
};
THREE.Loader.prototype = {
  constructor: THREE.Loader,
  crossOrigin: void 0,
  addStatusElement: function() {
    var a = document.createElement("div");
    a.style.position = "absolute";
    a.style.right = "0px";
    a.style.top = "0px";
    a.style.fontSize = "0.8em";
    a.style.textAlign = "left";
    a.style.background = "rgba(0,0,0,0.25)";
    a.style.color = "#fff";
    a.style.width = "120px";
    a.style.padding = "0.5em 0.5em 0.5em 0.5em";
    a.style.zIndex = 1E3;
    a.innerHTML = "Loading ...";
    return a
  },
  updateProgress: function(a) {
    var b = "Loaded ",
      b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + "%") : b + ((a.loaded / 1024).toFixed(2) + " KB");
    this.statusDomElement.innerHTML = b
  },
  extractUrlBase: function(a) {
    a = a.split("/");
    if (1 === a.length) return "./";
    a.pop();
    return a.join("/") + "/"
  },
  initMaterials: function(a, b) {
    for (var c = [], d = 0; d < a.length; ++d) c[d] = this.createMaterial(a[d], b);
    return c
  },
  needsTangents: function(a) {
    for (var b = 0, c = a.length; b < c; b++)
      if (a[b] instanceof THREE.ShaderMaterial) return !0;
    return !1
  },
  createMaterial: function(a, b) {
    function c(a) {
      a = Math.log(a) / Math.LN2;
      return Math.pow(2, Math.round(a))
    }

    function d(a, d, e, g, h, k, r) {
      var u = b + e,
        v, y = THREE.Loader.Handlers.get(u);
      null !== y ? v = y.load(u) : (v = new THREE.Texture, y = f.imageLoader, y.crossOrigin = f.crossOrigin, y.load(u, function(a) {
        if (!1 === THREE.Math.isPowerOfTwo(a.width) || !1 === THREE.Math.isPowerOfTwo(a.height)) {
          var b = c(a.width),
            d = c(a.height),
            e = document.createElement("canvas");
          e.width = b;
          e.height = d;
          e.getContext("2d").drawImage(a, 0, 0, b, d);
          v.image = e
        } else v.image = a;
        v.needsUpdate = !0
      }));
      v.sourceFile = e;
      g && (v.repeat.set(g[0], g[1]), 1 !== g[0] && (v.wrapS = THREE.RepeatWrapping), 1 !== g[1] && (v.wrapT = THREE.RepeatWrapping));
      h && v.offset.set(h[0], h[1]);
      k && (e = {
        repeat: THREE.RepeatWrapping,
        mirror: THREE.MirroredRepeatWrapping
      }, void 0 !== e[k[0]] && (v.wrapS = e[k[0]]), void 0 !== e[k[1]] && (v.wrapT = e[k[1]]));
      r && (v.anisotropy = r);
      a[d] = v
    }

    function e(a) {
      return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2]
    }
    var f = this,
      g = "MeshLambertMaterial",
      h = {
        color: 15658734,
        opacity: 1,
        map: null,
        lightMap: null,
        normalMap: null,
        bumpMap: null,
        wireframe: !1
      };
    if (a.shading) {
      var k = a.shading.toLowerCase();
      "phong" === k ? g = "MeshPhongMaterial" : "basic" === k && (g = "MeshBasicMaterial")
    }
    void 0 !== a.blending && void 0 !== THREE[a.blending] && (h.blending = THREE[a.blending]);
    if (void 0 !== a.transparent || 1 > a.opacity) h.transparent = a.transparent;
    void 0 !== a.depthTest && (h.depthTest = a.depthTest);
    void 0 !== a.depthWrite && (h.depthWrite = a.depthWrite);
    void 0 !== a.visible && (h.visible = a.visible);
    void 0 !== a.flipSided && (h.side = THREE.BackSide);
    void 0 !== a.doubleSided && (h.side = THREE.DoubleSide);
    void 0 !== a.wireframe && (h.wireframe = a.wireframe);
    void 0 !== a.vertexColors && ("face" === a.vertexColors ? h.vertexColors = THREE.FaceColors : a.vertexColors && (h.vertexColors = THREE.VertexColors));
    a.colorDiffuse ? h.color = e(a.colorDiffuse) : a.DbgColor && (h.color = a.DbgColor);
    a.colorSpecular && (h.specular = e(a.colorSpecular));
    a.colorAmbient && (h.ambient = e(a.colorAmbient));
    a.colorEmissive && (h.emissive = e(a.colorEmissive));
    a.transparency && (h.opacity = a.transparency);
    a.specularCoef && (h.shininess = a.specularCoef);
    a.mapDiffuse && b && d(h, "map", a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
    a.mapLight && b && d(h, "lightMap", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
    a.mapBump && b && d(h, "bumpMap", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
    a.mapNormal && b && d(h, "normalMap", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
    a.mapSpecular && b && d(h, "specularMap", a.mapSpecular, a.mapSpecularRepeat, a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
    a.mapAlpha && b && d(h, "alphaMap", a.mapAlpha, a.mapAlphaRepeat, a.mapAlphaOffset, a.mapAlphaWrap, a.mapAlphaAnisotropy);
    a.mapBumpScale && (h.bumpScale = a.mapBumpScale);
    a.mapNormalFactor && (h.normalScale = new THREE.Vector2(a.mapNormalFactor, a.mapNormalFactor));
    g = new THREE[g](h);
    void 0 !== a.DbgName && (g.name = a.DbgName);
    return g
  }
};
THREE.Loader.Handlers = {
  handlers: [],
  add: function(a, b) {
    this.handlers.push(a, b)
  },
  get: function(a) {
    for (var b = 0, c = this.handlers.length; b < c; b += 2) {
      var d = this.handlers[b + 1];
      if (this.handlers[b].test(a)) return d
    }
    return null
  }
};
THREE.XHRLoader = function(a) {
  this.cache = new THREE.Cache;
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.XHRLoader.prototype = {
  constructor: THREE.XHRLoader,
  load: function(a, b, c, d) {
    var e = this,
      f = e.cache.get(a);
    void 0 !== f ? b && b(f) : (f = new XMLHttpRequest, f.open("GET", a, !0), f.addEventListener("load", function(c) {
      e.cache.add(a, this.response);
      b && b(this.response);
      e.manager.itemEnd(a)
    }, !1), void 0 !== c && f.addEventListener("progress", function(a) {
      c(a)
    }, !1), void 0 !== d && f.addEventListener("error", function(a) {
      d(a)
    }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), void 0 !== this.responseType && (f.responseType = this.responseType), f.send(null), e.manager.itemStart(a))
  },
  setResponseType: function(a) {
    this.responseType = a
  },
  setCrossOrigin: function(a) {
    this.crossOrigin = a
  }
};
THREE.ImageLoader = function(a) {
  this.cache = new THREE.Cache;
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.ImageLoader.prototype = {
  constructor: THREE.ImageLoader,
  load: function(a, b, c, d) {
    var e = this,
      f = e.cache.get(a);
    if (void 0 !== f) b(f);
    else return f = document.createElement("img"), void 0 !== b && f.addEventListener("load", function(c) {
      e.cache.add(a, this);
      b(this);
      e.manager.itemEnd(a)
    }, !1), void 0 !== c && f.addEventListener("progress", function(a) {
      c(a)
    }, !1), void 0 !== d && f.addEventListener("error", function(a) {
      d(a)
    }, !1), void 0 !== this.crossOrigin && (f.crossOrigin = this.crossOrigin), f.src = a, e.manager.itemStart(a), f
  },
  setCrossOrigin: function(a) {
    this.crossOrigin = a
  }
};
THREE.JSONLoader = function(a) {
  THREE.Loader.call(this, a);
  this.withCredentials = !1
};
THREE.JSONLoader.prototype = Object.create(THREE.Loader.prototype);
THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;
THREE.JSONLoader.prototype.load = function(a, b, c) {
  c = c && "string" === typeof c ? c : this.extractUrlBase(a);
  this.onLoadStart();
  this.loadAjaxJSON(this, a, b, c)
};
THREE.JSONLoader.prototype.loadAjaxJSON = function(a, b, c, d, e) {
  var f = new XMLHttpRequest,
    g = 0;
  f.onreadystatechange = function() {
    if (f.readyState === f.DONE)
      if (200 === f.status || 0 === f.status) {
        if (f.responseText) {
          var h = JSON.parse(f.responseText);
          if (void 0 !== h.metadata && "scene" === h.metadata.type) {
            console.error('THREE.JSONLoader: "' + b + '" seems to be a Scene. Use THREE.SceneLoader instead.');
            return
          }
          h = a.parse(h, d);
          c(h.geometry, h.materials)
        } else console.error('THREE.JSONLoader: "' + b + '" seems to be unreachable or the file is empty.');
        a.onLoadComplete()
      } else console.error("THREE.JSONLoader: Couldn't load \"" + b + '" (' + f.status + ")");
    else f.readyState === f.LOADING ? e && (0 === g && (g = f.getResponseHeader("Content-Length")), e({
      total: g,
      loaded: f.responseText.length
    })) : f.readyState === f.HEADERS_RECEIVED && void 0 !== e && (g = f.getResponseHeader("Content-Length"))
  };
  f.open("GET", b, !0);
  f.withCredentials = this.withCredentials;
  f.send(null)
};
THREE.JSONLoader.prototype.parse = function(a, b) {
  var c = new THREE.Geometry,
    d = void 0 !== a.scale ? 1 / a.scale : 1;
  (function(b) {
    var d, g, h, k, n, p, q, m, t, s, r, u, v, y = a.faces;
    p = a.vertices;
    var C = a.normals,
      x = a.colors,
      F = 0;
    if (void 0 !== a.uvs) {
      for (d = 0; d < a.uvs.length; d++) a.uvs[d].length && F++;
      for (d = 0; d < F; d++) c.faceVertexUvs[d] = []
    }
    k = 0;
    for (n = p.length; k < n;) d = new THREE.Vector3, d.x = p[k++] * b, d.y = p[k++] * b, d.z = p[k++] * b, c.vertices.push(d);
    k = 0;
    for (n = y.length; k < n;)
      if (b = y[k++], t = b & 1, h = b & 2, d = b & 8, q = b & 16, s = b & 32, p = b & 64, b &= 128, t) {
        t = new THREE.Face3;
        t.a = y[k];
        t.b = y[k + 1];
        t.c = y[k + 3];
        r = new THREE.Face3;
        r.a = y[k + 1];
        r.b = y[k + 2];
        r.c = y[k + 3];
        k += 4;
        h && (h = y[k++], t.materialIndex = h, r.materialIndex = h);
        h = c.faces.length;
        if (d)
          for (d = 0; d < F; d++)
            for (u = a.uvs[d], c.faceVertexUvs[d][h] = [], c.faceVertexUvs[d][h + 1] = [], g = 0; 4 > g; g++) m = y[k++], v = u[2 * m], m = u[2 * m + 1], v = new THREE.Vector2(v, m), 2 !== g && c.faceVertexUvs[d][h].push(v), 0 !== g && c.faceVertexUvs[d][h + 1].push(v);
        q && (q = 3 * y[k++], t.normal.set(C[q++], C[q++], C[q]), r.normal.copy(t.normal));
        if (s)
          for (d = 0; 4 > d; d++) q = 3 * y[k++], s = new THREE.Vector3(C[q++], C[q++], C[q]), 2 !== d && t.vertexNormals.push(s), 0 !== d && r.vertexNormals.push(s);
        p && (p = y[k++], p = x[p], t.color.setHex(p), r.color.setHex(p));
        if (b)
          for (d = 0; 4 > d; d++) p = y[k++], p = x[p], 2 !== d && t.vertexColors.push(new THREE.Color(p)), 0 !== d && r.vertexColors.push(new THREE.Color(p));
        c.faces.push(t);
        c.faces.push(r)
      } else {
        t = new THREE.Face3;
        t.a = y[k++];
        t.b = y[k++];
        t.c = y[k++];
        h && (h = y[k++], t.materialIndex = h);
        h = c.faces.length;
        if (d)
          for (d = 0; d < F; d++)
            for (u = a.uvs[d], c.faceVertexUvs[d][h] = [], g = 0; 3 > g; g++) m = y[k++], v = u[2 * m], m = u[2 * m + 1], v = new THREE.Vector2(v, m), c.faceVertexUvs[d][h].push(v);
        q && (q = 3 * y[k++], t.normal.set(C[q++], C[q++], C[q]));
        if (s)
          for (d = 0; 3 > d; d++) q = 3 * y[k++], s = new THREE.Vector3(C[q++], C[q++], C[q]), t.vertexNormals.push(s);
        p && (p = y[k++], t.color.setHex(x[p]));
        if (b)
          for (d = 0; 3 > d; d++) p = y[k++], t.vertexColors.push(new THREE.Color(x[p]));
        c.faces.push(t)
      }
  })(d);
  (function() {
    var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
    if (a.skinWeights)
      for (var d = 0, g = a.skinWeights.length; d < g; d += b) c.skinWeights.push(new THREE.Vector4(a.skinWeights[d], 1 < b ? a.skinWeights[d + 1] : 0, 2 < b ? a.skinWeights[d + 2] : 0, 3 < b ? a.skinWeights[d + 3] : 0));
    if (a.skinIndices)
      for (d = 0, g = a.skinIndices.length; d < g; d += b) c.skinIndices.push(new THREE.Vector4(a.skinIndices[d], 1 < b ? a.skinIndices[d + 1] : 0, 2 < b ? a.skinIndices[d + 2] : 0, 3 < b ? a.skinIndices[d + 3] : 0));
    c.bones = a.bones;
    c.bones && 0 < c.bones.length && (c.skinWeights.length !== c.skinIndices.length || c.skinIndices.length !== c.vertices.length) && console.warn("When skinning, number of vertices (" + c.vertices.length + "), skinIndices (" + c.skinIndices.length + "), and skinWeights (" + c.skinWeights.length + ") should match.");
    c.animation = a.animation;
    c.animations = a.animations
  })();
  (function(b) {
    if (void 0 !== a.morphTargets) {
      var d, g, h, k, n, p;
      d = 0;
      for (g = a.morphTargets.length; d < g; d++)
        for (c.morphTargets[d] = {}, c.morphTargets[d].name = a.morphTargets[d].name, c.morphTargets[d].vertices = [], n = c.morphTargets[d].vertices, p = a.morphTargets[d].vertices, h = 0, k = p.length; h < k; h += 3) {
          var q = new THREE.Vector3;
          q.x = p[h] * b;
          q.y = p[h + 1] * b;
          q.z = p[h + 2] * b;
          n.push(q)
        }
    }
    if (void 0 !== a.morphColors)
      for (d = 0, g = a.morphColors.length; d < g; d++)
        for (c.morphColors[d] = {}, c.morphColors[d].name = a.morphColors[d].name, c.morphColors[d].colors = [], k = c.morphColors[d].colors, n = a.morphColors[d].colors, b = 0, h = n.length; b < h; b += 3) p = new THREE.Color(16755200), p.setRGB(n[b], n[b + 1], n[b + 2]), k.push(p)
  })(d);
  c.computeFaceNormals();
  c.computeBoundingSphere();
  if (void 0 === a.materials || 0 === a.materials.length) return {
    geometry: c
  };
  d = this.initMaterials(a.materials, b);
  this.needsTangents(d) && c.computeTangents();
  return {
    geometry: c,
    materials: d
  }
};
THREE.LoadingManager = function(a, b, c) {
  var d = this,
    e = 0,
    f = 0;
  this.onLoad = a;
  this.onProgress = b;
  this.onError = c;
  this.itemStart = function(a) {
    f++
  };
  this.itemEnd = function(a) {
    e++;
    if (void 0 !== d.onProgress) d.onProgress(a, e, f);
    if (e === f && void 0 !== d.onLoad) d.onLoad()
  }
};
THREE.DefaultLoadingManager = new THREE.LoadingManager;
THREE.BufferGeometryLoader = function(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.BufferGeometryLoader.prototype = {
  constructor: THREE.BufferGeometryLoader,
  load: function(a, b, c, d) {
    var e = this,
      f = new THREE.XHRLoader(e.manager);
    f.setCrossOrigin(this.crossOrigin);
    f.load(a, function(a) {
      b(e.parse(JSON.parse(a)))
    }, c, d)
  },
  setCrossOrigin: function(a) {
    this.crossOrigin = a
  },
  parse: function(a) {
    var b = new THREE.BufferGeometry,
      c = a.attributes,
      d;
    for (d in c) {
      var e = c[d],
        f = new self[e.type](e.array);
      b.addAttribute(d, new THREE.BufferAttribute(f, e.itemSize))
    }
    c = a.offsets;
    void 0 !== c && (b.offsets = JSON.parse(JSON.stringify(c)));
    a = a.boundingSphere;
    void 0 !== a && (c = new THREE.Vector3, void 0 !== a.center && c.fromArray(a.center), b.boundingSphere = new THREE.Sphere(c, a.radius));
    return b
  }
};
THREE.MaterialLoader = function(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.MaterialLoader.prototype = {
  constructor: THREE.MaterialLoader,
  load: function(a, b, c, d) {
    var e = this,
      f = new THREE.XHRLoader(e.manager);
    f.setCrossOrigin(this.crossOrigin);
    f.load(a, function(a) {
      b(e.parse(JSON.parse(a)))
    }, c, d)
  },
  setCrossOrigin: function(a) {
    this.crossOrigin = a
  },
  parse: function(a) {
    var b = new THREE[a.type];
    void 0 !== a.color && b.color.setHex(a.color);
    void 0 !== a.ambient && b.ambient.setHex(a.ambient);
    void 0 !== a.emissive && b.emissive.setHex(a.emissive);
    void 0 !== a.specular && b.specular.setHex(a.specular);
    void 0 !== a.shininess && (b.shininess = a.shininess);
    void 0 !== a.uniforms && (b.uniforms = a.uniforms);
    void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader);
    void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader);
    void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
    void 0 !== a.shading && (b.shading = a.shading);
    void 0 !== a.blending && (b.blending = a.blending);
    void 0 !== a.side && (b.side = a.side);
    void 0 !== a.opacity && (b.opacity = a.opacity);
    void 0 !== a.transparent && (b.transparent = a.transparent);
    void 0 !== a.wireframe && (b.wireframe = a.wireframe);
    if (void 0 !== a.materials)
      for (var c = 0, d = a.materials.length; c < d; c++) b.materials.push(this.parse(a.materials[c]));
    return b
  }
};
THREE.ObjectLoader = function(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.ObjectLoader.prototype = {
  constructor: THREE.ObjectLoader,
  load: function(a, b, c, d) {
    var e = this,
      f = new THREE.XHRLoader(e.manager);
    f.setCrossOrigin(this.crossOrigin);
    f.load(a, function(a) {
      b(e.parse(JSON.parse(a)))
    }, c, d)
  },
  setCrossOrigin: function(a) {
    this.crossOrigin = a
  },
  parse: function(a) {
    var b = this.parseGeometries(a.geometries),
      c = this.parseMaterials(a.materials);
    return this.parseObject(a.object, b, c)
  },
  parseGeometries: function(a) {
    var b = {};
    if (void 0 !== a)
      for (var c = new THREE.JSONLoader, d = new THREE.BufferGeometryLoader, e = 0, f = a.length; e < f; e++) {
        var g, h = a[e];
        switch (h.type) {
          case "PlaneGeometry":
            g = new THREE.PlaneGeometry(h.width, h.height, h.widthSegments, h.heightSegments);
            break;
          case "BoxGeometry":
          case "CubeGeometry":
            g = new THREE.BoxGeometry(h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
            break;
          case "CircleGeometry":
            g = new THREE.CircleGeometry(h.radius, h.segments);
            break;
          case "CylinderGeometry":
            g = new THREE.CylinderGeometry(h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded);
            break;
          case "SphereGeometry":
            g = new THREE.SphereGeometry(h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
            break;
          case "IcosahedronGeometry":
            g = new THREE.IcosahedronGeometry(h.radius, h.detail);
            break;
          case "TorusGeometry":
            g = new THREE.TorusGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
            break;
          case "TorusKnotGeometry":
            g = new THREE.TorusKnotGeometry(h.radius, h.tube, h.radialSegments, h.tubularSegments, h.p, h.q, h.heightScale);
            break;
          case "BufferGeometry":
            g = d.parse(h.data);
            break;
          case "Geometry":
            g = c.parse(h.data).geometry
        }
        g.uuid = h.uuid;
        void 0 !== h.name && (g.name = h.name);
        b[h.uuid] = g
      }
    return b
  },
  parseMaterials: function(a) {
    var b = {};
    if (void 0 !== a)
      for (var c = new THREE.MaterialLoader, d = 0, e = a.length; d < e; d++) {
        var f = a[d],
          g = c.parse(f);
        g.uuid = f.uuid;
        void 0 !== f.name && (g.name = f.name);
        b[f.uuid] = g
      }
    return b
  },
  parseObject: function() {
    var a = new THREE.Matrix4;
    return function(b, c, d) {
      var e;
      switch (b.type) {
        case "Scene":
          e = new THREE.Scene;
          break;
        case "PerspectiveCamera":
          e = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
          break;
        case "OrthographicCamera":
          e = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
          break;
        case "AmbientLight":
          e = new THREE.AmbientLight(b.color);
          break;
        case "DirectionalLight":
          e = new THREE.DirectionalLight(b.color, b.intensity);
          break;
        case "PointLight":
          e = new THREE.PointLight(b.color, b.intensity, b.distance);
          break;
        case "SpotLight":
          e = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.exponent);
          break;
        case "HemisphereLight":
          e = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
          break;
        case "Mesh":
          e = c[b.geometry];
          var f = d[b.material];
          void 0 === e && console.warn("THREE.ObjectLoader: Undefined geometry", b.geometry);
          void 0 === f && console.warn("THREE.ObjectLoader: Undefined material", b.material);
          e = new THREE.Mesh(e, f);
          break;
        case "Line":
          e = c[b.geometry];
          f = d[b.material];
          void 0 === e && console.warn("THREE.ObjectLoader: Undefined geometry", b.geometry);
          void 0 === f && console.warn("THREE.ObjectLoader: Undefined material", b.material);
          e = new THREE.Line(e, f);
          break;
        case "Sprite":
          f = d[b.material];
          void 0 === f && console.warn("THREE.ObjectLoader: Undefined material", b.material);
          e = new THREE.Sprite(f);
          break;
        case "Group":
          e = new THREE.Group;
          break;
        default:
          e = new THREE.Object3D
      }
      e.uuid = b.uuid;
      void 0 !== b.name && (e.name = b.name);
      void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(e.position, e.quaternion, e.scale)) : (void 0 !== b.position && e.position.fromArray(b.position), void 0 !== b.rotation && e.rotation.fromArray(b.rotation), void 0 !== b.scale && e.scale.fromArray(b.scale));
      void 0 !== b.visible && (e.visible = b.visible);
      void 0 !== b.userData && (e.userData = b.userData);
      if (void 0 !== b.children)
        for (var g in b.children) e.add(this.parseObject(b.children[g], c, d));
      return e
    }
  }()
};
THREE.TextureLoader = function(a) {
  this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.TextureLoader.prototype = {
  constructor: THREE.TextureLoader,
  load: function(a, b, c, d) {
    var e = new THREE.ImageLoader(this.manager);
    e.setCrossOrigin(this.crossOrigin);
    e.load(a, function(a) {
      a = new THREE.Texture(a);
      a.needsUpdate = !0;
      void 0 !== b && b(a)
    }, c, d)
  },
  setCrossOrigin: function(a) {
    this.crossOrigin = a
  }
};
THREE.DataTextureLoader = THREE.BinaryTextureLoader = function() {
  this._parser = null
};
THREE.BinaryTextureLoader.prototype = {
  constructor: THREE.BinaryTextureLoader,
  load: function(a, b, c, d) {
    var e = this,
      f = new THREE.DataTexture,
      g = new THREE.XHRLoader;
    g.setResponseType("arraybuffer");
    g.load(a, function(a) {
      if (a = e._parser(a)) void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : THREE.ClampToEdgeWrapping, f.wrapT = void 0 !== a.wrapT ? a.wrapT : THREE.ClampToEdgeWrapping, f.magFilter = void 0 !== a.magFilter ? a.magFilter : THREE.LinearFilter, f.minFilter = void 0 !== a.minFilter ? a.minFilter : THREE.LinearMipMapLinearFilter, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.needsUpdate = !0, b && b(f, a)
    }, c, d);
    return f
  }
};
THREE.CompressedTextureLoader = function() {
  this._parser = null
};
THREE.CompressedTextureLoader.prototype = {
  constructor: THREE.CompressedTextureLoader,
  load: function(a, b, c) {
    var d = this,
      e = [],
      f = new THREE.CompressedTexture;
    f.image = e;
    var g = new THREE.XHRLoader;
    g.setResponseType("arraybuffer");
    if (a instanceof Array) {
      var h = 0;
      c = function(c) {
        g.load(a[c], function(a) {
          a = d._parser(a, !0);
          e[c] = {
            width: a.width,
            height: a.height,
            format: a.format,
            mipmaps: a.mipmaps
          };
          h += 1;
          6 === h && (1 == a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.format = a.format, f.needsUpdate = !0, b && b(f))
        })
      };
      for (var k = 0, n = a.length; k < n; ++k) c(k)
    } else g.load(a, function(a) {
      a = d._parser(a, !0);
      if (a.isCubemap)
        for (var c = a.mipmaps.length / a.mipmapCount, g = 0; g < c; g++) {
          e[g] = {
            mipmaps: []
          };
          for (var h = 0; h < a.mipmapCount; h++) e[g].mipmaps.push(a.mipmaps[g * a.mipmapCount + h]), e[g].format = a.format, e[g].width = a.width, e[g].height = a.height
        } else f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
      1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter);
      f.format = a.format;
      f.needsUpdate = !0;
      b && b(f)
    });
    return f
  }
};
THREE.Material = function() {
  Object.defineProperty(this, "id", {
    value: THREE.MaterialIdCount++
  });
  this.uuid = THREE.Math.generateUUID();
  this.name = "";
  this.type = "Material";
  this.side = THREE.FrontSide;
  this.opacity = 1;
  this.transparent = !1;
  this.blending = THREE.NormalBlending;
  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.depthWrite = this.depthTest = !0;
  this.polygonOffset = !1;
  this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
  this.needsUpdate = this.visible = !0
};
THREE.Material.prototype = {
  constructor: THREE.Material,
  setValues: function(a) {
    if (void 0 !== a)
      for (var b in a) {
        var c = a[b];
        if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
        else if (b in this) {
          var d = this[b];
          d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) : this[b] = "overdraw" == b ? Number(c) : c
        }
      }
  },
  toJSON: function() {
    var a = {
      metadata: {
        version: 4.2,
        type: "material",
        generator: "MaterialExporter"
      },
      uuid: this.uuid,
      type: this.type
    };
    "" !== this.name && (a.name = this.name);
    this instanceof THREE.MeshBasicMaterial ? (a.color = this.color.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshLambertMaterial ? (a.color = this.color.getHex(), a.ambient = this.ambient.getHex(), a.emissive = this.emissive.getHex(), this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshPhongMaterial ? (a.color = this.color.getHex(), a.ambient = this.ambient.getHex(), a.emissive = this.emissive.getHex(), a.specular = this.specular.getHex(), a.shininess = this.shininess, this.vertexColors !== THREE.NoColors && (a.vertexColors = this.vertexColors), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshNormalMaterial ? (this.shading !== THREE.FlatShading && (a.shading = this.shading), this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.MeshDepthMaterial ? (this.blending !== THREE.NormalBlending && (a.blending = this.blending), this.side !== THREE.FrontSide && (a.side = this.side)) : this instanceof THREE.ShaderMaterial ? (a.uniforms = this.uniforms, a.vertexShader = this.vertexShader, a.fragmentShader = this.fragmentShader) : this instanceof THREE.SpriteMaterial && (a.color = this.color.getHex());
    1 > this.opacity && (a.opacity = this.opacity);
    !1 !== this.transparent && (a.transparent = this.transparent);
    !1 !== this.wireframe && (a.wireframe = this.wireframe);
    return a
  },
  clone: function(a) {
    void 0 === a && (a = new THREE.Material);
    a.name = this.name;
    a.side = this.side;
    a.opacity = this.opacity;
    a.transparent = this.transparent;
    a.blending = this.blending;
    a.blendSrc = this.blendSrc;
    a.blendDst = this.blendDst;
    a.blendEquation = this.blendEquation;
    a.depthTest = this.depthTest;
    a.depthWrite = this.depthWrite;
    a.polygonOffset = this.polygonOffset;
    a.polygonOffsetFactor = this.polygonOffsetFactor;
    a.polygonOffsetUnits = this.polygonOffsetUnits;
    a.alphaTest = this.alphaTest;
    a.overdraw = this.overdraw;
    a.visible = this.visible;
    return a
  },
  dispose: function() {
    this.dispatchEvent({
      type: "dispose"
    })
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function(a) {
  THREE.Material.call(this);
  this.type = "LineBasicMaterial";
  this.color = new THREE.Color(16777215);
  this.linewidth = 1;
  this.linejoin = this.linecap = "round";
  this.vertexColors = THREE.NoColors;
  this.fog = !0;
  this.setValues(a)
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
THREE.LineBasicMaterial.prototype.clone = function() {
  var a = new THREE.LineBasicMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.linewidth = this.linewidth;
  a.linecap = this.linecap;
  a.linejoin = this.linejoin;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a
};
THREE.LineDashedMaterial = function(a) {
  THREE.Material.call(this);
  this.type = "LineDashedMaterial";
  this.color = new THREE.Color(16777215);
  this.scale = this.linewidth = 1;
  this.dashSize = 3;
  this.gapSize = 1;
  this.vertexColors = !1;
  this.fog = !0;
  this.setValues(a)
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
THREE.LineDashedMaterial.prototype.clone = function() {
  var a = new THREE.LineDashedMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.linewidth = this.linewidth;
  a.scale = this.scale;
  a.dashSize = this.dashSize;
  a.gapSize = this.gapSize;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a
};
THREE.MeshBasicMaterial = function(a) {
  THREE.Material.call(this);
  this.type = "MeshBasicMaterial";
  this.color = new THREE.Color(16777215);
  this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = .98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = "round";
  this.vertexColors = THREE.NoColors;
  this.morphTargets = this.skinning = !1;
  this.setValues(a)
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
THREE.MeshBasicMaterial.prototype.clone = function() {
  var a = new THREE.MeshBasicMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.specularMap = this.specularMap;
  a.alphaMap = this.alphaMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  return a
};
THREE.MeshLambertMaterial = function(a) {
  THREE.Material.call(this);
  this.type = "MeshLambertMaterial";
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.wrapAround = !1;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.envMap = this.alphaMap = this.specularMap = this.lightMap = this.map = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = .98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = "round";
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.setValues(a)
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
THREE.MeshLambertMaterial.prototype.clone = function() {
  var a = new THREE.MeshLambertMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.ambient.copy(this.ambient);
  a.emissive.copy(this.emissive);
  a.wrapAround = this.wrapAround;
  a.wrapRGB.copy(this.wrapRGB);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.specularMap = this.specularMap;
  a.alphaMap = this.alphaMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a
};
THREE.MeshPhongMaterial = function(a) {
  THREE.Material.call(this);
  this.type = "MeshPhongMaterial";
  this.color = new THREE.Color(16777215);
  this.ambient = new THREE.Color(16777215);
  this.emissive = new THREE.Color(0);
  this.specular = new THREE.Color(1118481);
  this.shininess = 30;
  this.wrapAround = this.metal = !1;
  this.wrapRGB = new THREE.Vector3(1, 1, 1);
  this.bumpMap = this.lightMap = this.map = null;
  this.bumpScale = 1;
  this.normalMap = null;
  this.normalScale = new THREE.Vector2(1, 1);
  this.envMap = this.alphaMap = this.specularMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = .98;
  this.fog = !0;
  this.shading = THREE.SmoothShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.wireframeLinejoin = this.wireframeLinecap = "round";
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.setValues(a)
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
THREE.MeshPhongMaterial.prototype.clone = function() {
  var a = new THREE.MeshPhongMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.ambient.copy(this.ambient);
  a.emissive.copy(this.emissive);
  a.specular.copy(this.specular);
  a.shininess = this.shininess;
  a.metal = this.metal;
  a.wrapAround = this.wrapAround;
  a.wrapRGB.copy(this.wrapRGB);
  a.map = this.map;
  a.lightMap = this.lightMap;
  a.bumpMap = this.bumpMap;
  a.bumpScale = this.bumpScale;
  a.normalMap = this.normalMap;
  a.normalScale.copy(this.normalScale);
  a.specularMap = this.specularMap;
  a.alphaMap = this.alphaMap;
  a.envMap = this.envMap;
  a.combine = this.combine;
  a.reflectivity = this.reflectivity;
  a.refractionRatio = this.refractionRatio;
  a.fog = this.fog;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.wireframeLinecap = this.wireframeLinecap;
  a.wireframeLinejoin = this.wireframeLinejoin;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a
};
THREE.MeshDepthMaterial = function(a) {
  THREE.Material.call(this);
  this.type = "MeshDepthMaterial";
  this.wireframe = this.morphTargets = !1;
  this.wireframeLinewidth = 1;
  this.setValues(a)
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
THREE.MeshDepthMaterial.prototype.clone = function() {
  var a = new THREE.MeshDepthMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  return a
};
THREE.MeshNormalMaterial = function(a) {
  THREE.Material.call(this, a);
  this.type = "MeshNormalMaterial";
  this.shading = THREE.FlatShading;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.morphTargets = !1;
  this.setValues(a)
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
THREE.MeshNormalMaterial.prototype.clone = function() {
  var a = new THREE.MeshNormalMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  return a
};
THREE.MeshFaceMaterial = function(a) {
  this.uuid = THREE.Math.generateUUID();
  this.type = "MeshFaceMaterial";
  this.materials = a instanceof Array ? a : []
};
THREE.MeshFaceMaterial.prototype = {
  constructor: THREE.MeshFaceMaterial,
  toJSON: function() {
    for (var a = {
        metadata: {
          version: 4.2,
          type: "material",
          generator: "MaterialExporter"
        },
        uuid: this.uuid,
        type: this.type,
        materials: []
      }, b = 0, c = this.materials.length; b < c; b++) a.materials.push(this.materials[b].toJSON());
    return a
  },
  clone: function() {
    for (var a = new THREE.MeshFaceMaterial, b = 0; b < this.materials.length; b++) a.materials.push(this.materials[b].clone());
    return a
  }
};
THREE.PointCloudMaterial = function(a) {
  THREE.Material.call(this);
  this.type = "PointCloudMaterial";
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.size = 1;
  this.sizeAttenuation = !0;
  this.vertexColors = THREE.NoColors;
  this.fog = !0;
  this.setValues(a)
};
THREE.PointCloudMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;
THREE.PointCloudMaterial.prototype.clone = function() {
  var a = new THREE.PointCloudMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.size = this.size;
  a.sizeAttenuation = this.sizeAttenuation;
  a.vertexColors = this.vertexColors;
  a.fog = this.fog;
  return a
};
THREE.ParticleBasicMaterial = function(a) {
  console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.");
  return new THREE.PointCloudMaterial(a)
};
THREE.ParticleSystemMaterial = function(a) {
  console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.");
  return new THREE.PointCloudMaterial(a)
};
THREE.ShaderMaterial = function(a) {
  THREE.Material.call(this);
  this.type = "ShaderMaterial";
  this.defines = {};
  this.uniforms = {};
  this.attributes = null;
  this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  this.shading = THREE.SmoothShading;
  this.linewidth = 1;
  this.wireframe = !1;
  this.wireframeLinewidth = 1;
  this.lights = this.fog = !1;
  this.vertexColors = THREE.NoColors;
  this.morphNormals = this.morphTargets = this.skinning = !1;
  this.defaultAttributeValues = {
    color: [1, 1, 1],
    uv: [0, 0],
    uv2: [0, 0]
  };
  this.index0AttributeName = void 0;
  this.setValues(a)
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
THREE.ShaderMaterial.prototype.clone = function() {
  var a = new THREE.ShaderMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.fragmentShader = this.fragmentShader;
  a.vertexShader = this.vertexShader;
  a.uniforms = THREE.UniformsUtils.clone(this.uniforms);
  a.attributes = this.attributes;
  a.defines = this.defines;
  a.shading = this.shading;
  a.wireframe = this.wireframe;
  a.wireframeLinewidth = this.wireframeLinewidth;
  a.fog = this.fog;
  a.lights = this.lights;
  a.vertexColors = this.vertexColors;
  a.skinning = this.skinning;
  a.morphTargets = this.morphTargets;
  a.morphNormals = this.morphNormals;
  return a
};
THREE.RawShaderMaterial = function(a) {
  THREE.ShaderMaterial.call(this, a);
  this.type = "RawShaderMaterial"
};
THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
THREE.RawShaderMaterial.prototype.clone = function() {
  var a = new THREE.RawShaderMaterial;
  THREE.ShaderMaterial.prototype.clone.call(this, a);
  return a
};
THREE.SpriteMaterial = function(a) {
  THREE.Material.call(this);
  this.type = "SpriteMaterial";
  this.color = new THREE.Color(16777215);
  this.map = null;
  this.rotation = 0;
  this.fog = !1;
  this.setValues(a)
};
THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
THREE.SpriteMaterial.prototype.clone = function() {
  var a = new THREE.SpriteMaterial;
  THREE.Material.prototype.clone.call(this, a);
  a.color.copy(this.color);
  a.map = this.map;
  a.rotation = this.rotation;
  a.fog = this.fog;
  return a
};
THREE.Texture = function(a, b, c, d, e, f, g, h, k) {
  Object.defineProperty(this, "id", {
    value: THREE.TextureIdCount++
  });
  this.uuid = THREE.Math.generateUUID();
  this.name = "";
  this.image = void 0 !== a ? a : THREE.Texture.DEFAULT_IMAGE;
  this.mipmaps = [];
  this.mapping = void 0 !== b ? b : THREE.Texture.DEFAULT_MAPPING;
  this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
  this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;
  this.magFilter = void 0 !== e ? e : THREE.LinearFilter;
  this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;
  this.anisotropy = void 0 !== k ? k : 1;
  this.format = void 0 !== g ? g : THREE.RGBAFormat;
  this.type = void 0 !== h ? h : THREE.UnsignedByteType;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.generateMipmaps = !0;
  this.premultiplyAlpha = !1;
  this.flipY = !0;
  this.unpackAlignment = 4;
  this._needsUpdate = !1;
  this.onUpdate = null
};
THREE.Texture.DEFAULT_IMAGE = void 0;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
THREE.Texture.prototype = {
  constructor: THREE.Texture,
  get needsUpdate() {
    return this._needsUpdate
  },
  set needsUpdate(a) {
    !0 === a && this.update();
    this._needsUpdate = a
  },
  clone: function(a) {
    void 0 === a && (a = new THREE.Texture);
    a.image = this.image;
    a.mipmaps = this.mipmaps.slice(0);
    a.mapping = this.mapping;
    a.wrapS = this.wrapS;
    a.wrapT = this.wrapT;
    a.magFilter = this.magFilter;
    a.minFilter = this.minFilter;
    a.anisotropy = this.anisotropy;
    a.format = this.format;
    a.type = this.type;
    a.offset.copy(this.offset);
    a.repeat.copy(this.repeat);
    a.generateMipmaps = this.generateMipmaps;
    a.premultiplyAlpha = this.premultiplyAlpha;
    a.flipY = this.flipY;
    a.unpackAlignment = this.unpackAlignment;
    return a
  },
  update: function() {
    this.dispatchEvent({
      type: "update"
    })
  },
  dispose: function() {
    this.dispatchEvent({
      type: "dispose"
    })
  }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.CubeTexture = function(a, b, c, d, e, f, g, h, k) {
  b = void 0 !== b ? b : THREE.CubeReflectionMapping;
  THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);
  this.images = a
};
THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
THREE.CubeTexture.clone = function(a) {
  void 0 === a && (a = new THREE.CubeTexture);
  THREE.Texture.prototype.clone.call(this, a);
  a.images = this.images;
  return a
};
THREE.CompressedTexture = function(a, b, c, d, e, f, g, h, k, n, p) {
  THREE.Texture.call(this, null, f, g, h, k, n, d, e, p);
  this.image = {
    width: b,
    height: c
  };
  this.mipmaps = a;
  this.generateMipmaps = this.flipY = !1
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
THREE.CompressedTexture.prototype.clone = function() {
  var a = new THREE.CompressedTexture;
  THREE.Texture.prototype.clone.call(this, a);
  return a
};
THREE.DataTexture = function(a, b, c, d, e, f, g, h, k, n, p) {
  THREE.Texture.call(this, null, f, g, h, k, n, d, e, p);
  this.image = {
    data: a,
    width: b,
    height: c
  }
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.constructor = THREE.DataTexture;
THREE.DataTexture.prototype.clone = function() {
  var a = new THREE.DataTexture;
  THREE.Texture.prototype.clone.call(this, a);
  return a
};
THREE.VideoTexture = function(a, b, c, d, e, f, g, h, k) {
  THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);
  this.generateMipmaps = !1;
  var n = this,
    p = function() {
      requestAnimationFrame(p);
      a.readyState === a.HAVE_ENOUGH_DATA && (n.needsUpdate = !0)
    };
  p()
};
THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
THREE.Group = function() {
  THREE.Object3D.call(this);
  this.type = "Group"
};
THREE.Group.prototype = Object.create(THREE.Object3D.prototype);
THREE.Group.prototype.constructor = THREE.Group;
THREE.PointCloud = function(a, b) {
  THREE.Object3D.call(this);
  this.type = "PointCloud";
  this.geometry = void 0 !== a ? a : new THREE.Geometry;
  this.material = void 0 !== b ? b : new THREE.PointCloudMaterial({
    color: 16777215 * Math.random()
  })
};
THREE.PointCloud.prototype = Object.create(THREE.Object3D.prototype);
THREE.PointCloud.prototype.constructor = THREE.PointCloud;
THREE.PointCloud.prototype.raycast = function() {
  var a = new THREE.Matrix4,
    b = new THREE.Ray;
  return function(c, d) {
    var e = this,
      f = e.geometry,
      g = c.params.PointCloud.threshold;
    a.getInverse(this.matrixWorld);
    b.copy(c.ray).applyMatrix4(a);
    if (null === f.boundingBox || !1 !== b.isIntersectionBox(f.boundingBox)) {
      var h = g / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        k = new THREE.Vector3,
        g = function(a, f) {
          var g = b.distanceToPoint(a);
          if (g < h) {
            var k = b.closestPointToPoint(a);
            k.applyMatrix4(e.matrixWorld);
            var m = c.ray.origin.distanceTo(k);
            d.push({
              distance: m,
              distanceToRay: g,
              point: k.clone(),
              index: f,
              face: null,
              object: e
            })
          }
        };
      if (f instanceof THREE.BufferGeometry) {
        var n = f.attributes,
          p = n.position.array;
        if (void 0 !== n.index) {
          var n = n.index.array,
            q = f.offsets;
          0 === q.length && (q = [{
            start: 0,
            count: n.length,
            index: 0
          }]);
          for (var m = 0, t = q.length; m < t; ++m)
            for (var s = q[m].start, r = q[m].index, f = s, s = s + q[m].count; f < s; f++) {
              var u = r + n[f];
              k.fromArray(p, 3 * u);
              g(k, u)
            }
        } else
          for (n = p.length / 3, f = 0; f < n; f++) k.set(p[3 * f], p[3 * f + 1], p[3 * f + 2]), g(k, f)
      } else
        for (k = this.geometry.vertices, f = 0; f < k.length; f++) g(k[f], f)
    }
  }
}();
THREE.PointCloud.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.PointCloud(this.geometry, this.material));
  THREE.Object3D.prototype.clone.call(this, a);
  return a
};
THREE.ParticleSystem = function(a, b) {
  console.warn("THREE.ParticleSystem has been renamed to THREE.PointCloud.");
  return new THREE.PointCloud(a, b)
};
THREE.Line = function(a, b, c) {
  THREE.Object3D.call(this);
  this.type = "Line";
  this.geometry = void 0 !== a ? a : new THREE.Geometry;
  this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({
    color: 16777215 * Math.random()
  });
  this.mode = void 0 !== c ? c : THREE.LineStrip
};
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.constructor = THREE.Line;
THREE.Line.prototype.raycast = function() {
  var a = new THREE.Matrix4,
    b = new THREE.Ray,
    c = new THREE.Sphere;
  return function(d, e) {
    var f = d.linePrecision,
      f = f * f,
      g = this.geometry;
    null === g.boundingSphere && g.computeBoundingSphere();
    c.copy(g.boundingSphere);
    c.applyMatrix4(this.matrixWorld);
    if (!1 !== d.ray.isIntersectionSphere(c)) {
      a.getInverse(this.matrixWorld);
      b.copy(d.ray).applyMatrix4(a);
      var h = new THREE.Vector3,
        k = new THREE.Vector3,
        n = new THREE.Vector3,
        p = new THREE.Vector3,
        q = this.mode === THREE.LineStrip ? 1 : 2;
      if (g instanceof THREE.BufferGeometry) {
        var m = g.attributes;
        if (void 0 !== m.index) {
          var t = m.index.array,
            m = m.position.array,
            s = g.offsets;
          0 === s.length && (s = [{
            start: 0,
            count: t.length,
            index: 0
          }]);
          for (var r = 0; r < s.length; r++)
            for (var u = s[r].start, v = s[r].count, y = s[r].index, g = u; g < u + v - 1; g += q) {
              var C = y + t[g + 1];
              h.fromArray(m, 3 * (y + t[g]));
              k.fromArray(m, 3 * C);
              C = b.distanceSqToSegment(h, k, p, n);
              C > f || (C = b.origin.distanceTo(p), C < d.near || C > d.far || e.push({
                distance: C,
                point: n.clone().applyMatrix4(this.matrixWorld),
                face: null,
                faceIndex: null,
                object: this
              }))
            }
        } else
          for (m = m.position.array, g = 0; g < m.length / 3 - 1; g += q) h.fromArray(m, 3 * g), k.fromArray(m, 3 * g + 3), C = b.distanceSqToSegment(h, k, p, n), C > f || (C = b.origin.distanceTo(p), C < d.near || C > d.far || e.push({
            distance: C,
            point: n.clone().applyMatrix4(this.matrixWorld),
            face: null,
            faceIndex: null,
            object: this
          }))
      } else if (g instanceof THREE.Geometry)
        for (h = g.vertices, k = h.length, g = 0; g < k - 1; g += q) C = b.distanceSqToSegment(h[g], h[g + 1], p, n), C > f || (C = b.origin.distanceTo(p), C < d.near || C > d.far || e.push({
          distance: C,
          point: n.clone().applyMatrix4(this.matrixWorld),
          face: null,
          faceIndex: null,
          object: this
        }))
    }
  }
}();
THREE.Line.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Line(this.geometry, this.material, this.mode));
  THREE.Object3D.prototype.clone.call(this, a);
  return a
};
THREE.Mesh = function(a, b) {
  THREE.Object3D.call(this);
  this.type = "Mesh";
  this.geometry = void 0 !== a ? a : new THREE.Geometry;
  this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({
    color: 16777215 * Math.random()
  });
  this.updateMorphTargets()
};
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.constructor = THREE.Mesh;
THREE.Mesh.prototype.updateMorphTargets = function() {
  if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
    this.morphTargetBase = -1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};
    for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a
  }
};
THREE.Mesh.prototype.getMorphTargetIndexByName = function(a) {
  if (void 0 !== this.morphTargetDictionary[a]) return this.morphTargetDictionary[a];
  console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0.");
  return 0
};
THREE.Mesh.prototype.raycast = function() {
  var a = new THREE.Matrix4,
    b = new THREE.Ray,
    c = new THREE.Sphere,
    d = new THREE.Vector3,
    e = new THREE.Vector3,
    f = new THREE.Vector3;
  return function(g, h) {
    var k = this.geometry;
    null === k.boundingSphere && k.computeBoundingSphere();
    c.copy(k.boundingSphere);
    c.applyMatrix4(this.matrixWorld);
    if (!1 !== g.ray.isIntersectionSphere(c) && (a.getInverse(this.matrixWorld), b.copy(g.ray).applyMatrix4(a), null === k.boundingBox || !1 !== b.isIntersectionBox(k.boundingBox)))
      if (k instanceof THREE.BufferGeometry) {
        var n = this.material;
        if (void 0 !== n) {
          var p = k.attributes,
            q, m, t = g.precision;
          if (void 0 !== p.index) {
            var s = p.index.array,
              r = p.position.array,
              u = k.offsets;
            0 === u.length && (u = [{
              start: 0,
              count: s.length,
              index: 0
            }]);
            for (var v = 0, y = u.length; v < y; ++v)
              for (var p = u[v].start, C = u[v].index, k = p, x = p + u[v].count; k < x; k += 3) {
                p = C + s[k];
                q = C + s[k + 1];
                m = C + s[k + 2];
                d.fromArray(r, 3 * p);
                e.fromArray(r, 3 * q);
                f.fromArray(r, 3 * m);
                var F = n.side === THREE.BackSide ? b.intersectTriangle(f, e, d, !0) : b.intersectTriangle(d, e, f, n.side !== THREE.DoubleSide);
                if (null !== F) {
                  F.applyMatrix4(this.matrixWorld);
                  var z = g.ray.origin.distanceTo(F);
                  z < t || z < g.near || z > g.far || h.push({
                    distance: z,
                    point: F,
                    face: new THREE.Face3(p, q, m, THREE.Triangle.normal(d, e, f)),
                    faceIndex: null,
                    object: this
                  })
                }
              }
          } else
            for (r = p.position.array, s = k = 0, x = r.length; k < x; k += 3, s += 9) p = k, q = k + 1, m = k + 2, d.fromArray(r, s), e.fromArray(r, s + 3), f.fromArray(r, s + 6), F = n.side === THREE.BackSide ? b.intersectTriangle(f, e, d, !0) : b.intersectTriangle(d, e, f, n.side !== THREE.DoubleSide), null !== F && (F.applyMatrix4(this.matrixWorld), z = g.ray.origin.distanceTo(F), z < t || z < g.near || z > g.far || h.push({
              distance: z,
              point: F,
              face: new THREE.Face3(p, q, m, THREE.Triangle.normal(d, e, f)),
              faceIndex: null,
              object: this
            }))
        }
      } else if (k instanceof THREE.Geometry)
      for (s = this.material instanceof THREE.MeshFaceMaterial, r = !0 === s ? this.material.materials : null, t = g.precision, u = k.vertices, v = 0, y = k.faces.length; v < y; v++)
        if (C = k.faces[v], n = !0 === s ? r[C.materialIndex] : this.material, void 0 !== n) {
          p = u[C.a];
          q = u[C.b];
          m = u[C.c];
          if (!0 === n.morphTargets) {
            F = k.morphTargets;
            z = this.morphTargetInfluences;
            d.set(0, 0, 0);
            e.set(0, 0, 0);
            f.set(0, 0, 0);
            for (var x = 0, G = F.length; x < G; x++) {
              var E = z[x];
              if (0 !== E) {
                var w = F[x].vertices;
                d.x += (w[C.a].x - p.x) * E;
                d.y += (w[C.a].y - p.y) * E;
                d.z += (w[C.a].z - p.z) * E;
                e.x += (w[C.b].x - q.x) * E;
                e.y += (w[C.b].y - q.y) * E;
                e.z += (w[C.b].z - q.z) * E;
                f.x += (w[C.c].x - m.x) * E;
                f.y += (w[C.c].y - m.y) * E;
                f.z += (w[C.c].z - m.z) * E
              }
            }
            d.add(p);
            e.add(q);
            f.add(m);
            p = d;
            q = e;
            m = f
          }
          F = n.side === THREE.BackSide ? b.intersectTriangle(m, q, p, !0) : b.intersectTriangle(p, q, m, n.side !== THREE.DoubleSide);
          null !== F && (F.applyMatrix4(this.matrixWorld), z = g.ray.origin.distanceTo(F), z < t || z < g.near || z > g.far || h.push({
            distance: z,
            point: F,
            face: C,
            faceIndex: v,
            object: this
          }))
        }
  }
}();
THREE.Mesh.prototype.clone = function(a, b) {
  void 0 === a && (a = new THREE.Mesh(this.geometry, this.material));
  THREE.Object3D.prototype.clone.call(this, a, b);
  return a
};
THREE.Bone = function(a) {
  THREE.Object3D.call(this);
  this.skin = a
};
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.constructor = THREE.Bone;
THREE.Skeleton = function(a, b, c) {
  this.useVertexTexture = void 0 !== c ? c : !0;
  this.identityMatrix = new THREE.Matrix4;
  a = a || [];
  this.bones = a.slice(0);
  this.useVertexTexture ? (this.boneTextureHeight = this.boneTextureWidth = a = 256 < this.bones.length ? 64 : 64 < this.bones.length ? 32 : 16 < this.bones.length ? 16 : 8, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType), this.boneTexture.minFilter = THREE.NearestFilter, this.boneTexture.magFilter = THREE.NearestFilter, this.boneTexture.generateMipmaps = !1, this.boneTexture.flipY = !1) : this.boneMatrices = new Float32Array(16 * this.bones.length);
  if (void 0 === b) this.calculateInverses();
  else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
  else
    for (console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], b = 0, a = this.bones.length; b < a; b++) this.boneInverses.push(new THREE.Matrix4)
};
THREE.Skeleton.prototype.calculateInverses = function() {
  this.boneInverses = [];
  for (var a = 0, b = this.bones.length; a < b; a++) {
    var c = new THREE.Matrix4;
    this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
    this.boneInverses.push(c)
  }
};
THREE.Skeleton.prototype.pose = function() {
  for (var a, b = 0, c = this.bones.length; b < c; b++)(a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
  b = 0;
  for (c = this.bones.length; b < c; b++)
    if (a = this.bones[b]) a.parent ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)
};
THREE.Skeleton.prototype.update = function() {
  var a = new THREE.Matrix4;
  return function() {
    for (var b = 0, c = this.bones.length; b < c; b++) a.multiplyMatrices(this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix, this.boneInverses[b]), a.flattenToArrayOffset(this.boneMatrices, 16 * b);
    this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
  }
}();
THREE.SkinnedMesh = function(a, b, c) {
  THREE.Mesh.call(this, a, b);
  this.type = "SkinnedMesh";
  this.bindMode = "attached";
  this.bindMatrix = new THREE.Matrix4;
  this.bindMatrixInverse = new THREE.Matrix4;
  a = [];
  if (this.geometry && void 0 !== this.geometry.bones) {
    for (var d, e, f, g, h = 0, k = this.geometry.bones.length; h < k; ++h) d = this.geometry.bones[h], e = d.pos, f = d.rotq, g = d.scl, b = new THREE.Bone(this), a.push(b), b.name = d.name, b.position.set(e[0], e[1], e[2]), b.quaternion.set(f[0], f[1], f[2], f[3]), void 0 !== g ? b.scale.set(g[0], g[1], g[2]) : b.scale.set(1, 1, 1);
    h = 0;
    for (k = this.geometry.bones.length; h < k; ++h) d = this.geometry.bones[h], -1 !== d.parent ? a[d.parent].add(a[h]) : this.add(a[h])
  }
  this.normalizeSkinWeights();
  this.updateMatrixWorld(!0);
  this.bind(new THREE.Skeleton(a, void 0, c))
};
THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;
THREE.SkinnedMesh.prototype.bind = function(a, b) {
  this.skeleton = a;
  void 0 === b && (this.updateMatrixWorld(!0), b = this.matrixWorld);
  this.bindMatrix.copy(b);
  this.bindMatrixInverse.getInverse(b)
};
THREE.SkinnedMesh.prototype.pose = function() {
  this.skeleton.pose()
};
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
  if (this.geometry instanceof THREE.Geometry)
    for (var a = 0; a < this.geometry.skinIndices.length; a++) {
      var b = this.geometry.skinWeights[a],
        c = 1 / b.lengthManhattan();
      Infinity !== c ? b.multiplyScalar(c) : b.set(1)
    }
};
THREE.SkinnedMesh.prototype.updateMatrixWorld = function(a) {
  THREE.Mesh.prototype.updateMatrixWorld.call(this, !0);
  "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unreckognized bindMode: " + this.bindMode)
};
THREE.SkinnedMesh.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.SkinnedMesh(this.geometry, this.material, this.useVertexTexture));
  THREE.Mesh.prototype.clone.call(this, a);
  return a
};
THREE.MorphAnimMesh = function(a, b) {
  THREE.Mesh.call(this, a, b);
  this.type = "MorphAnimMesh";
  this.duration = 1E3;
  this.mirroredLoop = !1;
  this.currentKeyframe = this.lastKeyframe = this.time = 0;
  this.direction = 1;
  this.directionBackwards = !1;
  this.setFrameRange(0, this.geometry.morphTargets.length - 1)
};
THREE.MorphAnimMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;
THREE.MorphAnimMesh.prototype.setFrameRange = function(a, b) {
  this.startKeyframe = a;
  this.endKeyframe = b;
  this.length = this.endKeyframe - this.startKeyframe + 1
};
THREE.MorphAnimMesh.prototype.setDirectionForward = function() {
  this.direction = 1;
  this.directionBackwards = !1
};
THREE.MorphAnimMesh.prototype.setDirectionBackward = function() {
  this.direction = -1;
  this.directionBackwards = !0
};
THREE.MorphAnimMesh.prototype.parseAnimations = function() {
  var a = this.geometry;
  a.animations || (a.animations = {});
  for (var b, c = a.animations, d = /([a-z]+)_?(\d+)/, e = 0, f = a.morphTargets.length; e < f; e++) {
    var g = a.morphTargets[e].name.match(d);
    if (g && 1 < g.length) {
      g = g[1];
      c[g] || (c[g] = {
        start: Infinity,
        end: -Infinity
      });
      var h = c[g];
      e < h.start && (h.start = e);
      e > h.end && (h.end = e);
      b || (b = g)
    }
  }
  a.firstAnimation = b
};
THREE.MorphAnimMesh.prototype.setAnimationLabel = function(a, b, c) {
  this.geometry.animations || (this.geometry.animations = {});
  this.geometry.animations[a] = {
    start: b,
    end: c
  }
};
THREE.MorphAnimMesh.prototype.playAnimation = function(a, b) {
  var c = this.geometry.animations[a];
  c ? (this.setFrameRange(c.start, c.end), this.duration = (c.end - c.start) / b * 1E3, this.time = 0) : console.warn("animation[" + a + "] undefined")
};
THREE.MorphAnimMesh.prototype.updateAnimation = function(a) {
  var b = this.duration / this.length;
  this.time += this.direction * a;
  if (this.mirroredLoop) {
    if (this.time > this.duration || 0 > this.time) this.direction *= -1, this.time > this.duration && (this.time = this.duration, this.directionBackwards = !0), 0 > this.time && (this.time = 0, this.directionBackwards = !1)
  } else this.time %= this.duration, 0 > this.time && (this.time += this.duration);
  a = this.startKeyframe + THREE.Math.clamp(Math.floor(this.time / b), 0, this.length - 1);
  a !== this.currentKeyframe && (this.morphTargetInfluences[this.lastKeyframe] = 0, this.morphTargetInfluences[this.currentKeyframe] = 1, this.morphTargetInfluences[a] = 0, this.lastKeyframe = this.currentKeyframe, this.currentKeyframe = a);
  b = this.time % b / b;
  this.directionBackwards && (b = 1 - b);
  this.morphTargetInfluences[this.currentKeyframe] = b;
  this.morphTargetInfluences[this.lastKeyframe] = 1 - b
};
THREE.MorphAnimMesh.prototype.interpolateTargets = function(a, b, c) {
  for (var d = this.morphTargetInfluences, e = 0, f = d.length; e < f; e++) d[e] = 0; - 1 < a && (d[a] = 1 - c); - 1 < b && (d[b] = c)
};
THREE.MorphAnimMesh.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.MorphAnimMesh(this.geometry, this.material));
  a.duration = this.duration;
  a.mirroredLoop = this.mirroredLoop;
  a.time = this.time;
  a.lastKeyframe = this.lastKeyframe;
  a.currentKeyframe = this.currentKeyframe;
  a.direction = this.direction;
  a.directionBackwards = this.directionBackwards;
  THREE.Mesh.prototype.clone.call(this, a);
  return a
};
THREE.LOD = function() {
  THREE.Object3D.call(this);
  this.objects = []
};
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.constructor = THREE.LOD;
THREE.LOD.prototype.addLevel = function(a, b) {
  void 0 === b && (b = 0);
  b = Math.abs(b);
  for (var c = 0; c < this.objects.length && !(b < this.objects[c].distance); c++);
  this.objects.splice(c, 0, {
    distance: b,
    object: a
  });
  this.add(a)
};
THREE.LOD.prototype.getObjectForDistance = function(a) {
  for (var b = 1, c = this.objects.length; b < c && !(a < this.objects[b].distance); b++);
  return this.objects[b - 1].object
};
THREE.LOD.prototype.raycast = function() {
  var a = new THREE.Vector3;
  return function(b, c) {
    a.setFromMatrixPosition(this.matrixWorld);
    var d = b.ray.origin.distanceTo(a);
    this.getObjectForDistance(d).raycast(b, c)
  }
}();
THREE.LOD.prototype.update = function() {
  var a = new THREE.Vector3,
    b = new THREE.Vector3;
  return function(c) {
    if (1 < this.objects.length) {
      a.setFromMatrixPosition(c.matrixWorld);
      b.setFromMatrixPosition(this.matrixWorld);
      c = a.distanceTo(b);
      this.objects[0].object.visible = !0;
      for (var d = 1, e = this.objects.length; d < e; d++)
        if (c >= this.objects[d].distance) this.objects[d - 1].object.visible = !1, this.objects[d].object.visible = !0;
        else break;
      for (; d < e; d++) this.objects[d].object.visible = !1
    }
  }
}();
THREE.LOD.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.LOD);
  THREE.Object3D.prototype.clone.call(this, a);
  for (var b = 0, c = this.objects.length; b < c; b++) {
    var d = this.objects[b].object.clone();
    d.visible = 0 === b;
    a.addLevel(d, this.objects[b].distance)
  }
  return a
};
THREE.Sprite = function() {
  var a = new Uint16Array([0, 1, 2, 0, 2, 3]),
    b = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0]),
    c = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
    d = new THREE.BufferGeometry;
  d.addAttribute("index", new THREE.BufferAttribute(a, 1));
  d.addAttribute("position", new THREE.BufferAttribute(b, 3));
  d.addAttribute("uv", new THREE.BufferAttribute(c, 2));
  return function(a) {
    THREE.Object3D.call(this);
    this.type = "Sprite";
    this.geometry = d;
    this.material = void 0 !== a ? a : new THREE.SpriteMaterial
  }
}();
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.constructor = THREE.Sprite;
THREE.Sprite.prototype.raycast = function() {
  var a = new THREE.Vector3;
  return function(b, c) {
    a.setFromMatrixPosition(this.matrixWorld);
    var d = b.ray.distanceToPoint(a);
    d > this.scale.x || c.push({
      distance: d,
      point: this.position,
      face: null,
      object: this
    })
  }
}();
THREE.Sprite.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Sprite(this.material));
  THREE.Object3D.prototype.clone.call(this, a);
  return a
};
THREE.Particle = THREE.Sprite;
THREE.LensFlare = function(a, b, c, d, e) {
  THREE.Object3D.call(this);
  this.lensFlares = [];
  this.positionScreen = new THREE.Vector3;
  this.customUpdateCallback = void 0;
  void 0 !== a && this.add(a, b, c, d, e)
};
THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype);
THREE.LensFlare.prototype.constructor = THREE.LensFlare;
THREE.LensFlare.prototype.add = function(a, b, c, d, e, f) {
  void 0 === b && (b = -1);
  void 0 === c && (c = 0);
  void 0 === f && (f = 1);
  void 0 === e && (e = new THREE.Color(16777215));
  void 0 === d && (d = THREE.NormalBlending);
  c = Math.min(c, Math.max(0, c));
  this.lensFlares.push({
    texture: a,
    size: b,
    distance: c,
    x: 0,
    y: 0,
    z: 0,
    scale: 1,
    rotation: 1,
    opacity: f,
    color: e,
    blending: d
  })
};
THREE.LensFlare.prototype.updateLensFlares = function() {
  var a, b = this.lensFlares.length,
    c, d = 2 * -this.positionScreen.x,
    e = 2 * -this.positionScreen.y;
  for (a = 0; a < b; a++) c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = c.x * Math.PI * .25, c.rotation += .25 * (c.wantedRotation - c.rotation)
};
THREE.Scene = function() {
  THREE.Object3D.call(this);
  this.type = "Scene";
  this.overrideMaterial = this.fog = null;
  this.autoUpdate = !0
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.constructor = THREE.Scene;
THREE.Scene.prototype.clone = function(a) {
  void 0 === a && (a = new THREE.Scene);
  THREE.Object3D.prototype.clone.call(this, a);
  null !== this.fog && (a.fog = this.fog.clone());
  null !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());
  a.autoUpdate = this.autoUpdate;
  a.matrixAutoUpdate = this.matrixAutoUpdate;
  return a
};
THREE.Fog = function(a, b, c) {
  this.name = "";
  this.color = new THREE.Color(a);
  this.near = void 0 !== b ? b : 1;
  this.far = void 0 !== c ? c : 1E3
};
THREE.Fog.prototype.clone = function() {
  return new THREE.Fog(this.color.getHex(), this.near, this.far)
};
THREE.FogExp2 = function(a, b) {
  this.name = "";
  this.color = new THREE.Color(a);
  this.density = void 0 !== b ? b : 2.5E-4
};
THREE.FogExp2.prototype.clone = function() {
  return new THREE.FogExp2(this.color.getHex(), this.density)
};
THREE.ShaderChunk = {};
THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n\tif ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n";
THREE.ShaderChunk.lights_lambert_vertex = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\tvec3 dirVector = normalize( lDirection.xyz );\n\n\tfloat dotProduct = dot( transformedNormal, dirVector );\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t#endif\n\n\t#endif\n\n\t#ifdef WRAP_AROUND\n\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n\t\t#endif\n\n\t#endif\n\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n\t#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat lDistance = 1.0;\n\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n\t\tlVector = normalize( lVector );\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\tfloat lDistance = 1.0;\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n\t\t\tlVector = normalize( lVector );\n\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n\t\t\t#endif\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\tvec3 lVector = normalize( lDirection.xyz );\n\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n\t\t#endif\n\n\t}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif";
THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif";
THREE.ShaderChunk.default_vertex = "#ifdef USE_SKINNING\n\n\tvec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n\tvec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";
THREE.ShaderChunk.map_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif";
THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n\t#ifdef USE_MORPHNORMALS\n\n\tvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n\t#else\n\n\tvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n\t#endif\n\n#endif\n";
THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n\tuniform float logDepthBufFC;\n\n#endif";
THREE.ShaderChunk.lightmap_pars_vertex = "#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\n#endif";
THREE.ShaderChunk.lights_phong_fragment = "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tvec3 pointDiffuse = vec3( 0.0 );\n\tvec3 pointSpecular = vec3( 0.0 );\n\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat lDistance = 1.0;\n\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n\t\tlVector = normalize( lVector );\n\n\t\t\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\tpointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n\t\t\t\t// specular\n\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tvec3 spotDiffuse = vec3( 0.0 );\n\tvec3 spotSpecular = vec3( 0.0 );\n\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat lDistance = 1.0;\n\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n\t\tlVector = normalize( lVector );\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\t\t\t// diffuse\n\n\t\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n\t\t\t#else\n\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t\t#endif\n\n\t\t\tspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n\t\t\t\t\t// specular\n\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n\t\t\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n\tvec3 dirDiffuse = vec3( 0.0 );\n\tvec3 dirSpecular = vec3( 0.0 );\n\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\t\tvec3 dirVector = normalize( lDirection.xyz );\n\n\t\t\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, dirVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\tdirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n\t\t// specular\n\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n\t\t/*\n\t\t// fresnel term from skin shader\n\t\tconst float F0 = 0.128;\n\n\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\n\t\tfloat exponential = pow( base, 5.0 );\n\n\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\n\t\t*/\n\n\t\t/*\n\t\t// fresnel term from fresnel shader\n\t\tconst float mFresnelBias = 0.08;\n\t\tconst float mFresnelScale = 0.3;\n\t\tconst float mFresnelPower = 5.0;\n\n\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n\t\t*/\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t// \t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tvec3 hemiDiffuse = vec3( 0.0 );\n\tvec3 hemiSpecular = vec3( 0.0 );\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\tvec3 lVector = normalize( lDirection.xyz );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\themiDiffuse += diffuse * hemiColor;\n\n\t\t// specular (sky light)\n\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n\t\t// specular (ground light)\n\n\t\tvec3 lVectorGround = -lVector;\n\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n\t\themiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n\t}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n\ttotalDiffuse += dirDiffuse;\n\ttotalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\ttotalDiffuse += hemiDiffuse;\n\ttotalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\ttotalDiffuse += pointDiffuse;\n\ttotalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\ttotalDiffuse += spotDiffuse;\n\ttotalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif";
THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n\n#endif";
THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n\tvec3 morphedNormal = vec3( 0.0 );\n\n\tmorphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tmorphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tmorphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tmorphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n\tmorphedNormal += normal;\n\n#endif";
THREE.ShaderChunk.envmap_pars_fragment = "#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tuniform float refractionRatio;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\n\t#endif\n\n#endif\n";
THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";
THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n";
THREE.ShaderChunk.lights_phong_pars_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n";
THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\tuniform sampler2D lightMap;\n\n#endif";
THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n\t}\n\n#endif";
THREE.ShaderChunk.lights_phong_vertex = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif";
THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\t#ifdef GAMMA_INPUT\n\n\t\ttexelColor.xyz *= texelColor.xyz;\n\n\t#endif\n\n\tgl_FragColor = gl_FragColor * texelColor;\n\n#endif";
THREE.ShaderChunk.lightmap_vertex = "#ifdef USE_LIGHTMAP\n\n\tvUv2 = uv2;\n\n#endif";
THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n\tgl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif";
THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";
THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n\t#ifdef GAMMA_INPUT\n\n\t\tvColor = color * color;\n\n\t#else\n\n\t\tvColor = color;\n\n\t#endif\n\n#endif";
THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n\t#ifdef USE_MORPHTARGETS\n\n\tvec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n\t#else\n\n\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n\n#endif\n";
THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvarying vec3 vReflect;\n\n\tuniform float refractionRatio;\n\n#endif\n";
THREE.ShaderChunk.linear_to_gamma_fragment = "#ifdef GAMMA_OUTPUT\n\n\tgl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif";
THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif";
THREE.ShaderChunk.lights_lambert_pars_vertex = "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n";
THREE.ShaderChunk.map_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n\n#endif\n";
THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\n\t\tvec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t#endif\n\n\t#else\n\n\t\tvec3 reflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = clamp( flipNormal * reflectVec.y * 0.5 + 0.5, 0.0, 1.0);\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * 0.15915494309189533576888376337251 + 0.5; // reciprocal( 2 PI ) + 0.5\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t\t\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\n\t#ifdef GAMMA_INPUT\n\n\t\tenvColor.xyz *= envColor.xyz;\n\n\t#endif\n\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, envColor.xyz, specularStrength * reflectivity );\n\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\n\t\tgl_FragColor.xyz += envColor.xyz * specularStrength * reflectivity;\n\n\t#endif\n\n#endif\n";
THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif";
THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n\tgl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n\t#endif\n\n#endif";
THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n\t#ifndef USE_MORPHNORMALS\n\n\tuniform float morphTargetInfluences[ 8 ];\n\n\t#else\n\n\tuniform float morphTargetInfluences[ 4 ];\n\n\t#endif\n\n#endif";
THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif";
THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n\t#else\n\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\n\t#endif\n\n\t#ifdef FOG_EXP2\n\n\t\tconst float LOG2 = 1.442695;\n\t\tfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\n\t#endif\n\t\n\tgl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif";
THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif";
THREE.ShaderChunk.defaultnormal_vertex = "#ifdef USE_SKINNING\n\n\tvec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n\tvec3 objectNormal = morphedNormal;\n\n#else\n\n\tvec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n\tobjectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
THREE.ShaderChunk.lights_phong_pars_fragment = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;";
THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
THREE.ShaderChunk.map_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";
THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n\tgl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif";
THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";
THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n\tgl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif";
THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n\tvec3 morphed = vec3( 0.0 );\n\tmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\tmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\tmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\tmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n\t#ifndef USE_MORPHNORMALS\n\n\tmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\tmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\tmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\tmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n\t#endif\n\n\tmorphed += position;\n\n#endif";
THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n\tvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n\tworldNormal = normalize( worldNormal );\n\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\t#ifdef ENVMAP_MODE_REFLECTION\n\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t#else\n\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t#endif\n\n#endif\n";
THREE.ShaderChunk.shadowmap_fragment = "#ifdef USE_SHADOWMAP\n\n\t#ifdef SHADOWMAP_DEBUG\n\n\t\tvec3 frustumColors[3];\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n\t#endif\n\n\t#ifdef SHADOWMAP_CASCADE\n\n\t\tint inFrustumCount = 0;\n\n\t#endif\n\n\tfloat fDepth;\n\tvec3 shadowColor = vec3( 1.0 );\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\n\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\tinFrustumCount += int( inFrustum );\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n\t\t#else\n\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\t#endif\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\t\t\tshadow += 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tshadow /= 9.0;\n\n\t\t*/\n\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\n\n\t\t\t\tmat3 shadowKernel;\n\t\t\t\tmat3 depthKernel;\n\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\n\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n\t\t\t\tvec4 shadowValues;\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#else\n\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\tif ( fDepth < shadowCoord.z )\n\n\t\t// spot with multiple shadows is darker\n\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n\t\t// spot with multiple shadows has the same color as single shadow spot\n\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n\t\t\t#endif\n\n\t\t}\n\n\n\t\t#ifdef SHADOWMAP_DEBUG\n\n\t\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n\t\t\t#else\n\n\t\t\t\tif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t}\n\n\t#ifdef GAMMA_OUTPUT\n\n\t\tshadowColor *= shadowColor;\n\n\t#endif\n\n\tgl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n";
THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n\t#ifdef USE_SKINNING\n\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\n\t#elif defined( USE_MORPHTARGETS )\n\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n\t#else\n\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n#endif\n";
THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\n\tuniform float shadowBias[ MAX_SHADOWS ];\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\tfloat depth = dot( rgba_depth, bit_shift );\n\t\treturn depth;\n\n\t}\n\n#endif";
THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\n\t#ifdef BONE_TEXTURE\n\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\n\t\t\ty = dy * ( y + 0.5 );\n\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\n\t\t\treturn bone;\n\n\t\t}\n\n\t#else\n\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n\t\tmat4 getBoneMatrix( const in float i ) {\n\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\n\t\t\treturn bone;\n\n\t\t}\n\n\t#endif\n\n#endif\n";
THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\t#extension GL_EXT_frag_depth : enable\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif";
THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n\tgl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n";
THREE.UniformsUtils = {
  merge: function(a) {
    for (var b = {}, c = 0; c < a.length; c++) {
      var d = this.clone(a[c]),
        e;
      for (e in d) b[e] = d[e]
    }
    return b
  },
  clone: function(a) {
    var b = {},
      c;
    for (c in a) {
      b[c] = {};
      for (var d in a[c]) {
        var e = a[c][d];
        b[c][d] = e instanceof THREE.Color || e instanceof THREE.Vector2 || e instanceof THREE.Vector3 || e instanceof THREE.Vector4 || e instanceof THREE.Matrix4 || e instanceof THREE.Texture ? e.clone() : e instanceof Array ? e.slice() : e
      }
    }
    return b
  }
};
THREE.UniformsLib = {
  common: {
    diffuse: {
      type: "c",
      value: new THREE.Color(15658734)
    },
    opacity: {
      type: "f",
      value: 1
    },
    map: {
      type: "t",
      value: null
    },
    offsetRepeat: {
      type: "v4",
      value: new THREE.Vector4(0, 0, 1, 1)
    },
    lightMap: {
      type: "t",
      value: null
    },
    specularMap: {
      type: "t",
      value: null
    },
    alphaMap: {
      type: "t",
      value: null
    },
    envMap: {
      type: "t",
      value: null
    },
    flipEnvMap: {
      type: "f",
      value: -1
    },
    reflectivity: {
      type: "f",
      value: 1
    },
    refractionRatio: {
      type: "f",
      value: .98
    },
    morphTargetInfluences: {
      type: "f",
      value: 0
    }
  },
  bump: {
    bumpMap: {
      type: "t",
      value: null
    },
    bumpScale: {
      type: "f",
      value: 1
    }
  },
  normalmap: {
    normalMap: {
      type: "t",
      value: null
    },
    normalScale: {
      type: "v2",
      value: new THREE.Vector2(1, 1)
    }
  },
  fog: {
    fogDensity: {
      type: "f",
      value: 2.5E-4
    },
    fogNear: {
      type: "f",
      value: 1
    },
    fogFar: {
      type: "f",
      value: 2E3
    },
    fogColor: {
      type: "c",
      value: new THREE.Color(16777215)
    }
  },
  lights: {
    ambientLightColor: {
      type: "fv",
      value: []
    },
    directionalLightDirection: {
      type: "fv",
      value: []
    },
    directionalLightColor: {
      type: "fv",
      value: []
    },
    hemisphereLightDirection: {
      type: "fv",
      value: []
    },
    hemisphereLightSkyColor: {
      type: "fv",
      value: []
    },
    hemisphereLightGroundColor: {
      type: "fv",
      value: []
    },
    pointLightColor: {
      type: "fv",
      value: []
    },
    pointLightPosition: {
      type: "fv",
      value: []
    },
    pointLightDistance: {
      type: "fv1",
      value: []
    },
    spotLightColor: {
      type: "fv",
      value: []
    },
    spotLightPosition: {
      type: "fv",
      value: []
    },
    spotLightDirection: {
      type: "fv",
      value: []
    },
    spotLightDistance: {
      type: "fv1",
      value: []
    },
    spotLightAngleCos: {
      type: "fv1",
      value: []
    },
    spotLightExponent: {
      type: "fv1",
      value: []
    }
  },
  particle: {
    psColor: {
      type: "c",
      value: new THREE.Color(15658734)
    },
    opacity: {
      type: "f",
      value: 1
    },
    size: {
      type: "f",
      value: 1
    },
    scale: {
      type: "f",
      value: 1
    },
    map: {
      type: "t",
      value: null
    },
    fogDensity: {
      type: "f",
      value: 2.5E-4
    },
    fogNear: {
      type: "f",
      value: 1
    },
    fogFar: {
      type: "f",
      value: 2E3
    },
    fogColor: {
      type: "c",
      value: new THREE.Color(16777215)
    }
  },
  shadowmap: {
    shadowMap: {
      type: "tv",
      value: []
    },
    shadowMapSize: {
      type: "v2v",
      value: []
    },
    shadowBias: {
      type: "fv1",
      value: []
    },
    shadowDarkness: {
      type: "fv1",
      value: []
    },
    shadowMatrix: {
      type: "m4v",
      value: []
    }
  }
};
THREE.ShaderLib = {
  basic: {
    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
    vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.skinbase_vertex, "\t#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "\t#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
    fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
  },
  lambert: {
    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
      ambient: {
        type: "c",
        value: new THREE.Color(16777215)
      },
      emissive: {
        type: "c",
        value: new THREE.Color(0)
      },
      wrapRGB: {
        type: "v3",
        value: new THREE.Vector3(1, 1, 1)
      }
    }]),
    vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
    fragmentShader: ["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "\t#ifdef DOUBLE_SIDED\n\t\tif ( gl_FrontFacing )\n\t\t\tgl_FragColor.xyz *= vLightFront;\n\t\telse\n\t\t\tgl_FragColor.xyz *= vLightBack;\n\t#else\n\t\tgl_FragColor.xyz *= vLightFront;\n\t#endif", THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
  },
  phong: {
    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
      ambient: {
        type: "c",
        value: new THREE.Color(16777215)
      },
      emissive: {
        type: "c",
        value: new THREE.Color(0)
      },
      specular: {
        type: "c",
        value: new THREE.Color(1118481)
      },
      shininess: {
        type: "f",
        value: 30
      },
      wrapRGB: {
        type: "v3",
        value: new THREE.Vector3(1, 1, 1)
      }
    }]),
    vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "\tvNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "\tvViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
    fragmentShader: ["#define PHONG\nuniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.alphamap_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( vec3( 1.0 ), opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphamap_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
  },
  particle_basic: {
    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
    vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\tgl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
    fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
  },
  dashed: {
    uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
      scale: {
        type: "f",
        value: 1
      },
      dashSize: {
        type: "f",
        value: 1
      },
      totalSize: {
        type: "f",
        value: 2
      }
    }]),
    vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
    fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tgl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
  },
  depth: {
    uniforms: {
      mNear: {
        type: "f",
        value: 1
      },
      mFar: {
        type: "f",
        value: 2E3
      },
      opacity: {
        type: "f",
        value: 1
      }
    },
    vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
    fragmentShader: ["uniform float mNear;\nuniform float mFar;\nuniform float opacity;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {", THREE.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\n\tgl_FragColor = vec4( vec3( color ), opacity );\n}"].join("\n")
  },
  normal: {
    uniforms: {
      opacity: {
        type: "f",
        value: 1
      }
    },
    vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n\tvNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
    fragmentShader: ["uniform float opacity;\nvarying vec3 vNormal;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
  },
  cube: {
    uniforms: {
      tCube: {
        type: "t",
        value: null
      },
      tFlip: {
        type: "f",
        value: -1
      }
    },
    vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\tvWorldPosition = worldPosition.xyz;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
    fragmentShader: ["uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
  },
  equirect: {
    uniforms: {
      tEquirect: {
        type: "t",
        value: null
      },
      tFlip: {
        type: "f",
        value: -1
      }
    },
    vertexShader: ["varying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {\n\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\tvWorldPosition = worldPosition.xyz;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
    fragmentShader: ["uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;", THREE.ShaderChunk.logdepthbuf_pars_fragment, "void main() {\nvec3 direction = normalize( vWorldPosition );\nvec2 sampleUV;\nsampleUV.y = clamp( tFlip * direction.y * -0.5 + 0.5, 0.0, 1.0);\nsampleUV.x = atan( direction.z, direction.x ) * 0.15915494309189533576888376337251 + 0.5;\ngl_FragColor = texture2D( tEquirect, sampleUV );", THREE.ShaderChunk.logdepthbuf_fragment, "}"].join("\n")
  },
  depthRGBA: {
    uniforms: {},
    vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.logdepthbuf_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.logdepthbuf_vertex, "}"].join("\n"),
    fragmentShader: [THREE.ShaderChunk.logdepthbuf_pars_fragment, "vec4 pack_depth( const in float depth ) {\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main() {", THREE.ShaderChunk.logdepthbuf_fragment, "\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n\t#else\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n\t#endif\n}"].join("\n")
  }
};
THREE.WebGLRenderer = function(a) {
  function b(a) {
    var b = a.geometry;
    a = a.material;
    var c = b.vertices.length;
    if (a.attributes) {
      void 0 === b.__webglCustomAttributesList && (b.__webglCustomAttributesList = []);
      for (var d in a.attributes) {
        var e = a.attributes[d];
        if (!e.__webglInitialized || e.createUniqueBuffers) {
          e.__webglInitialized = !0;
          var f = 1;
          "v2" === e.type ? f = 2 : "v3" === e.type ? f = 3 : "v4" === e.type ? f = 4 : "c" === e.type && (f = 3);
          e.size = f;
          e.array = new Float32Array(c * f);
          e.buffer = l.createBuffer();
          e.buffer.belongsToAttribute = d;
          e.needsUpdate = !0
        }
        b.__webglCustomAttributesList.push(e)
      }
    }
  }

  function c(a, b) {
    var c = b.geometry,
      e = a.faces3,
      f = 3 * e.length,
      g = 1 * e.length,
      h = 3 * e.length,
      e = d(b, a);
    a.__vertexArray = new Float32Array(3 * f);
    a.__normalArray = new Float32Array(3 * f);
    a.__colorArray = new Float32Array(3 * f);
    a.__uvArray = new Float32Array(2 * f);
    1 < c.faceVertexUvs.length && (a.__uv2Array = new Float32Array(2 * f));
    c.hasTangents && (a.__tangentArray = new Float32Array(4 * f));
    b.geometry.skinWeights.length && b.geometry.skinIndices.length && (a.__skinIndexArray = new Float32Array(4 * f), a.__skinWeightArray = new Float32Array(4 * f));
    c = null !== aa.get("OES_element_index_uint") && 21845 < g ? Uint32Array : Uint16Array;
    a.__typeArray = c;
    a.__faceArray = new c(3 * g);
    a.__lineArray = new c(2 * h);
    var k = a.numMorphTargets;
    if (k)
      for (a.__morphTargetsArrays = [], c = 0; c < k; c++) a.__morphTargetsArrays.push(new Float32Array(3 * f));
    if (k = a.numMorphNormals)
      for (a.__morphNormalsArrays = [], c = 0; c < k; c++) a.__morphNormalsArrays.push(new Float32Array(3 * f));
    a.__webglFaceCount = 3 * g;
    a.__webglLineCount = 2 * h;
    if (e.attributes) {
      void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
      for (var m in e.attributes) {
        var g = e.attributes[m],
          h = {},
          n;
        for (n in g) h[n] = g[n];
        if (!h.__webglInitialized || h.createUniqueBuffers) h.__webglInitialized = !0, c = 1, "v2" === h.type ? c = 2 : "v3" === h.type ? c = 3 : "v4" === h.type ? c = 4 : "c" === h.type && (c = 3), h.size = c, h.array = new Float32Array(f * c), h.buffer = l.createBuffer(), h.buffer.belongsToAttribute = m, g.needsUpdate = !0, h.__original = g;
        a.__webglCustomAttributesList.push(h)
      }
    }
    a.__inittedArrays = !0
  }

  function d(a, b) {
    return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material
  }

  function e(a, b, c, d) {
    c = c.attributes;
    var e = b.attributes;
    b = b.attributesKeys;
    for (var f = 0, k = b.length; f < k; f++) {
      var m = b[f],
        n = e[m];
      if (0 <= n) {
        var p = c[m];
        void 0 !== p ? (m = p.itemSize, l.bindBuffer(l.ARRAY_BUFFER, p.buffer), g(n), l.vertexAttribPointer(n, m, l.FLOAT, !1, 0, d * m * 4)) : void 0 !== a.defaultAttributeValues && (2 === a.defaultAttributeValues[m].length ? l.vertexAttrib2fv(n, a.defaultAttributeValues[m]) : 3 === a.defaultAttributeValues[m].length && l.vertexAttrib3fv(n, a.defaultAttributeValues[m]))
      }
    }
    h()
  }

  function f() {
    for (var a = 0, b = kb.length; a < b; a++) kb[a] = 0
  }

  function g(a) {
    kb[a] = 1;
    0 === Ma[a] && (l.enableVertexAttribArray(a), Ma[a] = 1)
  }

  function h() {
    for (var a = 0, b = Ma.length; a < b; a++) Ma[a] !== kb[a] && (l.disableVertexAttribArray(a), Ma[a] = 0)
  }

  function k(a, b) {
    return a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
  }

  function n(a, b) {
    return a.z !== b.z ? b.z - a.z : a.id - b.id
  }

  function p(a, b) {
    return b[0] - a[0]
  }

  function q(a) {
    if (!1 !== a.visible) {
      if (!(a instanceof THREE.Scene || a instanceof THREE.Group)) {
        void 0 === a.__webglInit && (a.__webglInit = !0, a._modelViewMatrix = new THREE.Matrix4, a._normalMatrix = new THREE.Matrix3, a.addEventListener("removed", ic));
        var c = a.geometry;
        if (void 0 !== c && void 0 === c.__webglInit)
          if (c.__webglInit = !0, c.addEventListener("dispose", jc), c instanceof THREE.BufferGeometry) I.info.memory.geometries++;
          else if (a instanceof THREE.Mesh) r(a, c);
        else if (a instanceof THREE.Line) {
          if (void 0 === c.__webglVertexBuffer) {
            c.__webglVertexBuffer = l.createBuffer();
            c.__webglColorBuffer = l.createBuffer();
            c.__webglLineDistanceBuffer = l.createBuffer();
            I.info.memory.geometries++;
            var d = c.vertices.length;
            c.__vertexArray = new Float32Array(3 * d);
            c.__colorArray = new Float32Array(3 * d);
            c.__lineDistanceArray = new Float32Array(1 * d);
            c.__webglLineCount = d;
            b(a);
            c.verticesNeedUpdate = !0;
            c.colorsNeedUpdate = !0;
            c.lineDistancesNeedUpdate = !0
          }
        } else a instanceof THREE.PointCloud && void 0 === c.__webglVertexBuffer && (c.__webglVertexBuffer = l.createBuffer(), c.__webglColorBuffer = l.createBuffer(), I.info.memory.geometries++, d = c.vertices.length, c.__vertexArray = new Float32Array(3 * d), c.__colorArray = new Float32Array(3 * d), c.__sortArray = [], c.__webglParticleCount = d, b(a), c.verticesNeedUpdate = !0, c.colorsNeedUpdate = !0);
        if (void 0 === a.__webglActive)
          if (a.__webglActive = !0, a instanceof THREE.Mesh)
            if (c instanceof THREE.BufferGeometry) u(Fa, c, a);
            else {
              if (c instanceof THREE.Geometry)
                for (var c = sb[c.id], d = 0, e = c.length; d < e; d++) u(Fa, c[d], a)
            } else a instanceof THREE.Line || a instanceof THREE.PointCloud ? u(Fa, c, a) : (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback) && Ga.push({
          id: null,
          object: a,
          opaque: null,
          transparent: null,
          z: 0
        });
        if (a instanceof THREE.Light) pa.push(a);
        else if (a instanceof THREE.Sprite) tb.push(a);
        else if (a instanceof THREE.LensFlare) eb.push(a);
        else if ((c = Fa[a.id]) && (!1 === a.frustumCulled || !0 === ub.intersectsObject(a)))
          for (d = 0, e = c.length; d < e; d++) {
            var f = c[d],
              g = f,
              h = g.object,
              k = g.buffer,
              m = h.geometry,
              h = h.material;
            h instanceof THREE.MeshFaceMaterial ? (h = h.materials[m instanceof THREE.BufferGeometry ? 0 : k.materialIndex], g.material = h, h.transparent ? za.push(g) : Ta.push(g)) : h && (g.material = h, h.transparent ? za.push(g) : Ta.push(g));
            f.render = !0;
            !0 === I.sortObjects && (Da.setFromMatrixPosition(a.matrixWorld), Da.applyProjection(vb), f.z = Da.z)
          }
      }
      d = 0;
      for (e = a.children.length; d < e; d++) q(a.children[d])
    }
  }

  function m(a, b, c, d, e, f) {
    for (var g, h = 0, l = a.length; h < l; h++) {
      g = a[h];
      var k = g.object,
        m = g.buffer;
      G(k, b);
      if (f) g = f;
      else {
        g = g.material;
        if (!g) continue;
        e && I.setBlending(g.blending, g.blendEquation, g.blendSrc, g.blendDst);
        I.setDepthTest(g.depthTest);
        I.setDepthWrite(g.depthWrite);
        A(g.polygonOffset, g.polygonOffsetFactor, g.polygonOffsetUnits)
      }
      I.setMaterialFaces(g);
      m instanceof THREE.BufferGeometry ? I.renderBufferDirect(b, c, d, g, m, k) : I.renderBuffer(b, c, d, g, m, k)
    }
  }

  function t(a, b, c, d, e, f, g) {
    for (var h, l = 0, k = a.length; l < k; l++) {
      h = a[l];
      var m = h.object;
      if (m.visible) {
        if (g) h = g;
        else {
          h = h[b];
          if (!h) continue;
          f && I.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst);
          I.setDepthTest(h.depthTest);
          I.setDepthWrite(h.depthWrite);
          A(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits)
        }
        I.renderImmediateObject(c, d, e, h, m)
      }
    }
  }

  function s(a) {
    var b = a.object.material;
    b.transparent ? (a.transparent = b, a.opaque = null) : (a.opaque = b, a.transparent = null)
  }

  function r(a, b) {
    var d = a.material,
      e = !1;
    if (void 0 === sb[b.id] || !0 === b.groupsNeedUpdate) {
      delete Fa[a.id];
      for (var f = sb, g = b.id, d = d instanceof THREE.MeshFaceMaterial, h = aa.get("OES_element_index_uint") ? 4294967296 : 65535, k, e = {}, m = b.morphTargets.length, n = b.morphNormals.length, p, q = {}, r = [], t = 0, s = b.faces.length; t < s; t++) {
        k = b.faces[t];
        var v = d ? k.materialIndex : 0;
        v in e || (e[v] = {
          hash: v,
          counter: 0
        });
        k = e[v].hash + "_" + e[v].counter;
        k in q || (p = {
          id: kc++,
          faces3: [],
          materialIndex: v,
          vertices: 0,
          numMorphTargets: m,
          numMorphNormals: n
        }, q[k] = p, r.push(p));
        q[k].vertices + 3 > h && (e[v].counter += 1, k = e[v].hash + "_" + e[v].counter, k in q || (p = {
          id: kc++,
          faces3: [],
          materialIndex: v,
          vertices: 0,
          numMorphTargets: m,
          numMorphNormals: n
        }, q[k] = p, r.push(p)));
        q[k].faces3.push(t);
        q[k].vertices += 3
      }
      f[g] = r;
      b.groupsNeedUpdate = !1
    }
    f = sb[b.id];
    g = 0;
    for (d = f.length; g < d; g++) {
      h = f[g];
      if (void 0 === h.__webglVertexBuffer) {
        e = h;
        e.__webglVertexBuffer = l.createBuffer();
        e.__webglNormalBuffer = l.createBuffer();
        e.__webglTangentBuffer = l.createBuffer();
        e.__webglColorBuffer = l.createBuffer();
        e.__webglUVBuffer = l.createBuffer();
        e.__webglUV2Buffer = l.createBuffer();
        e.__webglSkinIndicesBuffer = l.createBuffer();
        e.__webglSkinWeightsBuffer = l.createBuffer();
        e.__webglFaceBuffer = l.createBuffer();
        e.__webglLineBuffer = l.createBuffer();
        if (n = e.numMorphTargets)
          for (e.__webglMorphTargetsBuffers = [], m = 0; m < n; m++) e.__webglMorphTargetsBuffers.push(l.createBuffer());
        if (n = e.numMorphNormals)
          for (e.__webglMorphNormalsBuffers = [], m = 0; m < n; m++) e.__webglMorphNormalsBuffers.push(l.createBuffer());
        I.info.memory.geometries++;
        c(h, a);
        b.verticesNeedUpdate = !0;
        b.morphTargetsNeedUpdate = !0;
        b.elementsNeedUpdate = !0;
        b.uvsNeedUpdate = !0;
        b.normalsNeedUpdate = !0;
        b.tangentsNeedUpdate = !0;
        e = b.colorsNeedUpdate = !0
      } else e = !1;
      (e || void 0 === a.__webglActive) && u(Fa, h, a)
    }
    a.__webglActive = !0
  }

  function u(a, b, c) {
    var d = c.id;
    a[d] = a[d] || [];
    a[d].push({
      id: d,
      buffer: b,
      object: c,
      material: null,
      z: 0
    })
  }

  function v(a) {
    var b = a.geometry;
    if (b instanceof THREE.BufferGeometry)
      for (var e = b.attributes, f = b.attributesKeys, g = 0, h = f.length; g < h; g++) {
        var k = f[g],
          m = e[k];
        void 0 === m.buffer && (m.buffer = l.createBuffer(), m.needsUpdate = !0);
        if (!0 === m.needsUpdate) {
          var n = "index" === k ? l.ELEMENT_ARRAY_BUFFER : l.ARRAY_BUFFER;
          l.bindBuffer(n, m.buffer);
          l.bufferData(n, m.array, l.STATIC_DRAW);
          m.needsUpdate = !1
        }
      } else if (a instanceof THREE.Mesh) {
        !0 === b.groupsNeedUpdate && r(a, b);
        for (var p = sb[b.id], g = 0, q = p.length; g < q; g++) {
          var t = p[g],
            s = d(a, t);
          !0 === b.groupsNeedUpdate && c(t, a);
          var u = s.attributes && y(s);
          if (b.verticesNeedUpdate || b.morphTargetsNeedUpdate || b.elementsNeedUpdate || b.uvsNeedUpdate || b.normalsNeedUpdate || b.colorsNeedUpdate || b.tangentsNeedUpdate || u) {
            var v = t,
              x = a,
              z = l.DYNAMIC_DRAW,
              G = !b.dynamic,
              E = s;
            if (v.__inittedArrays) {
              var D = E && void 0 !== E.shading && E.shading === THREE.SmoothShading,
                w = void 0,
                F = void 0,
                I = void 0,
                A = void 0,
                Q = void 0,
                M = void 0,
                K = void 0,
                N = void 0,
                O = void 0,
                T = void 0,
                U = void 0,
                H = void 0,
                L = void 0,
                X = void 0,
                W = void 0,
                pa = void 0,
                ta = void 0,
                Za = void 0,
                Fa = void 0,
                ga = void 0,
                Ta = void 0,
                aa = void 0,
                Ga = void 0,
                za = void 0,
                ha = void 0,
                P = void 0,
                ea = void 0,
                fa = void 0,
                ma = void 0,
                Y = void 0,
                tb = void 0,
                qa = void 0,
                Da = void 0,
                Aa = void 0,
                Ha = void 0,
                xa = void 0,
                na = void 0,
                ab = void 0,
                eb = void 0,
                la = void 0,
                Na = 0,
                Ua = 0,
                mb = 0,
                ya = 0,
                Xa = 0,
                Va = 0,
                Ia = 0,
                nb = 0,
                Oa = 0,
                ia = 0,
                ra = 0,
                J = 0,
                Ba = void 0,
                bb = v.__vertexArray,
                wb = v.__uvArray,
                ob = v.__uv2Array,
                Pa = v.__normalArray,
                Ca = v.__tangentArray,
                cb = v.__colorArray,
                Ka = v.__skinIndexArray,
                La = v.__skinWeightArray,
                $a = v.__morphTargetsArrays,
                xb = v.__morphNormalsArrays,
                pb = v.__webglCustomAttributesList,
                B = void 0,
                db = v.__faceArray,
                sa = v.__lineArray,
                oa = x.geometry,
                Sa = oa.elementsNeedUpdate,
                Ma = oa.uvsNeedUpdate,
                Ab = oa.normalsNeedUpdate,
                Hb = oa.tangentsNeedUpdate,
                Ib = oa.colorsNeedUpdate,
                lb = oa.morphTargetsNeedUpdate,
                Cb = oa.vertices,
                V = v.faces3,
                Ja = oa.faces,
                Wa = oa.faceVertexUvs[0],
                Db = oa.faceVertexUvs[1],
                Pb = oa.skinIndices,
                $ = oa.skinWeights,
                Eb = oa.morphTargets,
                R = oa.morphNormals;
              if (oa.verticesNeedUpdate) {
                w = 0;
                for (F = V.length; w < F; w++) A = Ja[V[w]], H = Cb[A.a], L = Cb[A.b], X = Cb[A.c], bb[Ua] = H.x, bb[Ua + 1] = H.y, bb[Ua + 2] = H.z, bb[Ua + 3] = L.x, bb[Ua + 4] = L.y, bb[Ua + 5] = L.z, bb[Ua + 6] = X.x, bb[Ua + 7] = X.y, bb[Ua + 8] = X.z, Ua += 9;
                l.bindBuffer(l.ARRAY_BUFFER, v.__webglVertexBuffer);
                l.bufferData(l.ARRAY_BUFFER, bb, z)
              }
              if (lb)
                for (Ha = 0, xa = Eb.length; Ha < xa; Ha++) {
                  w = ra = 0;
                  for (F = V.length; w < F; w++) eb = V[w], A = Ja[eb], H = Eb[Ha].vertices[A.a], L = Eb[Ha].vertices[A.b], X = Eb[Ha].vertices[A.c], na = $a[Ha], na[ra] = H.x, na[ra + 1] = H.y, na[ra + 2] = H.z, na[ra + 3] = L.x, na[ra + 4] = L.y, na[ra + 5] = L.z, na[ra + 6] = X.x, na[ra + 7] = X.y, na[ra + 8] = X.z, E.morphNormals && (D ? (la = R[Ha].vertexNormals[eb], Za = la.a, Fa = la.b, ga = la.c) : ga = Fa = Za = R[Ha].faceNormals[eb], ab = xb[Ha], ab[ra] = Za.x, ab[ra + 1] = Za.y, ab[ra + 2] = Za.z, ab[ra + 3] = Fa.x, ab[ra + 4] = Fa.y, ab[ra + 5] = Fa.z, ab[ra + 6] = ga.x, ab[ra + 7] = ga.y, ab[ra + 8] = ga.z), ra += 9;
                  l.bindBuffer(l.ARRAY_BUFFER, v.__webglMorphTargetsBuffers[Ha]);
                  l.bufferData(l.ARRAY_BUFFER, $a[Ha], z);
                  E.morphNormals && (l.bindBuffer(l.ARRAY_BUFFER, v.__webglMorphNormalsBuffers[Ha]), l.bufferData(l.ARRAY_BUFFER, xb[Ha], z))
                }
              if ($.length) {
                w = 0;
                for (F = V.length; w < F; w++) A = Ja[V[w]], za = $[A.a], ha = $[A.b], P = $[A.c], La[ia] = za.x, La[ia + 1] = za.y, La[ia + 2] = za.z, La[ia + 3] = za.w, La[ia + 4] = ha.x, La[ia + 5] = ha.y, La[ia + 6] = ha.z, La[ia + 7] = ha.w, La[ia + 8] = P.x, La[ia + 9] = P.y, La[ia + 10] = P.z, La[ia + 11] = P.w, ea = Pb[A.a], fa = Pb[A.b], ma = Pb[A.c], Ka[ia] = ea.x, Ka[ia + 1] = ea.y, Ka[ia + 2] = ea.z, Ka[ia + 3] = ea.w, Ka[ia + 4] = fa.x, Ka[ia + 5] = fa.y, Ka[ia + 6] = fa.z, Ka[ia + 7] = fa.w, Ka[ia + 8] = ma.x, Ka[ia + 9] = ma.y, Ka[ia + 10] = ma.z, Ka[ia + 11] = ma.w, ia += 12;
                0 < ia && (l.bindBuffer(l.ARRAY_BUFFER, v.__webglSkinIndicesBuffer), l.bufferData(l.ARRAY_BUFFER, Ka, z), l.bindBuffer(l.ARRAY_BUFFER, v.__webglSkinWeightsBuffer), l.bufferData(l.ARRAY_BUFFER, La, z))
              }
              if (Ib) {
                w = 0;
                for (F = V.length; w < F; w++) A = Ja[V[w]], K = A.vertexColors, N = A.color, 3 === K.length && E.vertexColors === THREE.VertexColors ? (Ta = K[0], aa = K[1], Ga = K[2]) : Ga = aa = Ta = N, cb[Oa] = Ta.r, cb[Oa + 1] = Ta.g, cb[Oa + 2] = Ta.b, cb[Oa + 3] = aa.r, cb[Oa + 4] = aa.g, cb[Oa + 5] = aa.b, cb[Oa + 6] = Ga.r, cb[Oa + 7] = Ga.g, cb[Oa + 8] = Ga.b, Oa += 9;
                0 < Oa && (l.bindBuffer(l.ARRAY_BUFFER, v.__webglColorBuffer), l.bufferData(l.ARRAY_BUFFER, cb, z))
              }
              if (Hb && oa.hasTangents) {
                w = 0;
                for (F = V.length; w < F; w++) A = Ja[V[w]], O = A.vertexTangents, W = O[0], pa = O[1], ta = O[2], Ca[Ia] = W.x, Ca[Ia + 1] = W.y, Ca[Ia + 2] = W.z, Ca[Ia + 3] = W.w, Ca[Ia + 4] = pa.x, Ca[Ia + 5] = pa.y, Ca[Ia + 6] = pa.z, Ca[Ia + 7] = pa.w, Ca[Ia + 8] = ta.x, Ca[Ia + 9] = ta.y, Ca[Ia + 10] = ta.z, Ca[Ia + 11] = ta.w, Ia += 12;
                l.bindBuffer(l.ARRAY_BUFFER, v.__webglTangentBuffer);
                l.bufferData(l.ARRAY_BUFFER, Ca, z)
              }
              if (Ab) {
                w = 0;
                for (F = V.length; w < F; w++)
                  if (A = Ja[V[w]], Q = A.vertexNormals, M = A.normal, 3 === Q.length && D)
                    for (Y = 0; 3 > Y; Y++) qa = Q[Y], Pa[Va] = qa.x, Pa[Va + 1] = qa.y, Pa[Va + 2] = qa.z, Va += 3;
                  else
                    for (Y = 0; 3 > Y; Y++) Pa[Va] = M.x, Pa[Va + 1] = M.y, Pa[Va + 2] = M.z, Va += 3;
                l.bindBuffer(l.ARRAY_BUFFER, v.__webglNormalBuffer);
                l.bufferData(l.ARRAY_BUFFER, Pa, z)
              }
              if (Ma && Wa) {
                w = 0;
                for (F = V.length; w < F; w++)
                  if (I = V[w], T = Wa[I], void 0 !== T)
                    for (Y = 0; 3 > Y; Y++) Da = T[Y], wb[mb] = Da.x, wb[mb + 1] = Da.y, mb += 2;
                0 < mb && (l.bindBuffer(l.ARRAY_BUFFER, v.__webglUVBuffer), l.bufferData(l.ARRAY_BUFFER, wb, z))
              }
              if (Ma && Db) {
                w = 0;
                for (F = V.length; w < F; w++)
                  if (I = V[w], U = Db[I], void 0 !== U)
                    for (Y = 0; 3 > Y; Y++) Aa = U[Y], ob[ya] = Aa.x, ob[ya + 1] = Aa.y, ya += 2;
                0 < ya && (l.bindBuffer(l.ARRAY_BUFFER, v.__webglUV2Buffer), l.bufferData(l.ARRAY_BUFFER, ob, z))
              }
              if (Sa) {
                w = 0;
                for (F = V.length; w < F; w++) db[Xa] = Na, db[Xa + 1] = Na + 1, db[Xa + 2] = Na + 2, Xa += 3, sa[nb] = Na, sa[nb + 1] = Na + 1, sa[nb + 2] = Na, sa[nb + 3] = Na + 2, sa[nb + 4] = Na + 1, sa[nb + 5] = Na + 2, nb += 6, Na += 3;
                l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, v.__webglFaceBuffer);
                l.bufferData(l.ELEMENT_ARRAY_BUFFER, db, z);
                l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, v.__webglLineBuffer);
                l.bufferData(l.ELEMENT_ARRAY_BUFFER, sa, z)
              }
              if (pb)
                for (Y = 0, tb = pb.length; Y < tb; Y++)
                  if (B = pb[Y], B.__original.needsUpdate) {
                    J = 0;
                    if (1 === B.size)
                      if (void 0 === B.boundTo || "vertices" === B.boundTo)
                        for (w = 0, F = V.length; w < F; w++) A = Ja[V[w]], B.array[J] = B.value[A.a], B.array[J + 1] = B.value[A.b], B.array[J + 2] = B.value[A.c], J += 3;
                      else {
                        if ("faces" === B.boundTo)
                          for (w = 0, F = V.length; w < F; w++) Ba = B.value[V[w]], B.array[J] = Ba, B.array[J + 1] = Ba, B.array[J + 2] = Ba, J += 3
                      } else if (2 === B.size)
                      if (void 0 === B.boundTo || "vertices" === B.boundTo)
                        for (w = 0, F = V.length; w < F; w++) A = Ja[V[w]], H = B.value[A.a], L = B.value[A.b], X = B.value[A.c], B.array[J] = H.x, B.array[J + 1] = H.y, B.array[J + 2] = L.x, B.array[J + 3] = L.y, B.array[J + 4] = X.x, B.array[J + 5] = X.y, J += 6;
                      else {
                        if ("faces" === B.boundTo)
                          for (w = 0, F = V.length; w < F; w++) X = L = H = Ba = B.value[V[w]], B.array[J] = H.x, B.array[J + 1] = H.y, B.array[J + 2] = L.x, B.array[J + 3] = L.y, B.array[J + 4] = X.x, B.array[J + 5] = X.y, J += 6
                      } else if (3 === B.size) {
                      var S;
                      S = "c" === B.type ? ["r", "g", "b"] : ["x", "y", "z"];
                      if (void 0 === B.boundTo || "vertices" === B.boundTo)
                        for (w = 0, F = V.length; w < F; w++) A = Ja[V[w]], H = B.value[A.a], L = B.value[A.b], X = B.value[A.c], B.array[J] = H[S[0]], B.array[J + 1] = H[S[1]], B.array[J + 2] = H[S[2]], B.array[J + 3] = L[S[0]], B.array[J + 4] = L[S[1]], B.array[J + 5] = L[S[2]], B.array[J + 6] = X[S[0]], B.array[J + 7] = X[S[1]], B.array[J + 8] = X[S[2]], J += 9;
                      else if ("faces" === B.boundTo)
                        for (w = 0, F = V.length; w < F; w++) X = L = H = Ba = B.value[V[w]], B.array[J] = H[S[0]], B.array[J + 1] = H[S[1]], B.array[J + 2] = H[S[2]], B.array[J + 3] = L[S[0]], B.array[J + 4] = L[S[1]], B.array[J + 5] = L[S[2]], B.array[J + 6] = X[S[0]], B.array[J + 7] = X[S[1]], B.array[J + 8] = X[S[2]], J += 9;
                      else if ("faceVertices" === B.boundTo)
                        for (w = 0, F = V.length; w < F; w++) Ba = B.value[V[w]], H = Ba[0], L = Ba[1], X = Ba[2], B.array[J] = H[S[0]], B.array[J + 1] = H[S[1]], B.array[J + 2] = H[S[2]], B.array[J + 3] = L[S[0]], B.array[J + 4] = L[S[1]], B.array[J + 5] = L[S[2]], B.array[J + 6] = X[S[0]], B.array[J + 7] = X[S[1]], B.array[J + 8] = X[S[2]], J += 9
                    } else if (4 === B.size)
                      if (void 0 === B.boundTo || "vertices" === B.boundTo)
                        for (w = 0, F = V.length; w < F; w++) A = Ja[V[w]], H = B.value[A.a], L = B.value[A.b], X = B.value[A.c], B.array[J] = H.x, B.array[J + 1] = H.y, B.array[J + 2] = H.z, B.array[J + 3] = H.w, B.array[J + 4] = L.x, B.array[J + 5] = L.y, B.array[J + 6] = L.z, B.array[J + 7] = L.w, B.array[J + 8] = X.x, B.array[J + 9] = X.y, B.array[J + 10] = X.z, B.array[J + 11] = X.w, J += 12;
                      else if ("faces" === B.boundTo)
                      for (w = 0, F = V.length; w < F; w++) X = L = H = Ba = B.value[V[w]], B.array[J] = H.x, B.array[J + 1] = H.y, B.array[J + 2] = H.z, B.array[J + 3] = H.w, B.array[J + 4] = L.x, B.array[J + 5] = L.y, B.array[J + 6] = L.z, B.array[J + 7] = L.w, B.array[J + 8] = X.x, B.array[J + 9] = X.y, B.array[J + 10] = X.z, B.array[J + 11] = X.w, J += 12;
                    else if ("faceVertices" === B.boundTo)
                      for (w = 0, F = V.length; w < F; w++) Ba = B.value[V[w]], H = Ba[0], L = Ba[1], X = Ba[2], B.array[J] = H.x, B.array[J + 1] = H.y, B.array[J + 2] = H.z, B.array[J + 3] = H.w, B.array[J + 4] = L.x, B.array[J + 5] = L.y, B.array[J + 6] = L.z, B.array[J + 7] = L.w, B.array[J + 8] = X.x, B.array[J + 9] = X.y, B.array[J + 10] = X.z, B.array[J + 11] = X.w, J += 12;
                    l.bindBuffer(l.ARRAY_BUFFER, B.buffer);
                    l.bufferData(l.ARRAY_BUFFER, B.array, z)
                  }
              G && (delete v.__inittedArrays, delete v.__colorArray, delete v.__normalArray, delete v.__tangentArray, delete v.__uvArray, delete v.__uv2Array, delete v.__faceArray, delete v.__vertexArray, delete v.__lineArray, delete v.__skinIndexArray, delete v.__skinWeightArray)
            }
          }
        }
        b.verticesNeedUpdate = !1;
        b.morphTargetsNeedUpdate = !1;
        b.elementsNeedUpdate = !1;
        b.uvsNeedUpdate = !1;
        b.normalsNeedUpdate = !1;
        b.colorsNeedUpdate = !1;
        b.tangentsNeedUpdate = !1;
        s.attributes && C(s)
      } else if (a instanceof THREE.Line) {
      s = d(a, b);
      u = s.attributes && y(s);
      if (b.verticesNeedUpdate || b.colorsNeedUpdate || b.lineDistancesNeedUpdate || u) {
        var Z = l.DYNAMIC_DRAW,
          Ea, ka, Bb, Fb, ba, gb, ua = b.vertices,
          Qb = b.colors,
          Rb = b.lineDistances,
          qb = ua.length,
          Sb = Qb.length,
          yb = Rb.length,
          Gb = b.__vertexArray,
          rb = b.__colorArray,
          kb = b.__lineDistanceArray,
          Mb = b.colorsNeedUpdate,
          Ob = b.lineDistancesNeedUpdate,
          hb = b.__webglCustomAttributesList,
          Ya, ib, va, Kb, Qa, ca;
        if (b.verticesNeedUpdate) {
          for (Ea = 0; Ea < qb; Ea++) Fb = ua[Ea], ba = 3 * Ea, Gb[ba] = Fb.x, Gb[ba + 1] = Fb.y, Gb[ba + 2] = Fb.z;
          l.bindBuffer(l.ARRAY_BUFFER, b.__webglVertexBuffer);
          l.bufferData(l.ARRAY_BUFFER, Gb, Z)
        }
        if (Mb) {
          for (ka = 0; ka < Sb; ka++) gb = Qb[ka], ba = 3 * ka, rb[ba] = gb.r, rb[ba + 1] = gb.g, rb[ba + 2] = gb.b;
          l.bindBuffer(l.ARRAY_BUFFER, b.__webglColorBuffer);
          l.bufferData(l.ARRAY_BUFFER, rb, Z)
        }
        if (Ob) {
          for (Bb = 0; Bb < yb; Bb++) kb[Bb] = Rb[Bb];
          l.bindBuffer(l.ARRAY_BUFFER, b.__webglLineDistanceBuffer);
          l.bufferData(l.ARRAY_BUFFER, kb, Z)
        }
        if (hb)
          for (Ya = 0, ib = hb.length; Ya < ib; Ya++)
            if (ca = hb[Ya], ca.needsUpdate && (void 0 === ca.boundTo || "vertices" === ca.boundTo)) {
              ba = 0;
              Kb = ca.value.length;
              if (1 === ca.size)
                for (va = 0; va < Kb; va++) ca.array[va] = ca.value[va];
              else if (2 === ca.size)
                for (va = 0; va < Kb; va++) Qa = ca.value[va], ca.array[ba] = Qa.x, ca.array[ba + 1] = Qa.y, ba += 2;
              else if (3 === ca.size)
                if ("c" === ca.type)
                  for (va = 0; va < Kb; va++) Qa = ca.value[va], ca.array[ba] = Qa.r, ca.array[ba + 1] = Qa.g, ca.array[ba + 2] = Qa.b, ba += 3;
                else
                  for (va = 0; va < Kb; va++) Qa = ca.value[va], ca.array[ba] = Qa.x, ca.array[ba + 1] = Qa.y, ca.array[ba + 2] = Qa.z, ba += 3;
              else if (4 === ca.size)
                for (va = 0; va < Kb; va++) Qa = ca.value[va], ca.array[ba] = Qa.x, ca.array[ba + 1] = Qa.y, ca.array[ba + 2] = Qa.z, ca.array[ba + 3] = Qa.w, ba += 4;
              l.bindBuffer(l.ARRAY_BUFFER, ca.buffer);
              l.bufferData(l.ARRAY_BUFFER, ca.array, Z);
              ca.needsUpdate = !1
            }
      }
      b.verticesNeedUpdate = !1;
      b.colorsNeedUpdate = !1;
      b.lineDistancesNeedUpdate = !1;
      s.attributes && C(s)
    } else if (a instanceof THREE.PointCloud) {
      s = d(a, b);
      u = s.attributes && y(s);
      if (b.verticesNeedUpdate || b.colorsNeedUpdate || u) {
        var jb = l.DYNAMIC_DRAW,
          Tb, Ub, $b, ja, ac, ub = b.vertices,
          vb = ub.length,
          Nb = b.colors,
          Vb = Nb.length,
          bc = b.__vertexArray,
          cc = b.__colorArray,
          Wb = b.colorsNeedUpdate,
          Jb = b.__webglCustomAttributesList,
          dc, zb, wa, Lb, Ra, da;
        if (b.verticesNeedUpdate) {
          for (Tb = 0; Tb < vb; Tb++) $b = ub[Tb], ja = 3 * Tb, bc[ja] = $b.x, bc[ja + 1] = $b.y, bc[ja + 2] = $b.z;
          l.bindBuffer(l.ARRAY_BUFFER, b.__webglVertexBuffer);
          l.bufferData(l.ARRAY_BUFFER, bc, jb)
        }
        if (Wb) {
          for (Ub = 0; Ub < Vb; Ub++) ac = Nb[Ub], ja = 3 * Ub, cc[ja] = ac.r, cc[ja + 1] = ac.g, cc[ja + 2] = ac.b;
          l.bindBuffer(l.ARRAY_BUFFER, b.__webglColorBuffer);
          l.bufferData(l.ARRAY_BUFFER, cc, jb)
        }
        if (Jb)
          for (dc = 0, zb = Jb.length; dc < zb; dc++) {
            da = Jb[dc];
            if (da.needsUpdate && (void 0 === da.boundTo || "vertices" === da.boundTo))
              if (Lb = da.value.length, ja = 0, 1 === da.size)
                for (wa = 0; wa < Lb; wa++) da.array[wa] = da.value[wa];
              else if (2 === da.size)
              for (wa = 0; wa < Lb; wa++) Ra = da.value[wa], da.array[ja] = Ra.x, da.array[ja + 1] = Ra.y, ja += 2;
            else if (3 === da.size)
              if ("c" === da.type)
                for (wa = 0; wa < Lb; wa++) Ra = da.value[wa], da.array[ja] = Ra.r, da.array[ja + 1] = Ra.g, da.array[ja + 2] = Ra.b, ja += 3;
              else
                for (wa = 0; wa < Lb; wa++) Ra = da.value[wa], da.array[ja] = Ra.x, da.array[ja + 1] = Ra.y, da.array[ja + 2] = Ra.z, ja += 3;
            else if (4 === da.size)
              for (wa = 0; wa < Lb; wa++) Ra = da.value[wa], da.array[ja] = Ra.x, da.array[ja + 1] = Ra.y, da.array[ja + 2] = Ra.z, da.array[ja + 3] = Ra.w, ja += 4;
            l.bindBuffer(l.ARRAY_BUFFER, da.buffer);
            l.bufferData(l.ARRAY_BUFFER, da.array, jb);
            da.needsUpdate = !1
          }
      }
      b.verticesNeedUpdate = !1;
      b.colorsNeedUpdate = !1;
      s.attributes && C(s)
    }
  }

  function y(a) {
    for (var b in a.attributes)
      if (a.attributes[b].needsUpdate) return !0;
    return !1
  }

  function C(a) {
    for (var b in a.attributes) a.attributes[b].needsUpdate = !1
  }

  function x(a, b, c, d, e) {
    var f, g, h, k;
    Mb = 0;
    if (d.needsUpdate) {
      d.program && lc(d);
      d.addEventListener("dispose", mc);
      var m = Dc[d.type];
      if (m) {
        var n = THREE.ShaderLib[m];
        d.__webglShader = {
          uniforms: THREE.UniformsUtils.clone(n.uniforms),
          vertexShader: n.vertexShader,
          fragmentShader: n.fragmentShader
        }
      } else d.__webglShader = {
        uniforms: d.uniforms,
        vertexShader: d.vertexShader,
        fragmentShader: d.fragmentShader
      };
      for (var p = 0, q = 0, r = 0, t = 0, s = 0, v = b.length; s < v; s++) {
        var u = b[s];
        u.onlyShadow || !1 === u.visible || (u instanceof THREE.DirectionalLight && p++, u instanceof THREE.PointLight && q++, u instanceof THREE.SpotLight && r++, u instanceof THREE.HemisphereLight && t++)
      }
      f = p;
      g = q;
      h = r;
      k = t;
      for (var x, y = 0, C = 0, G = b.length; C < G; C++) {
        var A = b[C];
        A.castShadow && (A instanceof THREE.SpotLight && y++, A instanceof THREE.DirectionalLight && !A.shadowCascade && y++)
      }
      x = y;
      var D;
      if (Nb && e && e.skeleton && e.skeleton.useVertexTexture) D = 1024;
      else {
        var H = l.getParameter(l.MAX_VERTEX_UNIFORM_VECTORS),
          L = Math.floor((H - 20) / 4);
        void 0 !== e && e instanceof THREE.SkinnedMesh && (L = Math.min(e.skeleton.bones.length, L), L < e.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + e.skeleton.bones.length + ", this GPU supports just " + L + " (try OpenGL instead of ANGLE)"));
        D = L
      }
      var K = {
          precision: ga,
          supportsVertexTextures: Vb,
          map: !!d.map,
          envMap: !!d.envMap,
          envMapMode: d.envMap && d.envMap.mapping,
          lightMap: !!d.lightMap,
          bumpMap: !!d.bumpMap,
          normalMap: !!d.normalMap,
          specularMap: !!d.specularMap,
          alphaMap: !!d.alphaMap,
          combine: d.combine,
          vertexColors: d.vertexColors,
          fog: c,
          useFog: d.fog,
          fogExp: c instanceof THREE.FogExp2,
          sizeAttenuation: d.sizeAttenuation,
          logarithmicDepthBuffer: X,
          skinning: d.skinning,
          maxBones: D,
          useVertexTexture: Nb && e && e.skeleton && e.skeleton.useVertexTexture,
          morphTargets: d.morphTargets,
          morphNormals: d.morphNormals,
          maxMorphTargets: I.maxMorphTargets,
          maxMorphNormals: I.maxMorphNormals,
          maxDirLights: f,
          maxPointLights: g,
          maxSpotLights: h,
          maxHemiLights: k,
          maxShadows: x,
          shadowMapEnabled: I.shadowMapEnabled && e.receiveShadow && 0 < x,
          shadowMapType: I.shadowMapType,
          shadowMapDebug: I.shadowMapDebug,
          shadowMapCascade: I.shadowMapCascade,
          alphaTest: d.alphaTest,
          metal: d.metal,
          wrapAround: d.wrapAround,
          doubleSided: d.side === THREE.DoubleSide,
          flipSided: d.side === THREE.BackSide
        },
        N = [];
      m ? N.push(m) : (N.push(d.fragmentShader), N.push(d.vertexShader));
      if (void 0 !== d.defines)
        for (var O in d.defines) N.push(O), N.push(d.defines[O]);
      for (O in K) N.push(O), N.push(K[O]);
      for (var W = N.join(), pa, ta = 0, Za = Xa.length; ta < Za; ta++) {
        var Fa = Xa[ta];
        if (Fa.code === W) {
          pa = Fa;
          pa.usedTimes++;
          break
        }
      }
      void 0 === pa && (pa = new THREE.WebGLProgram(I, W, d, K), Xa.push(pa), I.info.memory.programs = Xa.length);
      d.program = pa;
      var Ta = pa.attributes;
      if (d.morphTargets) {
        d.numSupportedMorphTargets = 0;
        for (var aa, Ga = "morphTarget", za = 0; za < I.maxMorphTargets; za++) aa = Ga + za, 0 <= Ta[aa] && d.numSupportedMorphTargets++
      }
      if (d.morphNormals)
        for (d.numSupportedMorphNormals = 0, Ga = "morphNormal", za = 0; za < I.maxMorphNormals; za++) aa = Ga + za, 0 <= Ta[aa] && d.numSupportedMorphNormals++;
      d.uniformsList = [];
      for (var ea in d.__webglShader.uniforms) {
        var tb = d.program.uniforms[ea];
        tb && d.uniformsList.push([d.__webglShader.uniforms[ea], tb])
      }
      d.needsUpdate = !1
    }
    d.morphTargets && !e.__webglMorphTargetInfluences && (e.__webglMorphTargetInfluences = new Float32Array(I.maxMorphTargets));
    var qa = !1,
      eb = !1,
      ya = !1,
      xa = d.program,
      ha = xa.uniforms,
      P = d.__webglShader.uniforms;
    xa.id !== Wb && (l.useProgram(xa.program), Wb = xa.id, ya = eb = qa = !0);
    d.id !== Hb && (-1 === Hb && (ya = !0), Hb = d.id, eb = !0);
    if (qa || a !== Ib) l.uniformMatrix4fv(ha.projectionMatrix, !1, a.projectionMatrix.elements), X && l.uniform1f(ha.logDepthBufFC, 2 / (Math.log(a.far + 1) / Math.LN2)), a !== Ib && (Ib = a), (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null !== ha.cameraPosition && (Da.setFromMatrixPosition(a.matrixWorld), l.uniform3f(ha.cameraPosition, Da.x, Da.y, Da.z)), (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshBasicMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null !== ha.viewMatrix && l.uniformMatrix4fv(ha.viewMatrix, !1, a.matrixWorldInverse.elements);
    if (d.skinning)
      if (e.bindMatrix && null !== ha.bindMatrix && l.uniformMatrix4fv(ha.bindMatrix, !1, e.bindMatrix.elements), e.bindMatrixInverse && null !== ha.bindMatrixInverse && l.uniformMatrix4fv(ha.bindMatrixInverse, !1, e.bindMatrixInverse.elements), Nb && e.skeleton && e.skeleton.useVertexTexture) {
        if (null !== ha.boneTexture) {
          var $a = z();
          l.uniform1i(ha.boneTexture, $a);
          I.setTexture(e.skeleton.boneTexture, $a)
        }
        null !== ha.boneTextureWidth && l.uniform1i(ha.boneTextureWidth, e.skeleton.boneTextureWidth);
        null !== ha.boneTextureHeight && l.uniform1i(ha.boneTextureHeight, e.skeleton.boneTextureHeight)
      } else e.skeleton && e.skeleton.boneMatrices && null !== ha.boneGlobalMatrices && l.uniformMatrix4fv(ha.boneGlobalMatrices, !1, e.skeleton.boneMatrices);
    if (eb) {
      c && d.fog && (P.fogColor.value = c.color, c instanceof THREE.Fog ? (P.fogNear.value = c.near, P.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (P.fogDensity.value = c.density));
      if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {
        if (Ob) {
          var ya = !0,
            fa, fb, Y, Ma = 0,
            Sa = 0,
            Ya = 0,
            Aa, Ha, hb, na, ab, jb, la = nc,
            Na = la.directional.colors,
            Ua = la.directional.positions,
            mb = la.point.colors,
            kb = la.point.positions,
            sb = la.point.distances,
            Va = la.spot.colors,
            Ia = la.spot.positions,
            nb = la.spot.distances,
            Oa = la.spot.directions,
            ia = la.spot.anglesCos,
            ra = la.spot.exponents,
            J = la.hemi.skyColors,
            Ba = la.hemi.groundColors,
            bb = la.hemi.positions,
            wb = 0,
            ob = 0,
            Pa = 0,
            Ca = 0,
            cb = 0,
            Ka = 0,
            La = 0,
            ib = 0,
            xb = 0,
            pb = 0,
            B = 0,
            db = 0;
          fa = 0;
          for (fb = b.length; fa < fb; fa++) Y = b[fa], Y.onlyShadow || (Aa = Y.color, na = Y.intensity, jb = Y.distance, Y instanceof THREE.AmbientLight ? Y.visible && (I.gammaInput ? (Ma += Aa.r * Aa.r, Sa += Aa.g * Aa.g, Ya += Aa.b * Aa.b) : (Ma += Aa.r, Sa += Aa.g, Ya += Aa.b)) : Y instanceof THREE.DirectionalLight ? (cb += 1, Y.visible && (ma.setFromMatrixPosition(Y.matrixWorld), Da.setFromMatrixPosition(Y.target.matrixWorld), ma.sub(Da), ma.normalize(), xb = 3 * wb, Ua[xb] = ma.x, Ua[xb + 1] = ma.y, Ua[xb + 2] = ma.z, I.gammaInput ? E(Na, xb, Aa, na * na) : w(Na, xb, Aa, na), wb += 1)) : Y instanceof THREE.PointLight ? (Ka += 1, Y.visible && (pb = 3 * ob, I.gammaInput ? E(mb, pb, Aa, na * na) : w(mb, pb, Aa, na), Da.setFromMatrixPosition(Y.matrixWorld), kb[pb] = Da.x, kb[pb + 1] = Da.y, kb[pb + 2] = Da.z, sb[ob] = jb, ob += 1)) : Y instanceof THREE.SpotLight ? (La += 1, Y.visible && (B = 3 * Pa, I.gammaInput ? E(Va, B, Aa, na * na) : w(Va, B, Aa, na), ma.setFromMatrixPosition(Y.matrixWorld), Ia[B] = ma.x, Ia[B + 1] = ma.y, Ia[B + 2] = ma.z, nb[Pa] = jb, Da.setFromMatrixPosition(Y.target.matrixWorld), ma.sub(Da), ma.normalize(), Oa[B] = ma.x, Oa[B + 1] = ma.y, Oa[B + 2] = ma.z, ia[Pa] = Math.cos(Y.angle), ra[Pa] = Y.exponent, Pa += 1)) : Y instanceof THREE.HemisphereLight && (ib += 1, Y.visible && (ma.setFromMatrixPosition(Y.matrixWorld), ma.normalize(), db = 3 * Ca, bb[db] = ma.x, bb[db + 1] = ma.y, bb[db + 2] = ma.z, Ha = Y.color, hb = Y.groundColor, I.gammaInput ? (ab = na * na, E(J, db, Ha, ab), E(Ba, db, hb, ab)) : (w(J, db, Ha, na), w(Ba, db, hb, na)), Ca += 1)));
          fa = 3 * wb;
          for (fb = Math.max(Na.length, 3 * cb); fa < fb; fa++) Na[fa] = 0;
          fa = 3 * ob;
          for (fb = Math.max(mb.length, 3 * Ka); fa < fb; fa++) mb[fa] = 0;
          fa = 3 * Pa;
          for (fb = Math.max(Va.length, 3 * La); fa < fb; fa++) Va[fa] = 0;
          fa = 3 * Ca;
          for (fb = Math.max(J.length, 3 * ib); fa < fb; fa++) J[fa] = 0;
          fa = 3 * Ca;
          for (fb = Math.max(Ba.length, 3 * ib); fa < fb; fa++) Ba[fa] = 0;
          la.directional.length = wb;
          la.point.length = ob;
          la.spot.length = Pa;
          la.hemi.length = Ca;
          la.ambient[0] = Ma;
          la.ambient[1] = Sa;
          la.ambient[2] = Ya;
          Ob = !1
        }
        if (ya) {
          var sa = nc;
          P.ambientLightColor.value = sa.ambient;
          P.directionalLightColor.value = sa.directional.colors;
          P.directionalLightDirection.value = sa.directional.positions;
          P.pointLightColor.value = sa.point.colors;
          P.pointLightPosition.value = sa.point.positions;
          P.pointLightDistance.value = sa.point.distances;
          P.spotLightColor.value = sa.spot.colors;
          P.spotLightPosition.value = sa.spot.positions;
          P.spotLightDistance.value = sa.spot.distances;
          P.spotLightDirection.value = sa.spot.directions;
          P.spotLightAngleCos.value = sa.spot.anglesCos;
          P.spotLightExponent.value = sa.spot.exponents;
          P.hemisphereLightSkyColor.value = sa.hemi.skyColors;
          P.hemisphereLightGroundColor.value = sa.hemi.groundColors;
          P.hemisphereLightDirection.value = sa.hemi.positions;
          F(P, !0)
        } else F(P, !1)
      }
      if (d instanceof THREE.MeshBasicMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {
        P.opacity.value = d.opacity;
        I.gammaInput ? P.diffuse.value.copyGammaToLinear(d.color) : P.diffuse.value = d.color;
        P.map.value = d.map;
        P.lightMap.value = d.lightMap;
        P.specularMap.value = d.specularMap;
        P.alphaMap.value = d.alphaMap;
        d.bumpMap && (P.bumpMap.value = d.bumpMap, P.bumpScale.value = d.bumpScale);
        d.normalMap && (P.normalMap.value = d.normalMap, P.normalScale.value.copy(d.normalScale));
        var oa;
        d.map ? oa = d.map : d.specularMap ? oa = d.specularMap : d.normalMap ? oa = d.normalMap : d.bumpMap ? oa = d.bumpMap : d.alphaMap && (oa = d.alphaMap);
        if (void 0 !== oa) {
          var ub = oa.offset,
            zb = oa.repeat;
          P.offsetRepeat.value.set(ub.x, ub.y, zb.x, zb.y)
        }
        P.envMap.value = d.envMap;
        P.flipEnvMap.value = d.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1;
        P.reflectivity.value = d.reflectivity;
        P.refractionRatio.value = d.refractionRatio
      }
      d instanceof THREE.LineBasicMaterial ? (P.diffuse.value = d.color, P.opacity.value = d.opacity) : d instanceof THREE.LineDashedMaterial ? (P.diffuse.value = d.color, P.opacity.value = d.opacity, P.dashSize.value = d.dashSize, P.totalSize.value = d.dashSize + d.gapSize, P.scale.value = d.scale) : d instanceof THREE.PointCloudMaterial ? (P.psColor.value = d.color, P.opacity.value = d.opacity, P.size.value = d.size, P.scale.value = Q.height / 2, P.map.value = d.map) : d instanceof THREE.MeshPhongMaterial ? (P.shininess.value = d.shininess, I.gammaInput ? (P.ambient.value.copyGammaToLinear(d.ambient), P.emissive.value.copyGammaToLinear(d.emissive), P.specular.value.copyGammaToLinear(d.specular)) : (P.ambient.value = d.ambient, P.emissive.value = d.emissive, P.specular.value = d.specular), d.wrapAround && P.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? (I.gammaInput ? (P.ambient.value.copyGammaToLinear(d.ambient), P.emissive.value.copyGammaToLinear(d.emissive)) : (P.ambient.value = d.ambient, P.emissive.value = d.emissive), d.wrapAround && P.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (P.mNear.value = a.near, P.mFar.value = a.far, P.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (P.opacity.value = d.opacity);
      if (e.receiveShadow && !d._shadowPass && P.shadowMatrix)
        for (var Ab = 0, vb = 0, Xb = b.length; vb < Xb; vb++) {
          var lb = b[vb];
          lb.castShadow && (lb instanceof THREE.SpotLight || lb instanceof THREE.DirectionalLight && !lb.shadowCascade) && (P.shadowMap.value[Ab] = lb.shadowMap, P.shadowMapSize.value[Ab] = lb.shadowMapSize, P.shadowMatrix.value[Ab] = lb.shadowMatrix, P.shadowDarkness.value[Ab] = lb.shadowDarkness, P.shadowBias.value[Ab] = lb.shadowBias, Ab++)
        }
      for (var Cb = d.uniformsList, V, Ja, Wa, Db = 0, Pb = Cb.length; Db < Pb; Db++) {
        var $ = Cb[Db][0];
        if (!1 !== $.needsUpdate) {
          var Eb = $.type,
            R = $.value,
            S = Cb[Db][1];
          switch (Eb) {
            case "1i":
              l.uniform1i(S, R);
              break;
            case "1f":
              l.uniform1f(S, R);
              break;
            case "2f":
              l.uniform2f(S, R[0], R[1]);
              break;
            case "3f":
              l.uniform3f(S, R[0], R[1], R[2]);
              break;
            case "4f":
              l.uniform4f(S, R[0], R[1], R[2], R[3]);
              break;
            case "1iv":
              l.uniform1iv(S, R);
              break;
            case "3iv":
              l.uniform3iv(S, R);
              break;
            case "1fv":
              l.uniform1fv(S, R);
              break;
            case "2fv":
              l.uniform2fv(S, R);
              break;
            case "3fv":
              l.uniform3fv(S, R);
              break;
            case "4fv":
              l.uniform4fv(S, R);
              break;
            case "Matrix3fv":
              l.uniformMatrix3fv(S, !1, R);
              break;
            case "Matrix4fv":
              l.uniformMatrix4fv(S, !1, R);
              break;
            case "i":
              l.uniform1i(S, R);
              break;
            case "f":
              l.uniform1f(S, R);
              break;
            case "v2":
              l.uniform2f(S, R.x, R.y);
              break;
            case "v3":
              l.uniform3f(S, R.x, R.y, R.z);
              break;
            case "v4":
              l.uniform4f(S, R.x, R.y, R.z, R.w);
              break;
            case "c":
              l.uniform3f(S, R.r, R.g, R.b);
              break;
            case "iv1":
              l.uniform1iv(S, R);
              break;
            case "iv":
              l.uniform3iv(S, R);
              break;
            case "fv1":
              l.uniform1fv(S, R);
              break;
            case "fv":
              l.uniform3fv(S, R);
              break;
            case "v2v":
              void 0 === $._array && ($._array = new Float32Array(2 * R.length));
              for (var Z = 0, Ea = R.length; Z < Ea; Z++) Wa = 2 * Z, $._array[Wa] = R[Z].x, $._array[Wa + 1] = R[Z].y;
              l.uniform2fv(S, $._array);
              break;
            case "v3v":
              void 0 === $._array && ($._array = new Float32Array(3 * R.length));
              Z = 0;
              for (Ea = R.length; Z < Ea; Z++) Wa = 3 * Z, $._array[Wa] = R[Z].x, $._array[Wa + 1] = R[Z].y, $._array[Wa + 2] = R[Z].z;
              l.uniform3fv(S, $._array);
              break;
            case "v4v":
              void 0 === $._array && ($._array = new Float32Array(4 * R.length));
              Z = 0;
              for (Ea = R.length; Z < Ea; Z++) Wa = 4 * Z, $._array[Wa] = R[Z].x, $._array[Wa + 1] = R[Z].y, $._array[Wa + 2] = R[Z].z, $._array[Wa + 3] = R[Z].w;
              l.uniform4fv(S, $._array);
              break;
            case "m3":
              l.uniformMatrix3fv(S, !1, R.elements);
              break;
            case "m3v":
              void 0 === $._array && ($._array = new Float32Array(9 * R.length));
              Z = 0;
              for (Ea = R.length; Z < Ea; Z++) R[Z].flattenToArrayOffset($._array, 9 * Z);
              l.uniformMatrix3fv(S, !1, $._array);
              break;
            case "m4":
              l.uniformMatrix4fv(S, !1, R.elements);
              break;
            case "m4v":
              void 0 === $._array && ($._array = new Float32Array(16 * R.length));
              Z = 0;
              for (Ea = R.length; Z < Ea; Z++) R[Z].flattenToArrayOffset($._array, 16 * Z);
              l.uniformMatrix4fv(S, !1, $._array);
              break;
            case "t":
              V = R;
              Ja = z();
              l.uniform1i(S, Ja);
              if (!V) continue;
              if (V instanceof THREE.CubeTexture || V.image instanceof Array && 6 === V.image.length) {
                var ka = V,
                  Bb = Ja;
                if (6 === ka.image.length)
                  if (ka.needsUpdate) {
                    ka.image.__webglTextureCube || (ka.addEventListener("dispose", Jb), ka.image.__webglTextureCube = l.createTexture(), I.info.memory.textures++);
                    l.activeTexture(l.TEXTURE0 + Bb);
                    l.bindTexture(l.TEXTURE_CUBE_MAP, ka.image.__webglTextureCube);
                    l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL, ka.flipY);
                    for (var Fb = ka instanceof THREE.CompressedTexture, ba = ka.image[0] instanceof THREE.DataTexture, gb = [], ua = 0; 6 > ua; ua++) gb[ua] = !I.autoScaleCubemaps || Fb || ba ? ba ? ka.image[ua].image : ka.image[ua] : M(ka.image[ua], Ec);
                    var Qb = gb[0],
                      Rb = THREE.Math.isPowerOfTwo(Qb.width) && THREE.Math.isPowerOfTwo(Qb.height),
                      qb = T(ka.format),
                      Sb = T(ka.type);
                    U(l.TEXTURE_CUBE_MAP, ka, Rb);
                    for (ua = 0; 6 > ua; ua++)
                      if (Fb)
                        for (var yb, Gb = gb[ua].mipmaps, rb = 0, Yb = Gb.length; rb < Yb; rb++) yb = Gb[rb], ka.format !== THREE.RGBAFormat && ka.format !== THREE.RGBFormat ? -1 < oc().indexOf(qb) ? l.compressedTexImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ua, rb, qb, yb.width, yb.height, 0, yb.data) : console.warn("Attempt to load unsupported compressed texture format") : l.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ua, rb, qb, yb.width, yb.height, 0, qb, Sb, yb.data);
                      else ba ? l.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ua, 0, qb, gb[ua].width, gb[ua].height, 0, qb, Sb, gb[ua].data) : l.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + ua, 0, qb, qb, Sb, gb[ua]);
                    ka.generateMipmaps && Rb && l.generateMipmap(l.TEXTURE_CUBE_MAP);
                    ka.needsUpdate = !1;
                    if (ka.onUpdate) ka.onUpdate()
                  } else l.activeTexture(l.TEXTURE0 + Bb), l.bindTexture(l.TEXTURE_CUBE_MAP, ka.image.__webglTextureCube)
              } else if (V instanceof THREE.WebGLRenderTargetCube) {
                var Zb = V;
                l.activeTexture(l.TEXTURE0 + Ja);
                l.bindTexture(l.TEXTURE_CUBE_MAP, Zb.__webglTexture)
              } else I.setTexture(V, Ja);
              break;
            case "tv":
              void 0 === $._array && ($._array = []);
              Z = 0;
              for (Ea = $.value.length; Z < Ea; Z++) $._array[Z] = z();
              l.uniform1iv(S, $._array);
              Z = 0;
              for (Ea = $.value.length; Z < Ea; Z++) V = $.value[Z], Ja = $._array[Z], V && I.setTexture(V, Ja);
              break;
            default:
              console.warn("THREE.WebGLRenderer: Unknown uniform type: " + Eb)
          }
        }
      }
    }
    l.uniformMatrix4fv(ha.modelViewMatrix, !1, e._modelViewMatrix.elements);
    ha.normalMatrix && l.uniformMatrix3fv(ha.normalMatrix, !1, e._normalMatrix.elements);
    null !== ha.modelMatrix && l.uniformMatrix4fv(ha.modelMatrix, !1, e.matrixWorld.elements);
    return xa
  }

  function F(a, b) {
    a.ambientLightColor.needsUpdate = b;
    a.directionalLightColor.needsUpdate = b;
    a.directionalLightDirection.needsUpdate = b;
    a.pointLightColor.needsUpdate = b;
    a.pointLightPosition.needsUpdate = b;
    a.pointLightDistance.needsUpdate = b;
    a.spotLightColor.needsUpdate = b;
    a.spotLightPosition.needsUpdate = b;
    a.spotLightDistance.needsUpdate = b;
    a.spotLightDirection.needsUpdate = b;
    a.spotLightAngleCos.needsUpdate = b;
    a.spotLightExponent.needsUpdate = b;
    a.hemisphereLightSkyColor.needsUpdate = b;
    a.hemisphereLightGroundColor.needsUpdate = b;
    a.hemisphereLightDirection.needsUpdate = b
  }

  function z() {
    var a = Mb;
    a >= pc && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + pc);
    Mb += 1;
    return a
  }

  function G(a, b) {
    a._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, a.matrixWorld);
    a._normalMatrix.getNormalMatrix(a._modelViewMatrix)
  }

  function E(a, b, c, d) {
    a[b] = c.r * c.r * d;
    a[b + 1] = c.g * c.g * d;
    a[b + 2] = c.b * c.b * d
  }

  function w(a, b, c, d) {
    a[b] = c.r * d;
    a[b + 1] = c.g * d;
    a[b + 2] = c.b * d
  }

  function D(a) {
    a *= O;
    a !== qc && (l.lineWidth(a), qc = a)
  }

  function A(a, b, c) {
    rc !== a && (a ? l.enable(l.POLYGON_OFFSET_FILL) : l.disable(l.POLYGON_OFFSET_FILL), rc = a);
    !a || sc === b && tc === c || (l.polygonOffset(b, c), sc = b, tc = c)
  }

  function U(a, b, c) {
    c ? (l.texParameteri(a, l.TEXTURE_WRAP_S, T(b.wrapS)), l.texParameteri(a, l.TEXTURE_WRAP_T, T(b.wrapT)), l.texParameteri(a, l.TEXTURE_MAG_FILTER, T(b.magFilter)), l.texParameteri(a, l.TEXTURE_MIN_FILTER, T(b.minFilter))) : (l.texParameteri(a, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(a, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), b.wrapS === THREE.ClampToEdgeWrapping && b.wrapT === THREE.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT is set to THREE.ClampToEdgeWrapping. ( " + b.sourceFile + " )"), l.texParameteri(a, l.TEXTURE_MAG_FILTER, N(b.magFilter)), l.texParameteri(a, l.TEXTURE_MIN_FILTER, N(b.minFilter)), b.minFilter !== THREE.NearestFilter && b.minFilter !== THREE.LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter is set to THREE.LinearFilter or THREE.NearestFilter. ( " + b.sourceFile + " )"));
    (c = aa.get("EXT_texture_filter_anisotropic")) && b.type !== THREE.FloatType && (1 < b.anisotropy || b.__oldAnisotropy) && (l.texParameterf(a, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, I.getMaxAnisotropy())), b.__oldAnisotropy = b.anisotropy)
  }

  function M(a, b) {
    if (a.width > b || a.height > b) {
      var c = b / Math.max(a.width, a.height),
        d = document.createElement("canvas");
      d.width = Math.floor(a.width * c);
      d.height = Math.floor(a.height * c);
      d.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height);
      console.log("THREE.WebGLRenderer:", a, "is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height + ".");
      return d
    }
    return a
  }

  function K(a, b) {
    l.bindRenderbuffer(l.RENDERBUFFER, a);
    b.depthBuffer && !b.stencilBuffer ? (l.renderbufferStorage(l.RENDERBUFFER, l.DEPTH_COMPONENT16, b.width, b.height), l.framebufferRenderbuffer(l.FRAMEBUFFER, l.DEPTH_ATTACHMENT, l.RENDERBUFFER, a)) : b.depthBuffer && b.stencilBuffer ? (l.renderbufferStorage(l.RENDERBUFFER, l.DEPTH_STENCIL, b.width, b.height), l.framebufferRenderbuffer(l.FRAMEBUFFER, l.DEPTH_STENCIL_ATTACHMENT, l.RENDERBUFFER, a)) : l.renderbufferStorage(l.RENDERBUFFER, l.RGBA4, b.width, b.height)
  }

  function L(a) {
    a instanceof THREE.WebGLRenderTargetCube ? (l.bindTexture(l.TEXTURE_CUBE_MAP, a.__webglTexture), l.generateMipmap(l.TEXTURE_CUBE_MAP), l.bindTexture(l.TEXTURE_CUBE_MAP, null)) : (l.bindTexture(l.TEXTURE_2D, a.__webglTexture), l.generateMipmap(l.TEXTURE_2D), l.bindTexture(l.TEXTURE_2D, null))
  }

  function N(a) {
    return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? l.NEAREST : l.LINEAR
  }

  function T(a) {
    var b;
    if (a === THREE.RepeatWrapping) return l.REPEAT;
    if (a === THREE.ClampToEdgeWrapping) return l.CLAMP_TO_EDGE;
    if (a === THREE.MirroredRepeatWrapping) return l.MIRRORED_REPEAT;
    if (a === THREE.NearestFilter) return l.NEAREST;
    if (a === THREE.NearestMipMapNearestFilter) return l.NEAREST_MIPMAP_NEAREST;
    if (a === THREE.NearestMipMapLinearFilter) return l.NEAREST_MIPMAP_LINEAR;
    if (a === THREE.LinearFilter) return l.LINEAR;
    if (a === THREE.LinearMipMapNearestFilter) return l.LINEAR_MIPMAP_NEAREST;
    if (a === THREE.LinearMipMapLinearFilter) return l.LINEAR_MIPMAP_LINEAR;
    if (a === THREE.UnsignedByteType) return l.UNSIGNED_BYTE;
    if (a === THREE.UnsignedShort4444Type) return l.UNSIGNED_SHORT_4_4_4_4;
    if (a === THREE.UnsignedShort5551Type) return l.UNSIGNED_SHORT_5_5_5_1;
    if (a === THREE.UnsignedShort565Type) return l.UNSIGNED_SHORT_5_6_5;
    if (a === THREE.ByteType) return l.BYTE;
    if (a === THREE.ShortType) return l.SHORT;
    if (a === THREE.UnsignedShortType) return l.UNSIGNED_SHORT;
    if (a === THREE.IntType) return l.INT;
    if (a === THREE.UnsignedIntType) return l.UNSIGNED_INT;
    if (a === THREE.FloatType) return l.FLOAT;
    if (a === THREE.AlphaFormat) return l.ALPHA;
    if (a === THREE.RGBFormat) return l.RGB;
    if (a === THREE.RGBAFormat) return l.RGBA;
    if (a === THREE.LuminanceFormat) return l.LUMINANCE;
    if (a === THREE.LuminanceAlphaFormat) return l.LUMINANCE_ALPHA;
    if (a === THREE.AddEquation) return l.FUNC_ADD;
    if (a === THREE.SubtractEquation) return l.FUNC_SUBTRACT;
    if (a === THREE.ReverseSubtractEquation) return l.FUNC_REVERSE_SUBTRACT;
    if (a === THREE.ZeroFactor) return l.ZERO;
    if (a === THREE.OneFactor) return l.ONE;
    if (a === THREE.SrcColorFactor) return l.SRC_COLOR;
    if (a === THREE.OneMinusSrcColorFactor) return l.ONE_MINUS_SRC_COLOR;
    if (a === THREE.SrcAlphaFactor) return l.SRC_ALPHA;
    if (a === THREE.OneMinusSrcAlphaFactor) return l.ONE_MINUS_SRC_ALPHA;
    if (a === THREE.DstAlphaFactor) return l.DST_ALPHA;
    if (a === THREE.OneMinusDstAlphaFactor) return l.ONE_MINUS_DST_ALPHA;
    if (a === THREE.DstColorFactor) return l.DST_COLOR;
    if (a === THREE.OneMinusDstColorFactor) return l.ONE_MINUS_DST_COLOR;
    if (a === THREE.SrcAlphaSaturateFactor) return l.SRC_ALPHA_SATURATE;
    b = aa.get("WEBGL_compressed_texture_s3tc");
    if (null !== b) {
      if (a === THREE.RGB_S3TC_DXT1_Format) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (a === THREE.RGBA_S3TC_DXT1_Format) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (a === THREE.RGBA_S3TC_DXT3_Format) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (a === THREE.RGBA_S3TC_DXT5_Format) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
    }
    b = aa.get("WEBGL_compressed_texture_pvrtc");
    if (null !== b) {
      if (a === THREE.RGB_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (a === THREE.RGB_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (a === THREE.RGBA_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (a === THREE.RGBA_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
    }
    b = aa.get("EXT_blend_minmax");
    if (null !== b) {
      if (a === THREE.MinEquation) return b.MIN_EXT;
      if (a === THREE.MaxEquation) return b.MAX_EXT
    }
    return 0
  }
  console.log("THREE.WebGLRenderer", THREE.REVISION);
  a = a || {};
  var Q = void 0 !== a.canvas ? a.canvas : document.createElement("canvas"),
    W = void 0 !== a.context ? a.context : null,
    O = 1,
    ga = void 0 !== a.precision ? a.precision : "highp",
    ea = void 0 !== a.alpha ? a.alpha : !1,
    xa = void 0 !== a.depth ? a.depth : !0,
    H = void 0 !== a.stencil ? a.stencil : !0,
    $a = void 0 !== a.antialias ? a.antialias : !1,
    qa = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
    ya = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
    X = void 0 !== a.logarithmicDepthBuffer ? a.logarithmicDepthBuffer : !1,
    ta = new THREE.Color(0),
    Za = 0,
    pa = [],
    Fa = {},
    Ga = [],
    Ta = [],
    za = [],
    tb = [],
    eb = [];
  this.domElement = Q;
  this.context = null;
  this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
  this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1;
  this.shadowMapType = THREE.PCFShadowMap;
  this.shadowMapCullFace = THREE.CullFaceFront;
  this.shadowMapCascade = this.shadowMapDebug = !1;
  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;
  this.autoScaleCubemaps = !0;
  this.info = {
    memory: {
      programs: 0,
      geometries: 0,
      textures: 0
    },
    render: {
      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0
    }
  };
  var I = this,
    Xa = [],
    Wb = null,
    uc = null,
    Hb = -1,
    Sa = "",
    Ib = null,
    Mb = 0,
    zb = -1,
    Xb = -1,
    Yb = -1,
    Zb = -1,
    ec = -1,
    fc = -1,
    gc = -1,
    hc = -1,
    rc = null,
    sc = null,
    tc = null,
    qc = null,
    hb = 0,
    Ya = 0,
    ib = Q.width,
    jb = Q.height,
    vc = 0,
    wc = 0,
    kb = new Uint8Array(16),
    Ma = new Uint8Array(16),
    ub = new THREE.Frustum,
    vb = new THREE.Matrix4;
  new THREE.Matrix4;
  var Da = new THREE.Vector3,
    ma = new THREE.Vector3,
    Ob = !0,
    nc = {
      ambient: [0, 0, 0],
      directional: {
        length: 0,
        colors: [],
        positions: []
      },
      point: {
        length: 0,
        colors: [],
        positions: [],
        distances: []
      },
      spot: {
        length: 0,
        colors: [],
        positions: [],
        distances: [],
        directions: [],
        anglesCos: [],
        exponents: []
      },
      hemi: {
        length: 0,
        skyColors: [],
        groundColors: [],
        positions: []
      }
    },
    l;
  try {
    var xc = {
      alpha: ea,
      depth: xa,
      stencil: H,
      antialias: $a,
      premultipliedAlpha: qa,
      preserveDrawingBuffer: ya
    };
    l = W || Q.getContext("webgl", xc) || Q.getContext("experimental-webgl", xc);
    if (null === l) {
      if (null !== Q.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
      throw "Error creating WebGL context.";
    }
    Q.addEventListener("webglcontextlost", function(a) {
      a.preventDefault();
      yc();
      zc();
      Fa = {}
    }, !1)
  } catch (Fc) {
    console.error(Fc)
  }
  void 0 === l.getShaderPrecisionFormat && (l.getShaderPrecisionFormat = function() {
    return {
      rangeMin: 1,
      rangeMax: 1,
      precision: 1
    }
  });
  var aa = new THREE.WebGLExtensions(l);
  aa.get("OES_texture_float");
  aa.get("OES_texture_float_linear");
  aa.get("OES_standard_derivatives");
  X && aa.get("EXT_frag_depth");
  var zc = function() {
      l.clearColor(0, 0, 0, 1);
      l.clearDepth(1);
      l.clearStencil(0);
      l.enable(l.DEPTH_TEST);
      l.depthFunc(l.LEQUAL);
      l.frontFace(l.CCW);
      l.cullFace(l.BACK);
      l.enable(l.CULL_FACE);
      l.enable(l.BLEND);
      l.blendEquation(l.FUNC_ADD);
      l.blendFunc(l.SRC_ALPHA, l.ONE_MINUS_SRC_ALPHA);
      l.viewport(hb, Ya, ib, jb);
      l.clearColor(ta.r, ta.g, ta.b, Za)
    },
    yc = function() {
      Ib = Wb = null;
      Xb = zb = hc = gc = Yb = -1;
      Sa = "";
      Hb = -1;
      Ob = !0;
      for (var a = 0; a < Ma.length; a++) Ma[a] = 0
    };
  zc();
  this.context = l;
  var pc = l.getParameter(l.MAX_TEXTURE_IMAGE_UNITS),
    Gc = l.getParameter(l.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    Hc = l.getParameter(l.MAX_TEXTURE_SIZE),
    Ec = l.getParameter(l.MAX_CUBE_MAP_TEXTURE_SIZE),
    Vb = 0 < Gc,
    Nb = Vb && aa.get("OES_texture_float"),
    Ic = l.getShaderPrecisionFormat(l.VERTEX_SHADER, l.HIGH_FLOAT),
    Jc = l.getShaderPrecisionFormat(l.VERTEX_SHADER, l.MEDIUM_FLOAT);
  l.getShaderPrecisionFormat(l.VERTEX_SHADER, l.LOW_FLOAT);
  var Kc = l.getShaderPrecisionFormat(l.FRAGMENT_SHADER, l.HIGH_FLOAT),
    Lc = l.getShaderPrecisionFormat(l.FRAGMENT_SHADER, l.MEDIUM_FLOAT);
  l.getShaderPrecisionFormat(l.FRAGMENT_SHADER, l.LOW_FLOAT);
  var oc = function() {
      var a;
      return function() {
        if (void 0 !== a) return a;
        a = [];
        if (aa.get("WEBGL_compressed_texture_pvrtc") || aa.get("WEBGL_compressed_texture_s3tc"))
          for (var b = l.getParameter(l.COMPRESSED_TEXTURE_FORMATS), c = 0; c < b.length; c++) a.push(b[c]);
        return a
      }
    }(),
    Mc = 0 < Ic.precision && 0 < Kc.precision,
    Ac = 0 < Jc.precision && 0 < Lc.precision;
  "highp" !== ga || Mc || (Ac ? (ga = "mediump", console.warn("THREE.WebGLRenderer: highp not supported, using mediump.")) : (ga = "lowp", console.warn("THREE.WebGLRenderer: highp and mediump not supported, using lowp.")));
  "mediump" !== ga || Ac || (ga = "lowp", console.warn("THREE.WebGLRenderer: mediump not supported, using lowp."));
  var Nc = new THREE.ShadowMapPlugin(this, pa, Fa, Ga),
    Oc = new THREE.SpritePlugin(this, tb),
    Pc = new THREE.LensFlarePlugin(this, eb);
  this.getContext = function() {
    return l
  };
  this.forceContextLoss = function() {
    aa.get("WEBGL_lose_context").loseContext()
  };
  this.supportsVertexTextures = function() {
    return Vb
  };
  this.supportsFloatTextures = function() {
    return aa.get("OES_texture_float")
  };
  this.supportsStandardDerivatives = function() {
    return aa.get("OES_standard_derivatives")
  };
  this.supportsCompressedTextureS3TC = function() {
    return aa.get("WEBGL_compressed_texture_s3tc")
  };
  this.supportsCompressedTexturePVRTC = function() {
    return aa.get("WEBGL_compressed_texture_pvrtc")
  };
  this.supportsBlendMinMax = function() {
    return aa.get("EXT_blend_minmax")
  };
  this.getMaxAnisotropy = function() {
    var a;
    return function() {
      if (void 0 !== a) return a;
      var b = aa.get("EXT_texture_filter_anisotropic");
      return a = null !== b ? l.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
    }
  }();
  this.getPrecision = function() {
    return ga
  };
  this.getPixelRatio = function() {
    return O
  };
  this.setPixelRatio = function(a) {
    O = a
  };
  this.setSize = function(a, b, c) {
    Q.width = a * O;
    Q.height = b * O;
    !1 !== c && (Q.style.width = a + "px", Q.style.height = b + "px");
    this.setViewport(0, 0, a, b)
  };
  this.setViewport = function(a, b, c, d) {
    hb = a * O;
    Ya = b * O;
    ib = c * O;
    jb = d * O;
    l.viewport(hb, Ya, ib, jb)
  };
  this.setScissor = function(a, b, c, d) {
    l.scissor(a * O, b * O, c * O, d * O)
  };
  this.enableScissorTest = function(a) {
    a ? l.enable(l.SCISSOR_TEST) : l.disable(l.SCISSOR_TEST)
  };
  this.getClearColor = function() {
    return ta
  };
  this.setClearColor = function(a, b) {
    ta.set(a);
    Za = void 0 !== b ? b : 1;
    l.clearColor(ta.r, ta.g, ta.b, Za)
  };
  this.getClearAlpha = function() {
    return Za
  };
  this.setClearAlpha = function(a) {
    Za = a;
    l.clearColor(ta.r, ta.g, ta.b, Za)
  };
  this.clear = function(a, b, c) {
    var d = 0;
    if (void 0 === a || a) d |= l.COLOR_BUFFER_BIT;
    if (void 0 === b || b) d |= l.DEPTH_BUFFER_BIT;
    if (void 0 === c || c) d |= l.STENCIL_BUFFER_BIT;
    l.clear(d)
  };
  this.clearColor = function() {
    l.clear(l.COLOR_BUFFER_BIT)
  };
  this.clearDepth = function() {
    l.clear(l.DEPTH_BUFFER_BIT)
  };
  this.clearStencil = function() {
    l.clear(l.STENCIL_BUFFER_BIT)
  };
  this.clearTarget = function(a, b, c, d) {
    this.setRenderTarget(a);
    this.clear(b, c, d)
  };
  this.resetGLState = yc;
  var ic = function(a) {
      a.target.traverse(function(a) {
        a.removeEventListener("remove", ic);
        if (a instanceof THREE.Mesh || a instanceof THREE.PointCloud || a instanceof THREE.Line) delete Fa[a.id];
        else if (a instanceof THREE.ImmediateRenderObject || a.immediateRenderCallback)
          for (var b = Ga, c = b.length - 1; 0 <= c; c--) b[c].object === a && b.splice(c, 1);
        delete a.__webglInit;
        delete a._modelViewMatrix;
        delete a._normalMatrix;
        delete a.__webglActive
      })
    },
    jc = function(a) {
      a = a.target;
      a.removeEventListener("dispose", jc);
      delete a.__webglInit;
      if (a instanceof THREE.BufferGeometry) {
        for (var b in a.attributes) {
          var c = a.attributes[b];
          void 0 !== c.buffer && (l.deleteBuffer(c.buffer), delete c.buffer)
        }
        I.info.memory.geometries--
      } else if (b = sb[a.id], void 0 !== b) {
        for (var c = 0, d = b.length; c < d; c++) {
          var e = b[c];
          if (void 0 !== e.numMorphTargets) {
            for (var f = 0, g = e.numMorphTargets; f < g; f++) l.deleteBuffer(e.__webglMorphTargetsBuffers[f]);
            delete e.__webglMorphTargetsBuffers
          }
          if (void 0 !== e.numMorphNormals) {
            f = 0;
            for (g = e.numMorphNormals; f < g; f++) l.deleteBuffer(e.__webglMorphNormalsBuffers[f]);
            delete e.__webglMorphNormalsBuffers
          }
          Bc(e)
        }
        delete sb[a.id]
      } else Bc(a);
      Sa = ""
    },
    Jb = function(a) {
      a = a.target;
      a.removeEventListener("dispose", Jb);
      a.image && a.image.__webglTextureCube ? (l.deleteTexture(a.image.__webglTextureCube), delete a.image.__webglTextureCube) : void 0 !== a.__webglInit && (l.deleteTexture(a.__webglTexture), delete a.__webglTexture, delete a.__webglInit);
      I.info.memory.textures--
    },
    Cc = function(a) {
      a = a.target;
      a.removeEventListener("dispose", Cc);
      if (a && void 0 !== a.__webglTexture) {
        l.deleteTexture(a.__webglTexture);
        delete a.__webglTexture;
        if (a instanceof THREE.WebGLRenderTargetCube)
          for (var b = 0; 6 > b; b++) l.deleteFramebuffer(a.__webglFramebuffer[b]), l.deleteRenderbuffer(a.__webglRenderbuffer[b]);
        else l.deleteFramebuffer(a.__webglFramebuffer), l.deleteRenderbuffer(a.__webglRenderbuffer);
        delete a.__webglFramebuffer;
        delete a.__webglRenderbuffer
      }
      I.info.memory.textures--
    },
    mc = function(a) {
      a = a.target;
      a.removeEventListener("dispose", mc);
      lc(a)
    },
    Bc = function(a) {
      for (var b = "__webglVertexBuffer __webglNormalBuffer __webglTangentBuffer __webglColorBuffer __webglUVBuffer __webglUV2Buffer __webglSkinIndicesBuffer __webglSkinWeightsBuffer __webglFaceBuffer __webglLineBuffer __webglLineDistanceBuffer".split(" "), c = 0, d = b.length; c < d; c++) {
        var e = b[c];
        void 0 !== a[e] && (l.deleteBuffer(a[e]), delete a[e])
      }
      if (void 0 !== a.__webglCustomAttributesList) {
        for (e in a.__webglCustomAttributesList) l.deleteBuffer(a.__webglCustomAttributesList[e].buffer);
        delete a.__webglCustomAttributesList
      }
      I.info.memory.geometries--
    },
    lc = function(a) {
      var b = a.program.program;
      if (void 0 !== b) {
        a.program = void 0;
        var c, d, e = !1;
        a = 0;
        for (c = Xa.length; a < c; a++)
          if (d = Xa[a], d.program === b) {
            d.usedTimes--;
            0 === d.usedTimes && (e = !0);
            break
          }
        if (!0 === e) {
          e = [];
          a = 0;
          for (c = Xa.length; a < c; a++) d = Xa[a], d.program !== b && e.push(d);
          Xa = e;
          l.deleteProgram(b);
          I.info.memory.programs--
        }
      }
    };
  this.renderBufferImmediate = function(a, b, c) {
    f();
    a.hasPositions && !a.__webglVertexBuffer && (a.__webglVertexBuffer = l.createBuffer());
    a.hasNormals && !a.__webglNormalBuffer && (a.__webglNormalBuffer = l.createBuffer());
    a.hasUvs && !a.__webglUvBuffer && (a.__webglUvBuffer = l.createBuffer());
    a.hasColors && !a.__webglColorBuffer && (a.__webglColorBuffer = l.createBuffer());
    a.hasPositions && (l.bindBuffer(l.ARRAY_BUFFER, a.__webglVertexBuffer), l.bufferData(l.ARRAY_BUFFER, a.positionArray, l.DYNAMIC_DRAW), g(b.attributes.position), l.vertexAttribPointer(b.attributes.position, 3, l.FLOAT, !1, 0, 0));
    if (a.hasNormals) {
      l.bindBuffer(l.ARRAY_BUFFER, a.__webglNormalBuffer);
      if (c.shading === THREE.FlatShading) {
        var d, e, k, m, n, p, q, r, t, s, v, u = 3 * a.count;
        for (v = 0; v < u; v += 9) s = a.normalArray, d = s[v], e = s[v + 1], k = s[v + 2], m = s[v + 3], p = s[v + 4], r = s[v + 5], n = s[v + 6], q = s[v + 7], t = s[v + 8], d = (d + m + n) / 3, e = (e + p + q) / 3, k = (k + r + t) / 3, s[v] = d, s[v + 1] = e, s[v + 2] = k, s[v + 3] = d, s[v + 4] = e, s[v + 5] = k, s[v + 6] = d, s[v + 7] = e, s[v + 8] = k
      }
      l.bufferData(l.ARRAY_BUFFER, a.normalArray, l.DYNAMIC_DRAW);
      g(b.attributes.normal);
      l.vertexAttribPointer(b.attributes.normal, 3, l.FLOAT, !1, 0, 0)
    }
    a.hasUvs && c.map && (l.bindBuffer(l.ARRAY_BUFFER, a.__webglUvBuffer), l.bufferData(l.ARRAY_BUFFER, a.uvArray, l.DYNAMIC_DRAW), g(b.attributes.uv), l.vertexAttribPointer(b.attributes.uv, 2, l.FLOAT, !1, 0, 0));
    a.hasColors && c.vertexColors !== THREE.NoColors && (l.bindBuffer(l.ARRAY_BUFFER, a.__webglColorBuffer), l.bufferData(l.ARRAY_BUFFER, a.colorArray, l.DYNAMIC_DRAW), g(b.attributes.color), l.vertexAttribPointer(b.attributes.color, 3, l.FLOAT, !1, 0, 0));
    h();
    l.drawArrays(l.TRIANGLES, 0, a.count);
    a.count = 0
  };
  this.renderBufferDirect = function(a, b, c, d, g, h) {
    if (!1 !== d.visible)
      if (v(h), a = x(a, b, c, d, h), b = !1, c = "direct_" + g.id + "_" + a.id + "_" + (d.wireframe ? 1 : 0), c !== Sa && (Sa = c, b = !0), b && f(), h instanceof THREE.Mesh) {
        h = !0 === d.wireframe ? l.LINES : l.TRIANGLES;
        var k = g.attributes.index;
        if (k) {
          var m, n;
          k.array instanceof Uint32Array && aa.get("OES_element_index_uint") ? (m = l.UNSIGNED_INT, n = 4) : (m = l.UNSIGNED_SHORT, n = 2);
          c = g.offsets;
          if (0 === c.length) b && (e(d, a, g, 0), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, k.buffer)), l.drawElements(h, k.array.length, m, 0), I.info.render.calls++, I.info.render.vertices += k.array.length, I.info.render.faces += k.array.length / 3;
          else {
            b = !0;
            for (var p = 0, q = c.length; p < q; p++) {
              var s = c[p].index;
              b && (e(d, a, g, s), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, k.buffer));
              l.drawElements(h, c[p].count, m, c[p].start * n);
              I.info.render.calls++;
              I.info.render.vertices += c[p].count;
              I.info.render.faces += c[p].count / 3
            }
          }
        } else b && e(d, a, g, 0), d = g.attributes.position, l.drawArrays(h, 0, d.array.length / 3), I.info.render.calls++, I.info.render.vertices += d.array.length / 3, I.info.render.faces += d.array.length / 9
      } else if (h instanceof THREE.PointCloud)
      if (h = l.POINTS, k = g.attributes.index)
        if (k.array instanceof Uint32Array && aa.get("OES_element_index_uint") ? (m = l.UNSIGNED_INT, n = 4) : (m = l.UNSIGNED_SHORT, n = 2), c = g.offsets, 0 === c.length) b && (e(d, a, g, 0), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, k.buffer)), l.drawElements(h, k.array.length, m, 0), I.info.render.calls++, I.info.render.points += k.array.length;
        else
          for (1 < c.length && (b = !0), p = 0, q = c.length; p < q; p++) s = c[p].index, b && (e(d, a, g, s), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, k.buffer)), l.drawElements(h, c[p].count, m, c[p].start * n), I.info.render.calls++, I.info.render.points += c[p].count;
    else if (b && e(d, a, g, 0), d = g.attributes.position, c = g.offsets, 0 === c.length) l.drawArrays(h, 0, d.array.length / 3), I.info.render.calls++, I.info.render.points += d.array.length / 3;
    else
      for (p = 0, q = c.length; p < q; p++) l.drawArrays(h, c[p].index, c[p].count), I.info.render.calls++, I.info.render.points += c[p].count;
    else if (h instanceof THREE.Line)
      if (h = h.mode === THREE.LineStrip ? l.LINE_STRIP : l.LINES, D(d.linewidth), k = g.attributes.index)
        if (k.array instanceof Uint32Array ? (m = l.UNSIGNED_INT, n = 4) : (m = l.UNSIGNED_SHORT, n = 2), c = g.offsets, 0 === c.length) b && (e(d, a, g, 0), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, k.buffer)), l.drawElements(h, k.array.length, m, 0), I.info.render.calls++, I.info.render.vertices += k.array.length;
        else
          for (1 < c.length && (b = !0), p = 0, q = c.length; p < q; p++) s = c[p].index, b && (e(d, a, g, s), l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, k.buffer)), l.drawElements(h, c[p].count, m, c[p].start * n), I.info.render.calls++, I.info.render.vertices += c[p].count;
    else if (b && e(d, a, g, 0), d = g.attributes.position, c = g.offsets, 0 === c.length) l.drawArrays(h, 0, d.array.length / 3), I.info.render.calls++, I.info.render.vertices += d.array.length / 3;
    else
      for (p = 0, q = c.length; p < q; p++) l.drawArrays(h, c[p].index, c[p].count), I.info.render.calls++, I.info.render.vertices += c[p].count
  };
  this.renderBuffer = function(a, b, c, d, e, k) {
    if (!1 !== d.visible) {
      v(k);
      c = x(a, b, c, d, k);
      b = c.attributes;
      a = !1;
      c = e.id + "_" + c.id + "_" + (d.wireframe ? 1 : 0);
      c !== Sa && (Sa = c, a = !0);
      a && f();
      if (!d.morphTargets && 0 <= b.position) a && (l.bindBuffer(l.ARRAY_BUFFER, e.__webglVertexBuffer), g(b.position), l.vertexAttribPointer(b.position, 3, l.FLOAT, !1, 0, 0));
      else if (k.morphTargetBase) {
        c = d.program.attributes; - 1 !== k.morphTargetBase && 0 <= c.position ? (l.bindBuffer(l.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[k.morphTargetBase]), g(c.position), l.vertexAttribPointer(c.position, 3, l.FLOAT, !1, 0, 0)) : 0 <= c.position && (l.bindBuffer(l.ARRAY_BUFFER, e.__webglVertexBuffer), g(c.position), l.vertexAttribPointer(c.position, 3, l.FLOAT, !1, 0, 0));
        if (k.morphTargetForcedOrder.length)
          for (var m = 0, n = k.morphTargetForcedOrder, q = k.morphTargetInfluences, s; m < d.numSupportedMorphTargets && m < n.length;) s = c["morphTarget" + m], 0 <= s && (l.bindBuffer(l.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[n[m]]), g(s), l.vertexAttribPointer(s, 3, l.FLOAT, !1, 0, 0)), s = c["morphNormal" + m], 0 <= s && d.morphNormals && (l.bindBuffer(l.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[n[m]]), g(s), l.vertexAttribPointer(s, 3, l.FLOAT, !1, 0, 0)), k.__webglMorphTargetInfluences[m] = q[n[m]], m++;
        else {
          n = [];
          q = k.morphTargetInfluences;
          m = 0;
          for (s = q.length; m < s; m++) n.push([q[m], m]);
          n.length > d.numSupportedMorphTargets ? (n.sort(p), n.length = d.numSupportedMorphTargets) : n.length > d.numSupportedMorphNormals ? n.sort(p) : 0 === n.length && n.push([0, 0]);
          for (var m = 0, r = d.numSupportedMorphTargets; m < r; m++)
            if (n[m]) {
              var t = n[m][1];
              s = c["morphTarget" + m];
              0 <= s && (l.bindBuffer(l.ARRAY_BUFFER, e.__webglMorphTargetsBuffers[t]), g(s), l.vertexAttribPointer(s, 3, l.FLOAT, !1, 0, 0));
              s = c["morphNormal" + m];
              0 <= s && d.morphNormals && (l.bindBuffer(l.ARRAY_BUFFER, e.__webglMorphNormalsBuffers[t]), g(s), l.vertexAttribPointer(s, 3, l.FLOAT, !1, 0, 0));
              k.__webglMorphTargetInfluences[m] = q[t]
            } else k.__webglMorphTargetInfluences[m] = 0
        }
        null !== d.program.uniforms.morphTargetInfluences && l.uniform1fv(d.program.uniforms.morphTargetInfluences, k.__webglMorphTargetInfluences)
      }
      if (a) {
        if (e.__webglCustomAttributesList)
          for (c = 0, q = e.__webglCustomAttributesList.length; c < q; c++) n = e.__webglCustomAttributesList[c], 0 <= b[n.buffer.belongsToAttribute] && (l.bindBuffer(l.ARRAY_BUFFER, n.buffer), g(b[n.buffer.belongsToAttribute]), l.vertexAttribPointer(b[n.buffer.belongsToAttribute], n.size, l.FLOAT, !1, 0, 0));
        0 <= b.color && (0 < k.geometry.colors.length || 0 < k.geometry.faces.length ? (l.bindBuffer(l.ARRAY_BUFFER, e.__webglColorBuffer), g(b.color), l.vertexAttribPointer(b.color, 3, l.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && l.vertexAttrib3fv(b.color, d.defaultAttributeValues.color));
        0 <= b.normal && (l.bindBuffer(l.ARRAY_BUFFER, e.__webglNormalBuffer), g(b.normal), l.vertexAttribPointer(b.normal, 3, l.FLOAT, !1, 0, 0));
        0 <= b.tangent && (l.bindBuffer(l.ARRAY_BUFFER, e.__webglTangentBuffer), g(b.tangent), l.vertexAttribPointer(b.tangent, 4, l.FLOAT, !1, 0, 0));
        0 <= b.uv && (k.geometry.faceVertexUvs[0] ? (l.bindBuffer(l.ARRAY_BUFFER, e.__webglUVBuffer), g(b.uv), l.vertexAttribPointer(b.uv, 2, l.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && l.vertexAttrib2fv(b.uv, d.defaultAttributeValues.uv));
        0 <= b.uv2 && (k.geometry.faceVertexUvs[1] ? (l.bindBuffer(l.ARRAY_BUFFER, e.__webglUV2Buffer), g(b.uv2), l.vertexAttribPointer(b.uv2, 2, l.FLOAT, !1, 0, 0)) : void 0 !== d.defaultAttributeValues && l.vertexAttrib2fv(b.uv2, d.defaultAttributeValues.uv2));
        d.skinning && 0 <= b.skinIndex && 0 <= b.skinWeight && (l.bindBuffer(l.ARRAY_BUFFER, e.__webglSkinIndicesBuffer), g(b.skinIndex), l.vertexAttribPointer(b.skinIndex, 4, l.FLOAT, !1, 0, 0), l.bindBuffer(l.ARRAY_BUFFER, e.__webglSkinWeightsBuffer), g(b.skinWeight), l.vertexAttribPointer(b.skinWeight, 4, l.FLOAT, !1, 0, 0));
        0 <= b.lineDistance && (l.bindBuffer(l.ARRAY_BUFFER, e.__webglLineDistanceBuffer), g(b.lineDistance), l.vertexAttribPointer(b.lineDistance, 1, l.FLOAT, !1, 0, 0))
      }
      h();
      k instanceof THREE.Mesh ? (k = e.__typeArray === Uint32Array ? l.UNSIGNED_INT : l.UNSIGNED_SHORT, d.wireframe ? (D(d.wireframeLinewidth), a && l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer), l.drawElements(l.LINES, e.__webglLineCount, k, 0)) : (a && l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer), l.drawElements(l.TRIANGLES, e.__webglFaceCount, k, 0)), I.info.render.calls++, I.info.render.vertices += e.__webglFaceCount, I.info.render.faces += e.__webglFaceCount / 3) : k instanceof THREE.Line ? (k = k.mode === THREE.LineStrip ? l.LINE_STRIP : l.LINES, D(d.linewidth), l.drawArrays(k, 0, e.__webglLineCount), I.info.render.calls++) : k instanceof THREE.PointCloud && (l.drawArrays(l.POINTS, 0, e.__webglParticleCount), I.info.render.calls++, I.info.render.points += e.__webglParticleCount)
    }
  };
  this.render = function(a, b, c, d) {
    if (!1 === b instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
    else {
      var e = a.fog;
      Sa = "";
      Hb = -1;
      Ib = null;
      Ob = !0;
      !0 === a.autoUpdate && a.updateMatrixWorld();
      void 0 === b.parent && b.updateMatrixWorld();
      a.traverse(function(a) {
        a instanceof THREE.SkinnedMesh && a.skeleton.update()
      });
      b.matrixWorldInverse.getInverse(b.matrixWorld);
      vb.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
      ub.setFromMatrix(vb);
      pa.length = 0;
      Ta.length = 0;
      za.length = 0;
      tb.length = 0;
      eb.length = 0;
      q(a);
      !0 === I.sortObjects && (Ta.sort(k), za.sort(n));
      Nc.render(a, b);
      I.info.render.calls = 0;
      I.info.render.vertices = 0;
      I.info.render.faces = 0;
      I.info.render.points = 0;
      this.setRenderTarget(c);
      (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
      d = 0;
      for (var f = Ga.length; d < f; d++) {
        var g = Ga[d],
          h = g.object;
        h.visible && (G(h, b), s(g))
      }
      a.overrideMaterial ? (d = a.overrideMaterial, this.setBlending(d.blending, d.blendEquation, d.blendSrc, d.blendDst), this.setDepthTest(d.depthTest), this.setDepthWrite(d.depthWrite), A(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits), m(Ta, b, pa, e, !0, d), m(za, b, pa, e, !0, d), t(Ga, "", b, pa, e, !1, d)) : (d = null, this.setBlending(THREE.NoBlending), m(Ta, b, pa, e, !1, d), t(Ga, "opaque", b, pa, e, !1, d), m(za, b, pa, e, !0, d), t(Ga, "transparent", b, pa, e, !0, d));
      Oc.render(a, b);
      Pc.render(a, b, vc, wc);
      c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && L(c);
      this.setDepthTest(!0);
      this.setDepthWrite(!0)
    }
  };
  this.renderImmediateObject = function(a, b, c, d, e) {
    var f = x(a, b, c, d, e);
    Sa = "";
    I.setMaterialFaces(d);
    e.immediateRenderCallback ? e.immediateRenderCallback(f, l, ub) : e.render(function(a) {
      I.renderBufferImmediate(a, f, d)
    })
  };
  var sb = {},
    kc = 0,
    Dc = {
      MeshDepthMaterial: "depth",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointCloudMaterial: "particle_basic"
    };
  this.setFaceCulling = function(a, b) {
    a === THREE.CullFaceNone ? l.disable(l.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? l.frontFace(l.CW) : l.frontFace(l.CCW), a === THREE.CullFaceBack ? l.cullFace(l.BACK) : a === THREE.CullFaceFront ? l.cullFace(l.FRONT) : l.cullFace(l.FRONT_AND_BACK), l.enable(l.CULL_FACE))
  };
  this.setMaterialFaces = function(a) {
    var b = a.side === THREE.DoubleSide;
    a = a.side === THREE.BackSide;
    zb !== b && (b ? l.disable(l.CULL_FACE) : l.enable(l.CULL_FACE), zb = b);
    Xb !== a && (a ? l.frontFace(l.CW) : l.frontFace(l.CCW), Xb = a)
  };
  this.setDepthTest = function(a) {
    gc !== a && (a ? l.enable(l.DEPTH_TEST) : l.disable(l.DEPTH_TEST), gc = a)
  };
  this.setDepthWrite = function(a) {
    hc !== a && (l.depthMask(a), hc = a)
  };
  this.setBlending = function(a, b, c, d) {
    a !== Yb && (a === THREE.NoBlending ? l.disable(l.BLEND) : a === THREE.AdditiveBlending ? (l.enable(l.BLEND), l.blendEquation(l.FUNC_ADD), l.blendFunc(l.SRC_ALPHA, l.ONE)) : a === THREE.SubtractiveBlending ? (l.enable(l.BLEND), l.blendEquation(l.FUNC_ADD), l.blendFunc(l.ZERO, l.ONE_MINUS_SRC_COLOR)) : a === THREE.MultiplyBlending ? (l.enable(l.BLEND), l.blendEquation(l.FUNC_ADD), l.blendFunc(l.ZERO, l.SRC_COLOR)) : a === THREE.CustomBlending ? l.enable(l.BLEND) : (l.enable(l.BLEND), l.blendEquationSeparate(l.FUNC_ADD, l.FUNC_ADD), l.blendFuncSeparate(l.SRC_ALPHA, l.ONE_MINUS_SRC_ALPHA, l.ONE, l.ONE_MINUS_SRC_ALPHA)), Yb = a);
    if (a === THREE.CustomBlending) {
      if (b !== Zb && (l.blendEquation(T(b)), Zb = b), c !== ec || d !== fc) l.blendFunc(T(c), T(d)), ec = c, fc = d
    } else fc = ec = Zb = null
  };
  this.uploadTexture = function(a) {
    void 0 === a.__webglInit && (a.__webglInit = !0, a.addEventListener("dispose", Jb), a.__webglTexture = l.createTexture(), I.info.memory.textures++);
    l.bindTexture(l.TEXTURE_2D, a.__webglTexture);
    l.pixelStorei(l.UNPACK_FLIP_Y_WEBGL, a.flipY);
    l.pixelStorei(l.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);
    l.pixelStorei(l.UNPACK_ALIGNMENT, a.unpackAlignment);
    a.image = M(a.image, Hc);
    var b = a.image,
      c = THREE.Math.isPowerOfTwo(b.width) && THREE.Math.isPowerOfTwo(b.height),
      d = T(a.format),
      e = T(a.type);
    U(l.TEXTURE_2D, a, c);
    var f = a.mipmaps;
    if (a instanceof THREE.DataTexture)
      if (0 < f.length && c) {
        for (var g = 0, h = f.length; g < h; g++) b = f[g], l.texImage2D(l.TEXTURE_2D, g, d, b.width, b.height, 0, d, e, b.data);
        a.generateMipmaps = !1
      } else l.texImage2D(l.TEXTURE_2D, 0, d, b.width, b.height, 0, d, e, b.data);
    else if (a instanceof THREE.CompressedTexture)
      for (g = 0, h = f.length; g < h; g++) b = f[g], a.format !== THREE.RGBAFormat && a.format !== THREE.RGBFormat ? -1 < oc().indexOf(d) ? l.compressedTexImage2D(l.TEXTURE_2D, g, d, b.width, b.height, 0, b.data) : console.warn("Attempt to load unsupported compressed texture format") : l.texImage2D(l.TEXTURE_2D, g, d, b.width, b.height, 0, d, e, b.data);
    else if (0 < f.length && c) {
      g = 0;
      for (h = f.length; g < h; g++) b = f[g], l.texImage2D(l.TEXTURE_2D, g, d, d, e, b);
      a.generateMipmaps = !1
    } else l.texImage2D(l.TEXTURE_2D, 0, d, d, e, a.image);
    a.generateMipmaps && c && l.generateMipmap(l.TEXTURE_2D);
    a.needsUpdate = !1;
    if (a.onUpdate) a.onUpdate()
  };
  this.setTexture = function(a, b) {
    l.activeTexture(l.TEXTURE0 + b);
    a.needsUpdate ? I.uploadTexture(a) : l.bindTexture(l.TEXTURE_2D, a.__webglTexture)
  };
  this.setRenderTarget = function(a) {
    var b = a instanceof THREE.WebGLRenderTargetCube;
    if (a && void 0 === a.__webglFramebuffer) {
      void 0 === a.depthBuffer && (a.depthBuffer = !0);
      void 0 === a.stencilBuffer && (a.stencilBuffer = !0);
      a.addEventListener("dispose", Cc);
      a.__webglTexture = l.createTexture();
      I.info.memory.textures++;
      var c = THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height),
        d = T(a.format),
        e = T(a.type);
      if (b) {
        a.__webglFramebuffer = [];
        a.__webglRenderbuffer = [];
        l.bindTexture(l.TEXTURE_CUBE_MAP, a.__webglTexture);
        U(l.TEXTURE_CUBE_MAP, a, c);
        for (var g = 0; 6 > g; g++) {
          a.__webglFramebuffer[g] = l.createFramebuffer();
          a.__webglRenderbuffer[g] = l.createRenderbuffer();
          l.texImage2D(l.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, d, a.width, a.height, 0, d, e, null);
          var f = a,
            h = l.TEXTURE_CUBE_MAP_POSITIVE_X + g;
          l.bindFramebuffer(l.FRAMEBUFFER, a.__webglFramebuffer[g]);
          l.framebufferTexture2D(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0, h, f.__webglTexture, 0);
          K(a.__webglRenderbuffer[g], a)
        }
        c && l.generateMipmap(l.TEXTURE_CUBE_MAP)
      } else a.__webglFramebuffer = l.createFramebuffer(), a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : l.createRenderbuffer(), l.bindTexture(l.TEXTURE_2D, a.__webglTexture), U(l.TEXTURE_2D, a, c), l.texImage2D(l.TEXTURE_2D, 0, d, a.width, a.height, 0, d, e, null), d = l.TEXTURE_2D, l.bindFramebuffer(l.FRAMEBUFFER, a.__webglFramebuffer), l.framebufferTexture2D(l.FRAMEBUFFER, l.COLOR_ATTACHMENT0, d, a.__webglTexture, 0), a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? l.framebufferRenderbuffer(l.FRAMEBUFFER, l.DEPTH_ATTACHMENT, l.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && l.framebufferRenderbuffer(l.FRAMEBUFFER, l.DEPTH_STENCIL_ATTACHMENT, l.RENDERBUFFER, a.__webglRenderbuffer) : K(a.__webglRenderbuffer, a), c && l.generateMipmap(l.TEXTURE_2D);
      b ? l.bindTexture(l.TEXTURE_CUBE_MAP, null) : l.bindTexture(l.TEXTURE_2D, null);
      l.bindRenderbuffer(l.RENDERBUFFER, null);
      l.bindFramebuffer(l.FRAMEBUFFER, null)
    }
    a ? (b = b ? a.__webglFramebuffer[a.activeCubeFace] : a.__webglFramebuffer, c = a.width, a = a.height, e = d = 0) : (b = null, c = ib, a = jb, d = hb, e = Ya);
    b !== uc && (l.bindFramebuffer(l.FRAMEBUFFER, b), l.viewport(d, e, c, a), uc = b);
    vc = c;
    wc = a
  };
  this.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
  };
  this.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
  };
  this.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
  };
  this.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
  }
};
THREE.WebGLRenderTarget = function(a, b, c) {
  this.width = a;
  this.height = b;
  c = c || {};
  this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;
  this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;
  this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;
  this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;
  this.offset = new THREE.Vector2(0, 0);
  this.repeat = new THREE.Vector2(1, 1);
  this.format = void 0 !== c.format ? c.format : THREE.RGBAFormat;
  this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;
  this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
  this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
  this.generateMipmaps = !0;
  this.shareDepthFrom = null
};
THREE.WebGLRenderTarget.prototype = {
  constructor: THREE.WebGLRenderTarget,
  setSize: function(a, b) {
    this.width = a;
    this.height = b
  },
  clone: function() {
    var a = new THREE.WebGLRenderTarget(this.width, this.height);
    a.wrapS = this.wrapS;
    a.wrapT = this.wrapT;
    a.magFilter = this.magFilter;
    a.minFilter = this.minFilter;
    a.anisotropy = this.anisotropy;
    a.offset.copy(this.offset);
    a.repeat.copy(this.repeat);
    a.format = this.format;
    a.type = this.type;
    a.depthBuffer = this.depthBuffer;
    a.stencilBuffer = this.stencilBuffer;
    a.generateMipmaps = this.generateMipmaps;
    a.shareDepthFrom = this.shareDepthFrom;
    return a
  },
  dispose: function() {
    this.dispatchEvent({
      type: "dispose"
    })
  }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube = function(a, b, c) {
  THREE.WebGLRenderTarget.call(this, a, b, c);
  this.activeCubeFace = 0
};
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
THREE.WebGLExtensions = function(a) {
  var b = {};
  this.get = function(c) {
    if (void 0 !== b[c]) return b[c];
    var d;
    switch (c) {
      case "EXT_texture_filter_anisotropic":
        d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        d = a.getExtension(c)
    }
    null === d && console.log("THREE.WebGLRenderer: " + c + " extension not supported.");
    return b[c] = d
  }
};
THREE.WebGLProgram = function() {
  var a = 0;
  return function(b, c, d, e) {
    var f = b.context,
      g = d.defines,
      h = d.__webglShader.uniforms,
      k = d.attributes,
      n = d.__webglShader.vertexShader,
      p = d.__webglShader.fragmentShader,
      q = d.index0AttributeName;
    void 0 === q && !0 === e.morphTargets && (q = "position");
    var m = "SHADOWMAP_TYPE_BASIC";
    e.shadowMapType === THREE.PCFShadowMap ? m = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === THREE.PCFSoftShadowMap && (m = "SHADOWMAP_TYPE_PCF_SOFT");
    var t = "ENVMAP_TYPE_CUBE",
      s = "ENVMAP_MODE_REFLECTION",
      r = "ENVMAP_BLENDING_MULTIPLY";
    if (e.envMap) {
      switch (d.envMap.mapping) {
        case THREE.CubeReflectionMapping:
        case THREE.CubeRefractionMapping:
          t = "ENVMAP_TYPE_CUBE";
          break;
        case THREE.EquirectangularReflectionMapping:
        case THREE.EquirectangularRefractionMapping:
          t = "ENVMAP_TYPE_EQUIREC";
          break;
        case THREE.SphericalReflectionMapping:
          t = "ENVMAP_TYPE_SPHERE"
      }
      switch (d.envMap.mapping) {
        case THREE.CubeRefractionMapping:
        case THREE.EquirectangularRefractionMapping:
          s = "ENVMAP_MODE_REFRACTION"
      }
      switch (d.combine) {
        case THREE.MultiplyOperation:
          r = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case THREE.MixOperation:
          r = "ENVMAP_BLENDING_MIX";
          break;
        case THREE.AddOperation:
          r = "ENVMAP_BLENDING_ADD"
      }
    }
    var u, v;
    u = [];
    for (var y in g) v = g[y], !1 !== v && (v = "#define " + y + " " + v, u.push(v));
    u = u.join("\n");
    g = f.createProgram();
    d instanceof THREE.RawShaderMaterial ? b = d = "" : (d = ["precision " + e.precision + " float;", "precision " + e.precision + " int;", u, e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", b.gammaInput ? "#define GAMMA_INPUT" : "", b.gammaOutput ? "#define GAMMA_OUTPUT" : "", "#define MAX_DIR_LIGHTS " + e.maxDirLights, "#define MAX_POINT_LIGHTS " + e.maxPointLights, "#define MAX_SPOT_LIGHTS " + e.maxSpotLights, "#define MAX_HEMI_LIGHTS " + e.maxHemiLights, "#define MAX_SHADOWS " + e.maxShadows, "#define MAX_BONES " + e.maxBones, e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + s : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.vertexColors ? "#define USE_COLOR" : "", e.skinning ? "#define USE_SKINNING" : "", e.useVertexTexture ? "#define BONE_TEXTURE" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals ? "#define USE_MORPHNORMALS" : "", e.wrapAround ? "#define WRAP_AROUND" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + m : "", e.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", e.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n\tattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n"].join("\n"), b = ["precision " + e.precision + " float;", "precision " + e.precision + " int;", e.bumpMap || e.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", u, "#define MAX_DIR_LIGHTS " + e.maxDirLights, "#define MAX_POINT_LIGHTS " + e.maxPointLights, "#define MAX_SPOT_LIGHTS " + e.maxSpotLights, "#define MAX_HEMI_LIGHTS " + e.maxHemiLights, "#define MAX_SHADOWS " + e.maxShadows, e.alphaTest ? "#define ALPHATEST " + e.alphaTest : "", b.gammaInput ? "#define GAMMA_INPUT" : "", b.gammaOutput ? "#define GAMMA_OUTPUT" : "", e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + t : "", e.envMap ? "#define " + s : "", e.envMap ? "#define " + r : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.vertexColors ? "#define USE_COLOR" : "", e.metal ? "#define METAL" : "", e.wrapAround ? "#define WRAP_AROUND" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + m : "", e.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", e.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n"));
    n = new THREE.WebGLShader(f, f.VERTEX_SHADER, d + n);
    p = new THREE.WebGLShader(f, f.FRAGMENT_SHADER, b + p);
    f.attachShader(g, n);
    f.attachShader(g, p);
    void 0 !== q && f.bindAttribLocation(g, 0, q);
    f.linkProgram(g);
    !1 === f.getProgramParameter(g, f.LINK_STATUS) && (console.error("THREE.WebGLProgram: Could not initialise shader."), console.error("gl.VALIDATE_STATUS", f.getProgramParameter(g, f.VALIDATE_STATUS)), console.error("gl.getError()", f.getError()));
    "" !== f.getProgramInfoLog(g) && console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", f.getProgramInfoLog(g));
    f.deleteShader(n);
    f.deleteShader(p);
    q = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse".split(" ");
    e.useVertexTexture ? (q.push("boneTexture"), q.push("boneTextureWidth"), q.push("boneTextureHeight")) : q.push("boneGlobalMatrices");
    e.logarithmicDepthBuffer && q.push("logDepthBufFC");
    for (var C in h) q.push(C);
    h = q;
    C = {};
    q = 0;
    for (b = h.length; q < b; q++) m = h[q], C[m] = f.getUniformLocation(g, m);
    this.uniforms = C;
    q = "position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" ");
    for (h = 0; h < e.maxMorphTargets; h++) q.push("morphTarget" + h);
    for (h = 0; h < e.maxMorphNormals; h++) q.push("morphNormal" + h);
    for (var x in k) q.push(x);
    e = q;
    k = {};
    x = 0;
    for (h = e.length; x < h; x++) C = e[x], k[C] = f.getAttribLocation(g, C);
    this.attributes = k;
    this.attributesKeys = Object.keys(this.attributes);
    this.id = a++;
    this.code = c;
    this.usedTimes = 1;
    this.program = g;
    this.vertexShader = n;
    this.fragmentShader = p;
    return this
  }
}();
THREE.WebGLShader = function() {
  var a = function(a) {
    a = a.split("\n");
    for (var c = 0; c < a.length; c++) a[c] = c + 1 + ": " + a[c];
    return a.join("\n")
  };
  return function(b, c, d) {
    c = b.createShader(c);
    b.shaderSource(c, d);
    b.compileShader(c);
    !1 === b.getShaderParameter(c, b.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile.");
    "" !== b.getShaderInfoLog(c) && (console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b.getShaderInfoLog(c)), console.warn(a(d)));
    return c
  }
}();
THREE.LensFlarePlugin = function(a, b) {
  var c, d, e, f, g, h, k, n, p, q, m = a.context,
    t, s, r, u, v, y;
  this.render = function(C, x, F, z) {
    if (0 !== b.length) {
      C = new THREE.Vector3;
      var G = z / F,
        E = .5 * F,
        w = .5 * z,
        D = 16 / z,
        A = new THREE.Vector2(D * G, D),
        U = new THREE.Vector3(1, 1, 0),
        M = new THREE.Vector2(1, 1);
      if (void 0 === r) {
        var D = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
          K = new Uint16Array([0, 1, 2, 0, 2, 3]);
        t = m.createBuffer();
        s = m.createBuffer();
        m.bindBuffer(m.ARRAY_BUFFER, t);
        m.bufferData(m.ARRAY_BUFFER, D, m.STATIC_DRAW);
        m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, s);
        m.bufferData(m.ELEMENT_ARRAY_BUFFER, K, m.STATIC_DRAW);
        v = m.createTexture();
        y = m.createTexture();
        m.bindTexture(m.TEXTURE_2D, v);
        m.texImage2D(m.TEXTURE_2D, 0, m.RGB, 16, 16, 0, m.RGB, m.UNSIGNED_BYTE, null);
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE);
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE);
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST);
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST);
        m.bindTexture(m.TEXTURE_2D, y);
        m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, 16, 16, 0, m.RGBA, m.UNSIGNED_BYTE, null);
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE);
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE);
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST);
        m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST);
        var D = (u = 0 < m.getParameter(m.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) ? {
            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
            fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
          } : {
            vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
            fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
          },
          K = m.createProgram(),
          L = m.createShader(m.FRAGMENT_SHADER),
          N = m.createShader(m.VERTEX_SHADER),
          T = "precision " + a.getPrecision() + " float;\n";
        m.shaderSource(L, T + D.fragmentShader);
        m.shaderSource(N, T + D.vertexShader);
        m.compileShader(L);
        m.compileShader(N);
        m.attachShader(K, L);
        m.attachShader(K, N);
        m.linkProgram(K);
        r = K;
        p = m.getAttribLocation(r, "position");
        q = m.getAttribLocation(r, "uv");
        c = m.getUniformLocation(r, "renderType");
        d = m.getUniformLocation(r, "map");
        e = m.getUniformLocation(r, "occlusionMap");
        f = m.getUniformLocation(r, "opacity");
        g = m.getUniformLocation(r, "color");
        h = m.getUniformLocation(r, "scale");
        k = m.getUniformLocation(r, "rotation");
        n = m.getUniformLocation(r, "screenPosition")
      }
      m.useProgram(r);
      m.enableVertexAttribArray(p);
      m.enableVertexAttribArray(q);
      m.uniform1i(e, 0);
      m.uniform1i(d, 1);
      m.bindBuffer(m.ARRAY_BUFFER, t);
      m.vertexAttribPointer(p, 2, m.FLOAT, !1, 16, 0);
      m.vertexAttribPointer(q, 2, m.FLOAT, !1, 16, 8);
      m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, s);
      m.disable(m.CULL_FACE);
      m.depthMask(!1);
      K = 0;
      for (L = b.length; K < L; K++)
        if (D = 16 / z, A.set(D * G, D), N = b[K], C.set(N.matrixWorld.elements[12], N.matrixWorld.elements[13], N.matrixWorld.elements[14]), C.applyMatrix4(x.matrixWorldInverse), C.applyProjection(x.projectionMatrix), U.copy(C), M.x = U.x * E + E, M.y = U.y * w + w, u || 0 < M.x && M.x < F && 0 < M.y && M.y < z) {
          m.activeTexture(m.TEXTURE1);
          m.bindTexture(m.TEXTURE_2D, v);
          m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGB, M.x - 8, M.y - 8, 16, 16, 0);
          m.uniform1i(c, 0);
          m.uniform2f(h, A.x, A.y);
          m.uniform3f(n, U.x, U.y, U.z);
          m.disable(m.BLEND);
          m.enable(m.DEPTH_TEST);
          m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0);
          m.activeTexture(m.TEXTURE0);
          m.bindTexture(m.TEXTURE_2D, y);
          m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGBA, M.x - 8, M.y - 8, 16, 16, 0);
          m.uniform1i(c, 1);
          m.disable(m.DEPTH_TEST);
          m.activeTexture(m.TEXTURE1);
          m.bindTexture(m.TEXTURE_2D, v);
          m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0);
          N.positionScreen.copy(U);
          N.customUpdateCallback ? N.customUpdateCallback(N) : N.updateLensFlares();
          m.uniform1i(c, 2);
          m.enable(m.BLEND);
          for (var T = 0, Q = N.lensFlares.length; T < Q; T++) {
            var W = N.lensFlares[T];.001 < W.opacity && .001 < W.scale && (U.x = W.x, U.y = W.y, U.z = W.z, D = W.size * W.scale / z, A.x = D * G, A.y = D, m.uniform3f(n, U.x, U.y, U.z), m.uniform2f(h, A.x, A.y), m.uniform1f(k, W.rotation), m.uniform1f(f, W.opacity), m.uniform3f(g, W.color.r, W.color.g, W.color.b), a.setBlending(W.blending, W.blendEquation, W.blendSrc, W.blendDst), a.setTexture(W.texture, 1), m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0))
          }
        }
      m.enable(m.CULL_FACE);
      m.enable(m.DEPTH_TEST);
      m.depthMask(!0);
      a.resetGLState()
    }
  }
};
THREE.ShadowMapPlugin = function(a, b, c, d) {
  function e(a, b, d) {
    if (b.visible) {
      var g = c[b.id];
      if (g && b.castShadow && (!1 === b.frustumCulled || !0 === p.intersectsObject(b)))
        for (var f = 0, h = g.length; f < h; f++) {
          var k = g[f];
          b._modelViewMatrix.multiplyMatrices(d.matrixWorldInverse, b.matrixWorld);
          r.push(k)
        }
      f = 0;
      for (h = b.children.length; f < h; f++) e(a, b.children[f], d)
    }
  }
  var f = a.context,
    g, h, k, n, p = new THREE.Frustum,
    q = new THREE.Matrix4,
    m = new THREE.Vector3,
    t = new THREE.Vector3,
    s = new THREE.Vector3,
    r = [],
    u = THREE.ShaderLib.depthRGBA,
    v = THREE.UniformsUtils.clone(u.uniforms);
  g = new THREE.ShaderMaterial({
    uniforms: v,
    vertexShader: u.vertexShader,
    fragmentShader: u.fragmentShader
  });
  h = new THREE.ShaderMaterial({
    uniforms: v,
    vertexShader: u.vertexShader,
    fragmentShader: u.fragmentShader,
    morphTargets: !0
  });
  k = new THREE.ShaderMaterial({
    uniforms: v,
    vertexShader: u.vertexShader,
    fragmentShader: u.fragmentShader,
    skinning: !0
  });
  n = new THREE.ShaderMaterial({
    uniforms: v,
    vertexShader: u.vertexShader,
    fragmentShader: u.fragmentShader,
    morphTargets: !0,
    skinning: !0
  });
  g._shadowPass = !0;
  h._shadowPass = !0;
  k._shadowPass = !0;
  n._shadowPass = !0;
  this.render = function(c, v) {
    if (!1 !== a.shadowMapEnabled) {
      var u, F, z, G, E, w, D, A, U = [];
      G = 0;
      f.clearColor(1, 1, 1, 1);
      f.disable(f.BLEND);
      f.enable(f.CULL_FACE);
      f.frontFace(f.CCW);
      a.shadowMapCullFace === THREE.CullFaceFront ? f.cullFace(f.FRONT) : f.cullFace(f.BACK);
      a.setDepthTest(!0);
      u = 0;
      for (F = b.length; u < F; u++)
        if (z = b[u], z.castShadow)
          if (z instanceof THREE.DirectionalLight && z.shadowCascade)
            for (E = 0; E < z.shadowCascadeCount; E++) {
              var M;
              if (z.shadowCascadeArray[E]) M = z.shadowCascadeArray[E];
              else {
                D = z;
                var K = E;
                M = new THREE.DirectionalLight;
                M.isVirtual = !0;
                M.onlyShadow = !0;
                M.castShadow = !0;
                M.shadowCameraNear = D.shadowCameraNear;
                M.shadowCameraFar = D.shadowCameraFar;
                M.shadowCameraLeft = D.shadowCameraLeft;
                M.shadowCameraRight = D.shadowCameraRight;
                M.shadowCameraBottom = D.shadowCameraBottom;
                M.shadowCameraTop = D.shadowCameraTop;
                M.shadowCameraVisible = D.shadowCameraVisible;
                M.shadowDarkness = D.shadowDarkness;
                M.shadowBias = D.shadowCascadeBias[K];
                M.shadowMapWidth = D.shadowCascadeWidth[K];
                M.shadowMapHeight = D.shadowCascadeHeight[K];
                M.pointsWorld = [];
                M.pointsFrustum = [];
                A = M.pointsWorld;
                w = M.pointsFrustum;
                for (var L = 0; 8 > L; L++) A[L] = new THREE.Vector3, w[L] = new THREE.Vector3;
                A = D.shadowCascadeNearZ[K];
                D = D.shadowCascadeFarZ[K];
                w[0].set(-1, -1, A);
                w[1].set(1, -1, A);
                w[2].set(-1, 1, A);
                w[3].set(1, 1, A);
                w[4].set(-1, -1, D);
                w[5].set(1, -1, D);
                w[6].set(-1, 1, D);
                w[7].set(1, 1, D);
                M.originalCamera = v;
                w = new THREE.Gyroscope;
                w.position.copy(z.shadowCascadeOffset);
                w.add(M);
                w.add(M.target);
                v.add(w);
                z.shadowCascadeArray[E] = M;
                console.log("Created virtualLight", M)
              }
              K = z;
              A = E;
              D = K.shadowCascadeArray[A];
              D.position.copy(K.position);
              D.target.position.copy(K.target.position);
              D.lookAt(D.target);
              D.shadowCameraVisible = K.shadowCameraVisible;
              D.shadowDarkness = K.shadowDarkness;
              D.shadowBias = K.shadowCascadeBias[A];
              w = K.shadowCascadeNearZ[A];
              K = K.shadowCascadeFarZ[A];
              D = D.pointsFrustum;
              D[0].z = w;
              D[1].z = w;
              D[2].z = w;
              D[3].z = w;
              D[4].z = K;
              D[5].z = K;
              D[6].z = K;
              D[7].z = K;
              U[G] = M;
              G++
            } else U[G] = z, G++;
      u = 0;
      for (F = U.length; u < F; u++) {
        z = U[u];
        z.shadowMap || (E = THREE.LinearFilter, a.shadowMapType === THREE.PCFSoftShadowMap && (E = THREE.NearestFilter), z.shadowMap = new THREE.WebGLRenderTarget(z.shadowMapWidth, z.shadowMapHeight, {
          minFilter: E,
          magFilter: E,
          format: THREE.RGBAFormat
        }), z.shadowMapSize = new THREE.Vector2(z.shadowMapWidth, z.shadowMapHeight), z.shadowMatrix = new THREE.Matrix4);
        if (!z.shadowCamera) {
          if (z instanceof THREE.SpotLight) z.shadowCamera = new THREE.PerspectiveCamera(z.shadowCameraFov, z.shadowMapWidth / z.shadowMapHeight, z.shadowCameraNear, z.shadowCameraFar);
          else if (z instanceof THREE.DirectionalLight) z.shadowCamera = new THREE.OrthographicCamera(z.shadowCameraLeft, z.shadowCameraRight, z.shadowCameraTop, z.shadowCameraBottom, z.shadowCameraNear, z.shadowCameraFar);
          else {
            console.error("Unsupported light type for shadow");
            continue
          }
          c.add(z.shadowCamera);
          !0 === c.autoUpdate && c.updateMatrixWorld()
        }
        z.shadowCameraVisible && !z.cameraHelper && (z.cameraHelper = new THREE.CameraHelper(z.shadowCamera), c.add(z.cameraHelper));
        if (z.isVirtual && M.originalCamera == v) {
          E = v;
          G = z.shadowCamera;
          w = z.pointsFrustum;
          D = z.pointsWorld;
          m.set(Infinity, Infinity, Infinity);
          t.set(-Infinity, -Infinity, -Infinity);
          for (K = 0; 8 > K; K++) A = D[K], A.copy(w[K]), A.unproject(E), A.applyMatrix4(G.matrixWorldInverse), A.x < m.x && (m.x = A.x), A.x > t.x && (t.x = A.x), A.y < m.y && (m.y = A.y), A.y > t.y && (t.y = A.y), A.z < m.z && (m.z = A.z), A.z > t.z && (t.z = A.z);
          G.left = m.x;
          G.right = t.x;
          G.top = t.y;
          G.bottom = m.y;
          G.updateProjectionMatrix()
        }
        G = z.shadowMap;
        w = z.shadowMatrix;
        E = z.shadowCamera;
        E.position.setFromMatrixPosition(z.matrixWorld);
        s.setFromMatrixPosition(z.target.matrixWorld);
        E.lookAt(s);
        E.updateMatrixWorld();
        E.matrixWorldInverse.getInverse(E.matrixWorld);
        z.cameraHelper && (z.cameraHelper.visible = z.shadowCameraVisible);
        z.shadowCameraVisible && z.cameraHelper.update();
        w.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
        w.multiply(E.projectionMatrix);
        w.multiply(E.matrixWorldInverse);
        q.multiplyMatrices(E.projectionMatrix, E.matrixWorldInverse);
        p.setFromMatrix(q);
        a.setRenderTarget(G);
        a.clear();
        r.length = 0;
        e(c, c, E);
        z = 0;
        for (G = r.length; z < G; z++) D = r[z], w = D.object, D = D.buffer, K = w.material instanceof THREE.MeshFaceMaterial ? w.material.materials[0] : w.material, A = void 0 !== w.geometry.morphTargets && 0 < w.geometry.morphTargets.length && K.morphTargets, L = w instanceof THREE.SkinnedMesh && K.skinning, A = w.customDepthMaterial ? w.customDepthMaterial : L ? A ? n : k : A ? h : g, a.setMaterialFaces(K), D instanceof THREE.BufferGeometry ? a.renderBufferDirect(E, b, null, A, D, w) : a.renderBuffer(E, b, null, A, D, w);
        z = 0;
        for (G = d.length; z < G; z++) D = d[z], w = D.object, w.visible && w.castShadow && (w._modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, w.matrixWorld), a.renderImmediateObject(E, b, null, g, w))
      }
      u = a.getClearColor();
      F = a.getClearAlpha();
      f.clearColor(u.r, u.g, u.b, F);
      f.enable(f.BLEND);
      a.shadowMapCullFace === THREE.CullFaceFront && f.cullFace(f.BACK);
      a.resetGLState()
    }
  }
};
THREE.SpritePlugin = function(a, b) {
  var c, d, e, f, g, h, k, n, p, q, m, t, s, r, u, v, y;

  function C(a, b) {
    return a.z !== b.z ? b.z - a.z : b.id - a.id
  }
  var x = a.context,
    F, z, G, E, w = new THREE.Vector3,
    D = new THREE.Quaternion,
    A = new THREE.Vector3;
  this.render = function(U, M) {
    if (0 !== b.length) {
      if (void 0 === G) {
        var K = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
          L = new Uint16Array([0, 1, 2, 0, 2, 3]);
        F = x.createBuffer();
        z = x.createBuffer();
        x.bindBuffer(x.ARRAY_BUFFER, F);
        x.bufferData(x.ARRAY_BUFFER, K, x.STATIC_DRAW);
        x.bindBuffer(x.ELEMENT_ARRAY_BUFFER, z);
        x.bufferData(x.ELEMENT_ARRAY_BUFFER, L, x.STATIC_DRAW);
        var K = x.createProgram(),
          L = x.createShader(x.VERTEX_SHADER),
          N = x.createShader(x.FRAGMENT_SHADER);
        x.shaderSource(L, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n"));
        x.shaderSource(N, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n"));
        x.compileShader(L);
        x.compileShader(N);
        x.attachShader(K, L);
        x.attachShader(K, N);
        x.linkProgram(K);
        G = K;
        v = x.getAttribLocation(G, "position");
        y = x.getAttribLocation(G, "uv");
        c = x.getUniformLocation(G, "uvOffset");
        d = x.getUniformLocation(G, "uvScale");
        e = x.getUniformLocation(G, "rotation");
        f = x.getUniformLocation(G, "scale");
        g = x.getUniformLocation(G, "color");
        h = x.getUniformLocation(G, "map");
        k = x.getUniformLocation(G, "opacity");
        n = x.getUniformLocation(G, "modelViewMatrix");
        p = x.getUniformLocation(G, "projectionMatrix");
        q = x.getUniformLocation(G, "fogType");
        m = x.getUniformLocation(G, "fogDensity");
        t = x.getUniformLocation(G, "fogNear");
        s = x.getUniformLocation(G, "fogFar");
        r = x.getUniformLocation(G, "fogColor");
        u = x.getUniformLocation(G, "alphaTest");
        K = document.createElement("canvas");
        K.width = 8;
        K.height = 8;
        L = K.getContext("2d");
        L.fillStyle = "white";
        L.fillRect(0, 0, 8, 8);
        E = new THREE.Texture(K);
        E.needsUpdate = !0
      }
      x.useProgram(G);
      x.enableVertexAttribArray(v);
      x.enableVertexAttribArray(y);
      x.disable(x.CULL_FACE);
      x.enable(x.BLEND);
      x.bindBuffer(x.ARRAY_BUFFER, F);
      x.vertexAttribPointer(v, 2, x.FLOAT, !1, 16, 0);
      x.vertexAttribPointer(y, 2, x.FLOAT, !1, 16, 8);
      x.bindBuffer(x.ELEMENT_ARRAY_BUFFER, z);
      x.uniformMatrix4fv(p, !1, M.projectionMatrix.elements);
      x.activeTexture(x.TEXTURE0);
      x.uniform1i(h, 0);
      L = K = 0;
      (N = U.fog) ? (x.uniform3f(r, N.color.r, N.color.g, N.color.b), N instanceof THREE.Fog ? (x.uniform1f(t, N.near), x.uniform1f(s, N.far), x.uniform1i(q, 1), L = K = 1) : N instanceof THREE.FogExp2 && (x.uniform1f(m, N.density), x.uniform1i(q, 2), L = K = 2)) : (x.uniform1i(q, 0), L = K = 0);
      for (var N = 0, T = b.length; N < T; N++) {
        var Q = b[N];
        Q._modelViewMatrix.multiplyMatrices(M.matrixWorldInverse, Q.matrixWorld);
        Q.z = -Q._modelViewMatrix.elements[14]
      }
      b.sort(C);
      for (var W = [], N = 0, T = b.length; N < T; N++) {
        var Q = b[N],
          O = Q.material;
        x.uniform1f(u, O.alphaTest);
        x.uniformMatrix4fv(n, !1, Q._modelViewMatrix.elements);
        Q.matrixWorld.decompose(w, D, A);
        W[0] = A.x;
        W[1] = A.y;
        Q = 0;
        U.fog && O.fog && (Q = L);
        K !== Q && (x.uniform1i(q, Q), K = Q);
        null !== O.map ? (x.uniform2f(c, O.map.offset.x, O.map.offset.y), x.uniform2f(d, O.map.repeat.x, O.map.repeat.y)) : (x.uniform2f(c, 0, 0), x.uniform2f(d, 1, 1));
        x.uniform1f(k, O.opacity);
        x.uniform3f(g, O.color.r, O.color.g, O.color.b);
        x.uniform1f(e, O.rotation);
        x.uniform2fv(f, W);
        a.setBlending(O.blending, O.blendEquation, O.blendSrc, O.blendDst);
        a.setDepthTest(O.depthTest);
        a.setDepthWrite(O.depthWrite);
        O.map && O.map.image && O.map.image.width ? a.setTexture(O.map, 0) : a.setTexture(E, 0);
        x.drawElements(x.TRIANGLES, 6, x.UNSIGNED_SHORT, 0)
      }
      x.enable(x.CULL_FACE);
      a.resetGLState()
    }
  }
};
THREE.GeometryUtils = {
  merge: function(a, b, c) {
    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
    var d;
    b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry);
    a.merge(b, d, c)
  },
  center: function(a) {
    console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
    return a.center()
  }
};
THREE.ImageUtils = {
  crossOrigin: void 0,
  loadTexture: function(a, b, c, d) {
    var e = new THREE.ImageLoader;
    e.crossOrigin = this.crossOrigin;
    var f = new THREE.Texture(void 0, b);
    e.load(a, function(a) {
      f.image = a;
      f.needsUpdate = !0;
      c && c(f)
    }, void 0, function(a) {
      d && d(a)
    });
    f.sourceFile = a;
    return f
  },
  loadTextureCube: function(a, b, c, d) {
    var e = new THREE.ImageLoader;
    e.crossOrigin = this.crossOrigin;
    var f = new THREE.CubeTexture([], b);
    f.flipY = !1;
    var g = 0;
    b = function(b) {
      e.load(a[b], function(a) {
        f.images[b] = a;
        g += 1;
        6 === g && (f.needsUpdate = !0, c && c(f))
      }, void 0, d)
    };
    for (var h = 0, k = a.length; h < k; ++h) b(h);
    return f
  },
  loadCompressedTexture: function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
  },
  loadCompressedTextureCube: function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
  },
  getNormalMap: function(a, b) {
    var c = function(a) {
      var b = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
      return [a[0] / b, a[1] / b, a[2] / b]
    };
    b |= 1;
    var d = a.width,
      e = a.height,
      f = document.createElement("canvas");
    f.width = d;
    f.height = e;
    var g = f.getContext("2d");
    g.drawImage(a, 0, 0);
    for (var h = g.getImageData(0, 0, d, e).data, k = g.createImageData(d, e), n = k.data, p = 0; p < d; p++)
      for (var q = 0; q < e; q++) {
        var m = 0 > q - 1 ? 0 : q - 1,
          t = q + 1 > e - 1 ? e - 1 : q + 1,
          s = 0 > p - 1 ? 0 : p - 1,
          r = p + 1 > d - 1 ? d - 1 : p + 1,
          u = [],
          v = [0, 0, h[4 * (q * d + p)] / 255 * b];
        u.push([-1, 0, h[4 * (q * d + s)] / 255 * b]);
        u.push([-1, -1, h[4 * (m * d + s)] / 255 * b]);
        u.push([0, -1, h[4 * (m * d + p)] / 255 * b]);
        u.push([1, -1, h[4 * (m * d + r)] / 255 * b]);
        u.push([1, 0, h[4 * (q * d + r)] / 255 * b]);
        u.push([1, 1, h[4 * (t * d + r)] / 255 * b]);
        u.push([0, 1, h[4 * (t * d + p)] / 255 * b]);
        u.push([-1, 1, h[4 * (t * d + s)] / 255 * b]);
        m = [];
        s = u.length;
        for (t = 0; t < s; t++) {
          var r = u[t],
            y = u[(t + 1) % s],
            r = [r[0] - v[0], r[1] - v[1], r[2] - v[2]],
            y = [y[0] - v[0], y[1] - v[1], y[2] - v[2]];
          m.push(c([r[1] * y[2] - r[2] * y[1], r[2] * y[0] - r[0] * y[2], r[0] * y[1] - r[1] * y[0]]))
        }
        u = [0, 0, 0];
        for (t = 0; t < m.length; t++) u[0] += m[t][0], u[1] += m[t][1], u[2] += m[t][2];
        u[0] /= m.length;
        u[1] /= m.length;
        u[2] /= m.length;
        v = 4 * (q * d + p);
        n[v] = (u[0] + 1) / 2 * 255 | 0;
        n[v + 1] = (u[1] + 1) / 2 * 255 | 0;
        n[v + 2] = 255 * u[2] | 0;
        n[v + 3] = 255
      }
    g.putImageData(k, 0, 0);
    return f
  },
  generateDataTexture: function(a, b, c) {
    var d = a * b,
      e = new Uint8Array(3 * d),
      f = Math.floor(255 * c.r),
      g = Math.floor(255 * c.g);
    c = Math.floor(255 * c.b);
    for (var h = 0; h < d; h++) e[3 * h] = f, e[3 * h + 1] = g, e[3 * h + 2] = c;
    a = new THREE.DataTexture(e, a, b, THREE.RGBFormat);
    a.needsUpdate = !0;
    return a
  }
};
THREE.SceneUtils = {
  createMultiMaterialObject: function(a, b) {
    for (var c = new THREE.Object3D, d = 0, e = b.length; d < e; d++) c.add(new THREE.Mesh(a, b[d]));
    return c
  },
  detach: function(a, b, c) {
    a.applyMatrix(b.matrixWorld);
    b.remove(a);
    c.add(a)
  },
  attach: function(a, b, c) {
    var d = new THREE.Matrix4;
    d.getInverse(c.matrixWorld);
    a.applyMatrix(d);
    b.remove(a);
    c.add(a)
  }
};
THREE.FontUtils = {
  faces: {},
  face: "helvetiker",
  weight: "normal",
  style: "normal",
  size: 150,
  divisions: 10,
  getFace: function() {
    try {
      return this.faces[this.face][this.weight][this.style]
    } catch (a) {
      throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing.";
    }
  },
  loadFace: function(a) {
    var b = a.familyName.toLowerCase();
    this.faces[b] = this.faces[b] || {};
    this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};
    this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
    return this.faces[b][a.cssFontWeight][a.cssFontStyle] = a
  },
  drawText: function(a) {
    var b = this.getFace(),
      c = this.size / b.resolution,
      d = 0,
      e = String(a).split(""),
      f = e.length,
      g = [];
    for (a = 0; a < f; a++) {
      var h = new THREE.Path,
        h = this.extractGlyphPoints(e[a], b, c, d, h),
        d = d + h.offset;
      g.push(h.path)
    }
    return {
      paths: g,
      offset: d / 2
    }
  },
  extractGlyphPoints: function(a, b, c, d, e) {
    var f = [],
      g, h, k, n, p, q, m, t, s, r, u, v = b.glyphs[a] || b.glyphs["?"];
    if (v) {
      if (v.o)
        for (b = v._cachedOutline || (v._cachedOutline = v.o.split(" ")), n = b.length, a = 0; a < n;) switch (k = b[a++], k) {
          case "m":
            k = b[a++] * c + d;
            p = b[a++] * c;
            e.moveTo(k, p);
            break;
          case "l":
            k = b[a++] * c + d;
            p = b[a++] * c;
            e.lineTo(k, p);
            break;
          case "q":
            k = b[a++] * c + d;
            p = b[a++] * c;
            t = b[a++] * c + d;
            s = b[a++] * c;
            e.quadraticCurveTo(t, s, k, p);
            if (g = f[f.length - 1])
              for (q = g.x, m = g.y, g = 1, h = this.divisions; g <= h; g++) {
                var y = g / h;
                THREE.Shape.Utils.b2(y, q, t, k);
                THREE.Shape.Utils.b2(y, m, s, p)
              }
            break;
          case "b":
            if (k = b[a++] * c + d, p = b[a++] * c, t = b[a++] * c + d, s = b[a++] * c, r = b[a++] * c + d, u = b[a++] * c, e.bezierCurveTo(t, s, r, u, k, p), g = f[f.length - 1])
              for (q = g.x, m = g.y, g = 1, h = this.divisions; g <= h; g++) y = g / h, THREE.Shape.Utils.b3(y, q, t, r, k), THREE.Shape.Utils.b3(y, m, s, u, p)
        }
      return {
        offset: v.ha * c,
        path: e
      }
    }
  }
};
THREE.FontUtils.generateShapes = function(a, b) {
  b = b || {};
  var c = void 0 !== b.curveSegments ? b.curveSegments : 4,
    d = void 0 !== b.font ? b.font : "helvetiker",
    e = void 0 !== b.weight ? b.weight : "normal",
    f = void 0 !== b.style ? b.style : "normal";
  THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;
  THREE.FontUtils.divisions = c;
  THREE.FontUtils.face = d;
  THREE.FontUtils.weight = e;
  THREE.FontUtils.style = f;
  c = THREE.FontUtils.drawText(a).paths;
  d = [];
  e = 0;
  for (f = c.length; e < f; e++) Array.prototype.push.apply(d, c[e].toShapes());
  return d
};
(function(a) {
  var b = function(a) {
    for (var b = a.length, e = 0, f = b - 1, g = 0; g < b; f = g++) e += a[f].x * a[g].y - a[g].x * a[f].y;
    return .5 * e
  };
  a.Triangulate = function(a, d) {
    var e = a.length;
    if (3 > e) return null;
    var f = [],
      g = [],
      h = [],
      k, n, p;
    if (0 < b(a))
      for (n = 0; n < e; n++) g[n] = n;
    else
      for (n = 0; n < e; n++) g[n] = e - 1 - n;
    var q = 2 * e;
    for (n = e - 1; 2 < e;) {
      if (0 >= q--) {
        console.log("Warning, unable to triangulate polygon!");
        break
      }
      k = n;
      e <= k && (k = 0);
      n = k + 1;
      e <= n && (n = 0);
      p = n + 1;
      e <= p && (p = 0);
      var m;
      a: {
        var t = m = void 0,
          s = void 0,
          r = void 0,
          u = void 0,
          v = void 0,
          y = void 0,
          C = void 0,
          x = void 0,
          t = a[g[k]].x,
          s = a[g[k]].y,
          r = a[g[n]].x,
          u = a[g[n]].y,
          v = a[g[p]].x,
          y = a[g[p]].y;
        if (1E-10 > (r - t) * (y - s) - (u - s) * (v - t)) m = !1;
        else {
          var F = void 0,
            z = void 0,
            G = void 0,
            E = void 0,
            w = void 0,
            D = void 0,
            A = void 0,
            U = void 0,
            M = void 0,
            K = void 0,
            M = U = A = x = C = void 0,
            F = v - r,
            z = y - u,
            G = t - v,
            E = s - y,
            w = r - t,
            D = u - s;
          for (m = 0; m < e; m++)
            if (C = a[g[m]].x, x = a[g[m]].y, !(C === t && x === s || C === r && x === u || C === v && x === y) && (A = C - t, U = x - s, M = C - r, K = x - u, C -= v, x -= y, M = F * K - z * M, A = w * U - D * A, U = G * x - E * C, -1E-10 <= M && -1E-10 <= U && -1E-10 <= A)) {
              m = !1;
              break a
            }
          m = !0
        }
      }
      if (m) {
        f.push([a[g[k]], a[g[n]], a[g[p]]]);
        h.push([g[k], g[n], g[p]]);
        k = n;
        for (p = n + 1; p < e; k++, p++) g[k] = g[p];
        e--;
        q = 2 * e
      }
    }
    return d ? h : f
  };
  a.Triangulate.area = b;
  return a
})(THREE.FontUtils);
self._typeface_js = {
  faces: THREE.FontUtils.faces,
  loadFace: THREE.FontUtils.loadFace
};
THREE.typeface_js = self._typeface_js;
THREE.Audio = function(a) {
  THREE.Object3D.call(this);
  this.type = "Audio";
  this.context = a.context;
  this.source = this.context.createBufferSource();
  this.gain = this.context.createGain();
  this.gain.connect(this.context.destination);
  this.panner = this.context.createPanner();
  this.panner.connect(this.gain)
};
THREE.Audio.prototype = Object.create(THREE.Object3D.prototype);
THREE.Audio.prototype.constructor = THREE.Audio;
THREE.Audio.prototype.load = function(a) {
  var b = this,
    c = new XMLHttpRequest;
  c.open("GET", a, !0);
  c.responseType = "arraybuffer";
  c.onload = function(a) {
    b.context.decodeAudioData(this.response, function(a) {
      b.source.buffer = a;
      b.source.connect(b.panner);
      b.source.start(0)
    })
  };
  c.send();
  return this
};
THREE.Audio.prototype.setLoop = function(a) {
  this.source.loop = a
};
THREE.Audio.prototype.setRefDistance = function(a) {
  this.panner.refDistance = a
};
THREE.Audio.prototype.setRolloffFactor = function(a) {
  this.panner.rolloffFactor = a
};
THREE.Audio.prototype.updateMatrixWorld = function() {
  var a = new THREE.Vector3;
  return function(b) {
    THREE.Object3D.prototype.updateMatrixWorld.call(this, b);
    a.setFromMatrixPosition(this.matrixWorld);
    this.panner.setPosition(a.x, a.y, a.z)
  }
}();
THREE.AudioListener = function() {
  THREE.Object3D.call(this);
  this.type = "AudioListener";
  this.context = new(window.AudioContext || window.webkitAudioContext)
};
THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype);
THREE.AudioListener.prototype.constructor = THREE.AudioListener;
THREE.AudioListener.prototype.updateMatrixWorld = function() {
  var a = new THREE.Vector3,
    b = new THREE.Quaternion,
    c = new THREE.Vector3,
    d = new THREE.Vector3,
    e = new THREE.Vector3,
    f = new THREE.Vector3;
  return function(g) {
    THREE.Object3D.prototype.updateMatrixWorld.call(this, g);
    g = this.context.listener;
    var h = this.up;
    this.matrixWorld.decompose(a, b, c);
    d.set(0, 0, -1).applyQuaternion(b);
    e.subVectors(a, f);
    g.setPosition(a.x, a.y, a.z);
    g.setOrientation(d.x, d.y, d.z, h.x, h.y, h.z);
    g.setVelocity(e.x, e.y, e.z);
    f.copy(a)
  }
}();
THREE.Curve = function() {};
THREE.Curve.prototype.getPoint = function(a) {
  console.log("Warning, getPoint() not implemented!");
  return null
};
THREE.Curve.prototype.getPointAt = function(a) {
  a = this.getUtoTmapping(a);
  return this.getPoint(a)
};
THREE.Curve.prototype.getPoints = function(a) {
  a || (a = 5);
  var b, c = [];
  for (b = 0; b <= a; b++) c.push(this.getPoint(b / a));
  return c
};
THREE.Curve.prototype.getSpacedPoints = function(a) {
  a || (a = 5);
  var b, c = [];
  for (b = 0; b <= a; b++) c.push(this.getPointAt(b / a));
  return c
};
THREE.Curve.prototype.getLength = function() {
  var a = this.getLengths();
  return a[a.length - 1]
};
THREE.Curve.prototype.getLengths = function(a) {
  a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
  if (this.cacheArcLengths && this.cacheArcLengths.length == a + 1 && !this.needsUpdate) return this.cacheArcLengths;
  this.needsUpdate = !1;
  var b = [],
    c, d = this.getPoint(0),
    e, f = 0;
  b.push(0);
  for (e = 1; e <= a; e++) c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;
  return this.cacheArcLengths = b
};
THREE.Curve.prototype.updateArcLengths = function() {
  this.needsUpdate = !0;
  this.getLengths()
};
THREE.Curve.prototype.getUtoTmapping = function(a, b) {
  var c = this.getLengths(),
    d = 0,
    e = c.length,
    f;
  f = b ? b : a * c[e - 1];
  for (var g = 0, h = e - 1, k; g <= h;)
    if (d = Math.floor(g + (h - g) / 2), k = c[d] - f, 0 > k) g = d + 1;
    else if (0 < k) h = d - 1;
  else {
    h = d;
    break
  }
  d = h;
  if (c[d] == f) return d / (e - 1);
  g = c[d];
  return c = (d + (f - g) / (c[d + 1] - g)) / (e - 1)
};
THREE.Curve.prototype.getTangent = function(a) {
  var b = a - 1E-4;
  a += 1E-4;
  0 > b && (b = 0);
  1 < a && (a = 1);
  b = this.getPoint(b);
  return this.getPoint(a).clone().sub(b).normalize()
};
THREE.Curve.prototype.getTangentAt = function(a) {
  a = this.getUtoTmapping(a);
  return this.getTangent(a)
};
THREE.Curve.Utils = {
  tangentQuadraticBezier: function(a, b, c, d) {
    return 2 * (1 - a) * (c - b) + 2 * a * (d - c)
  },
  tangentCubicBezier: function(a, b, c, d, e) {
    return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e
  },
  tangentSpline: function(a, b, c, d, e) {
    return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a)
  },
  interpolate: function(a, b, c, d, e) {
    a = .5 * (c - a);
    d = .5 * (d - b);
    var f = e * e;
    return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b
  }
};
THREE.Curve.create = function(a, b) {
  a.prototype = Object.create(THREE.Curve.prototype);
  a.prototype.constructor = a;
  a.prototype.getPoint = b;
  return a
};
THREE.CurvePath = function() {
  this.curves = [];
  this.bends = [];
  this.autoClose = !1
};
THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype);
THREE.CurvePath.prototype.constructor = THREE.CurvePath;
THREE.CurvePath.prototype.add = function(a) {
  this.curves.push(a)
};
THREE.CurvePath.prototype.checkConnection = function() {};
THREE.CurvePath.prototype.closePath = function() {
  var a = this.curves[0].getPoint(0),
    b = this.curves[this.curves.length - 1].getPoint(1);
  a.equals(b) || this.curves.push(new THREE.LineCurve(b, a))
};
THREE.CurvePath.prototype.getPoint = function(a) {
  var b = a * this.getLength(),
    c = this.getCurveLengths();
  for (a = 0; a < c.length;) {
    if (c[a] >= b) return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), a.getPointAt(b);
    a++
  }
  return null
};
THREE.CurvePath.prototype.getLength = function() {
  var a = this.getCurveLengths();
  return a[a.length - 1]
};
THREE.CurvePath.prototype.getCurveLengths = function() {
  if (this.cacheLengths && this.cacheLengths.length == this.curves.length) return this.cacheLengths;
  var a = [],
    b = 0,
    c, d = this.curves.length;
  for (c = 0; c < d; c++) b += this.curves[c].getLength(), a.push(b);
  return this.cacheLengths = a
};
THREE.CurvePath.prototype.getBoundingBox = function() {
  var a = this.getPoints(),
    b, c, d, e, f, g;
  b = c = Number.NEGATIVE_INFINITY;
  e = f = Number.POSITIVE_INFINITY;
  var h, k, n, p, q = a[0] instanceof THREE.Vector3;
  p = q ? new THREE.Vector3 : new THREE.Vector2;
  k = 0;
  for (n = a.length; k < n; k++) h = a[k], h.x > b ? b = h.x : h.x < e && (e = h.x), h.y > c ? c = h.y : h.y < f && (f = h.y), q && (h.z > d ? d = h.z : h.z < g && (g = h.z)), p.add(h);
  a = {
    minX: e,
    minY: f,
    maxX: b,
    maxY: c
  };
  q && (a.maxZ = d, a.minZ = g);
  return a
};
THREE.CurvePath.prototype.createPointsGeometry = function(a) {
  a = this.getPoints(a, !0);
  return this.createGeometry(a)
};
THREE.CurvePath.prototype.createSpacedPointsGeometry = function(a) {
  a = this.getSpacedPoints(a, !0);
  return this.createGeometry(a)
};
THREE.CurvePath.prototype.createGeometry = function(a) {
  for (var b = new THREE.Geometry, c = 0; c < a.length; c++) b.vertices.push(new THREE.Vector3(a[c].x, a[c].y, a[c].z || 0));
  return b
};
THREE.CurvePath.prototype.addWrapPath = function(a) {
  this.bends.push(a)
};
THREE.CurvePath.prototype.getTransformedPoints = function(a, b) {
  var c = this.getPoints(a),
    d, e;
  b || (b = this.bends);
  d = 0;
  for (e = b.length; d < e; d++) c = this.getWrapPoints(c, b[d]);
  return c
};
THREE.CurvePath.prototype.getTransformedSpacedPoints = function(a, b) {
  var c = this.getSpacedPoints(a),
    d, e;
  b || (b = this.bends);
  d = 0;
  for (e = b.length; d < e; d++) c = this.getWrapPoints(c, b[d]);
  return c
};
THREE.CurvePath.prototype.getWrapPoints = function(a, b) {
  var c = this.getBoundingBox(),
    d, e, f, g, h, k;
  d = 0;
  for (e = a.length; d < e; d++) f = a[d], g = f.x, h = f.y, k = g / c.maxX, k = b.getUtoTmapping(k, g), g = b.getPoint(k), k = b.getTangent(k), k.set(-k.y, k.x).multiplyScalar(h), f.x = g.x + k.x, f.y = g.y + k.y;
  return a
};
THREE.Gyroscope = function() {
  THREE.Object3D.call(this)
};
THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;
THREE.Gyroscope.prototype.updateMatrixWorld = function() {
  var a = new THREE.Vector3,
    b = new THREE.Quaternion,
    c = new THREE.Vector3,
    d = new THREE.Vector3,
    e = new THREE.Quaternion,
    f = new THREE.Vector3;
  return function(g) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || g) this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorld.decompose(d, e, f), this.matrix.decompose(a, b, c), this.matrixWorld.compose(d, b, f)) : this.matrixWorld.copy(this.matrix), this.matrixWorldNeedsUpdate = !1, g = !0;
    for (var h = 0, k = this.children.length; h < k; h++) this.children[h].updateMatrixWorld(g)
  }
}();
THREE.Path = function(a) {
  THREE.CurvePath.call(this);
  this.actions = [];
  a && this.fromPoints(a)
};
THREE.Path.prototype = Object.create(THREE.CurvePath.prototype);
THREE.Path.prototype.constructor = THREE.Path;
THREE.PathActions = {
  MOVE_TO: "moveTo",
  LINE_TO: "lineTo",
  QUADRATIC_CURVE_TO: "quadraticCurveTo",
  BEZIER_CURVE_TO: "bezierCurveTo",
  CSPLINE_THRU: "splineThru",
  ARC: "arc",
  ELLIPSE: "ellipse"
};
THREE.Path.prototype.fromPoints = function(a) {
  this.moveTo(a[0].x, a[0].y);
  for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
};
THREE.Path.prototype.moveTo = function(a, b) {
  var c = Array.prototype.slice.call(arguments);
  this.actions.push({
    action: THREE.PathActions.MOVE_TO,
    args: c
  })
};
THREE.Path.prototype.lineTo = function(a, b) {
  var c = Array.prototype.slice.call(arguments),
    d = this.actions[this.actions.length - 1].args,
    d = new THREE.LineCurve(new THREE.Vector2(d[d.length - 2], d[d.length - 1]), new THREE.Vector2(a, b));
  this.curves.push(d);
  this.actions.push({
    action: THREE.PathActions.LINE_TO,
    args: c
  })
};
THREE.Path.prototype.quadraticCurveTo = function(a, b, c, d) {
  var e = Array.prototype.slice.call(arguments),
    f = this.actions[this.actions.length - 1].args,
    f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length - 2], f[f.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
  this.curves.push(f);
  this.actions.push({
    action: THREE.PathActions.QUADRATIC_CURVE_TO,
    args: e
  })
};
THREE.Path.prototype.bezierCurveTo = function(a, b, c, d, e, f) {
  var g = Array.prototype.slice.call(arguments),
    h = this.actions[this.actions.length - 1].args,
    h = new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length - 2], h[h.length - 1]), new THREE.Vector2(a, b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
  this.curves.push(h);
  this.actions.push({
    action: THREE.PathActions.BEZIER_CURVE_TO,
    args: g
  })
};
THREE.Path.prototype.splineThru = function(a) {
  var b = Array.prototype.slice.call(arguments),
    c = this.actions[this.actions.length - 1].args,
    c = [new THREE.Vector2(c[c.length - 2], c[c.length - 1])];
  Array.prototype.push.apply(c, a);
  c = new THREE.SplineCurve(c);
  this.curves.push(c);
  this.actions.push({
    action: THREE.PathActions.CSPLINE_THRU,
    args: b
  })
};
THREE.Path.prototype.arc = function(a, b, c, d, e, f) {
  var g = this.actions[this.actions.length - 1].args;
  this.absarc(a + g[g.length - 2], b + g[g.length - 1], c, d, e, f)
};
THREE.Path.prototype.absarc = function(a, b, c, d, e, f) {
  this.absellipse(a, b, c, c, d, e, f)
};
THREE.Path.prototype.ellipse = function(a, b, c, d, e, f, g) {
  var h = this.actions[this.actions.length - 1].args;
  this.absellipse(a + h[h.length - 2], b + h[h.length - 1], c, d, e, f, g)
};
THREE.Path.prototype.absellipse = function(a, b, c, d, e, f, g) {
  var h = Array.prototype.slice.call(arguments),
    k = new THREE.EllipseCurve(a, b, c, d, e, f, g);
  this.curves.push(k);
  k = k.getPoint(1);
  h.push(k.x);
  h.push(k.y);
  this.actions.push({
    action: THREE.PathActions.ELLIPSE,
    args: h
  })
};
THREE.Path.prototype.getSpacedPoints = function(a, b) {
  a || (a = 40);
  for (var c = [], d = 0; d < a; d++) c.push(this.getPoint(d / a));
  return c
};
THREE.Path.prototype.getPoints = function(a, b) {
  if (this.useSpacedPoints) return console.log("tata"), this.getSpacedPoints(a, b);
  a = a || 12;
  var c = [],
    d, e, f, g, h, k, n, p, q, m, t, s, r;
  d = 0;
  for (e = this.actions.length; d < e; d++) switch (f = this.actions[d], g = f.action, f = f.args, g) {
    case THREE.PathActions.MOVE_TO:
      c.push(new THREE.Vector2(f[0], f[1]));
      break;
    case THREE.PathActions.LINE_TO:
      c.push(new THREE.Vector2(f[0], f[1]));
      break;
    case THREE.PathActions.QUADRATIC_CURVE_TO:
      h = f[2];
      k = f[3];
      q = f[0];
      m = f[1];
      0 < c.length ? (g = c[c.length - 1], t = g.x, s = g.y) : (g = this.actions[d - 1].args, t = g[g.length - 2], s = g[g.length - 1]);
      for (f = 1; f <= a; f++) r = f / a, g = THREE.Shape.Utils.b2(r, t, q, h), r = THREE.Shape.Utils.b2(r, s, m, k), c.push(new THREE.Vector2(g, r));
      break;
    case THREE.PathActions.BEZIER_CURVE_TO:
      h = f[4];
      k = f[5];
      q = f[0];
      m = f[1];
      n = f[2];
      p = f[3];
      0 < c.length ? (g = c[c.length - 1], t = g.x, s = g.y) : (g = this.actions[d - 1].args, t = g[g.length - 2], s = g[g.length - 1]);
      for (f = 1; f <= a; f++) r = f / a, g = THREE.Shape.Utils.b3(r, t, q, n, h), r = THREE.Shape.Utils.b3(r, s, m, p, k), c.push(new THREE.Vector2(g, r));
      break;
    case THREE.PathActions.CSPLINE_THRU:
      g = this.actions[d - 1].args;
      r = [new THREE.Vector2(g[g.length - 2], g[g.length - 1])];
      g = a * f[0].length;
      r = r.concat(f[0]);
      r = new THREE.SplineCurve(r);
      for (f = 1; f <= g; f++) c.push(r.getPointAt(f / g));
      break;
    case THREE.PathActions.ARC:
      h = f[0];
      k = f[1];
      m = f[2];
      n = f[3];
      g = f[4];
      q = !!f[5];
      t = g - n;
      s = 2 * a;
      for (f = 1; f <= s; f++) r = f / s, q || (r = 1 - r), r = n + r * t, g = h + m * Math.cos(r), r = k + m * Math.sin(r), c.push(new THREE.Vector2(g, r));
      break;
    case THREE.PathActions.ELLIPSE:
      for (h = f[0], k = f[1], m = f[2], p = f[3], n = f[4], g = f[5], q = !!f[6], t = g - n, s = 2 * a, f = 1; f <= s; f++) r = f / s, q || (r = 1 - r), r = n + r * t, g = h + m * Math.cos(r), r = k + p * Math.sin(r), c.push(new THREE.Vector2(g, r))
  }
  d = c[c.length - 1];
  1E-10 > Math.abs(d.x - c[0].x) && 1E-10 > Math.abs(d.y - c[0].y) && c.splice(c.length - 1, 1);
  b && c.push(c[0]);
  return c
};
THREE.Path.prototype.toShapes = function(a, b) {
  function c(a) {
    for (var b = [], c = 0, d = a.length; c < d; c++) {
      var e = a[c],
        g = new THREE.Shape;
      g.actions = e.actions;
      g.curves = e.curves;
      b.push(g)
    }
    return b
  }

  function d(a, b) {
    for (var c = b.length, d = !1, e = c - 1, g = 0; g < c; e = g++) {
      var f = b[e],
        h = b[g],
        k = h.x - f.x,
        m = h.y - f.y;
      if (1E-10 < Math.abs(m)) {
        if (0 > m && (f = b[g], k = -k, h = b[e], m = -m), !(a.y < f.y || a.y > h.y))
          if (a.y == f.y) {
            if (a.x == f.x) return !0
          } else {
            e = m * (a.x - f.x) - k * (a.y - f.y);
            if (0 == e) return !0;
            0 > e || (d = !d)
          }
      } else if (a.y == f.y && (h.x <= a.x && a.x <= f.x || f.x <= a.x && a.x <= h.x)) return !0
    }
    return d
  }
  var e = function(a) {
    var b, c, d, e, f = [],
      g = new THREE.Path;
    b = 0;
    for (c = a.length; b < c; b++) d = a[b], e = d.args, d = d.action, d == THREE.PathActions.MOVE_TO && 0 != g.actions.length && (f.push(g), g = new THREE.Path), g[d].apply(g, e);
    0 != g.actions.length && f.push(g);
    return f
  }(this.actions);
  if (0 == e.length) return [];
  if (!0 === b) return c(e);
  var f, g, h, k = [];
  if (1 == e.length) return g = e[0], h = new THREE.Shape, h.actions = g.actions, h.curves = g.curves, k.push(h), k;
  var n = !THREE.Shape.Utils.isClockWise(e[0].getPoints()),
    n = a ? !n : n;
  h = [];
  var p = [],
    q = [],
    m = 0,
    t;
  p[m] = void 0;
  q[m] = [];
  var s, r;
  s = 0;
  for (r = e.length; s < r; s++) g = e[s], t = g.getPoints(), f = THREE.Shape.Utils.isClockWise(t), (f = a ? !f : f) ? (!n && p[m] && m++, p[m] = {
    s: new THREE.Shape,
    p: t
  }, p[m].s.actions = g.actions, p[m].s.curves = g.curves, n && m++, q[m] = []) : q[m].push({
    h: g,
    p: t[0]
  });
  if (!p[0]) return c(e);
  if (1 < p.length) {
    s = !1;
    r = [];
    g = 0;
    for (e = p.length; g < e; g++) h[g] = [];
    g = 0;
    for (e = p.length; g < e; g++)
      for (f = q[g], n = 0; n < f.length; n++) {
        m = f[n];
        t = !0;
        for (var u = 0; u < p.length; u++) d(m.p, p[u].p) && (g != u && r.push({
          froms: g,
          tos: u,
          hole: n
        }), t ? (t = !1, h[u].push(m)) : s = !0);
        t && h[g].push(m)
      }
    0 < r.length && (s || (q = h))
  }
  s = 0;
  for (r = p.length; s < r; s++)
    for (h = p[s].s, k.push(h), g = q[s], e = 0, f = g.length; e < f; e++) h.holes.push(g[e].h);
  return k
};
THREE.Shape = function() {
  THREE.Path.apply(this, arguments);
  this.holes = []
};
THREE.Shape.prototype = Object.create(THREE.Path.prototype);
THREE.Shape.prototype.constructor = THREE.Shape;
THREE.Shape.prototype.extrude = function(a) {
  return new THREE.ExtrudeGeometry(this, a)
};
THREE.Shape.prototype.makeGeometry = function(a) {
  return new THREE.ShapeGeometry(this, a)
};
THREE.Shape.prototype.getPointsHoles = function(a) {
  var b, c = this.holes.length,
    d = [];
  for (b = 0; b < c; b++) d[b] = this.holes[b].getTransformedPoints(a, this.bends);
  return d
};
THREE.Shape.prototype.getSpacedPointsHoles = function(a) {
  var b, c = this.holes.length,
    d = [];
  for (b = 0; b < c; b++) d[b] = this.holes[b].getTransformedSpacedPoints(a, this.bends);
  return d
};
THREE.Shape.prototype.extractAllPoints = function(a) {
  return {
    shape: this.getTransformedPoints(a),
    holes: this.getPointsHoles(a)
  }
};
THREE.Shape.prototype.extractPoints = function(a) {
  return this.useSpacedPoints ? this.extractAllSpacedPoints(a) : this.extractAllPoints(a)
};
THREE.Shape.prototype.extractAllSpacedPoints = function(a) {
  return {
    shape: this.getTransformedSpacedPoints(a),
    holes: this.getSpacedPointsHoles(a)
  }
};
THREE.Shape.Utils = {
  triangulateShape: function(a, b) {
    function c(a, b, c) {
      return a.x != b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y
    }

    function d(a, b, d, e, g) {
      var f = b.x - a.x,
        h = b.y - a.y,
        k = e.x - d.x,
        n = e.y - d.y,
        p = a.x - d.x,
        q = a.y - d.y,
        G = h * k - f * n,
        E = h * p - f * q;
      if (1E-10 < Math.abs(G)) {
        if (0 < G) {
          if (0 > E || E > G) return [];
          k = n * p - k * q;
          if (0 > k || k > G) return []
        } else {
          if (0 < E || E < G) return [];
          k = n * p - k * q;
          if (0 < k || k < G) return []
        }
        if (0 == k) return !g || 0 != E && E != G ? [a] : [];
        if (k == G) return !g || 0 != E && E != G ? [b] : [];
        if (0 == E) return [d];
        if (E == G) return [e];
        g = k / G;
        return [{
          x: a.x + g * f,
          y: a.y + g * h
        }]
      }
      if (0 != E || n * p != k * q) return [];
      h = 0 == f && 0 == h;
      k = 0 == k && 0 == n;
      if (h && k) return a.x != d.x || a.y != d.y ? [] : [a];
      if (h) return c(d, e, a) ? [a] : [];
      if (k) return c(a, b, d) ? [d] : [];
      0 != f ? (a.x < b.x ? (f = a, k = a.x, h = b, a = b.x) : (f = b, k = b.x, h = a, a = a.x), d.x < e.x ? (b = d, G = d.x, n = e, d = e.x) : (b = e, G = e.x, n = d, d = d.x)) : (a.y < b.y ? (f = a, k = a.y, h = b, a = b.y) : (f = b, k = b.y, h = a, a = a.y), d.y < e.y ? (b = d, G = d.y, n = e, d = e.y) : (b = e, G = e.y, n = d, d = d.y));
      return k <= G ? a < G ? [] : a == G ? g ? [] : [b] : a <= d ? [b, h] : [b, n] : k > d ? [] : k == d ? g ? [] : [f] : a <= d ? [f, h] : [f, n]
    }

    function e(a, b, c, d) {
      var e = b.x - a.x,
        f = b.y - a.y;
      b = c.x - a.x;
      c = c.y - a.y;
      var g = d.x - a.x;
      d = d.y - a.y;
      a = e * c - f * b;
      e = e * d - f * g;
      return 1E-10 < Math.abs(a) ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e
    }
    var f, g, h, k, n, p = {};
    h = a.concat();
    f = 0;
    for (g = b.length; f < g; f++) Array.prototype.push.apply(h, b[f]);
    f = 0;
    for (g = h.length; f < g; f++) n = h[f].x + ":" + h[f].y, void 0 !== p[n] && console.log("Duplicate point", n), p[n] = f;
    f = function(a, b) {
      function c(a, b) {
        var d = h.length - 1,
          f = a - 1;
        0 > f && (f = d);
        var g = a + 1;
        g > d && (g = 0);
        d = e(h[a], h[f], h[g], k[b]);
        if (!d) return !1;
        d = k.length - 1;
        f = b - 1;
        0 > f && (f = d);
        g = b + 1;
        g > d && (g = 0);
        return (d = e(k[b], k[f], k[g], h[a])) ? !0 : !1
      }

      function f(a, b) {
        var c, e;
        for (c = 0; c < h.length; c++)
          if (e = c + 1, e %= h.length, e = d(a, b, h[c], h[e], !0), 0 < e.length) return !0;
        return !1
      }

      function g(a, c) {
        var e, f, h, k;
        for (e = 0; e < n.length; e++)
          for (f = b[n[e]], h = 0; h < f.length; h++)
            if (k = h + 1, k %= f.length, k = d(a, c, f[h], f[k], !0), 0 < k.length) return !0;
        return !1
      }
      var h = a.concat(),
        k, n = [],
        p, q, z, G, E, w = [],
        D, A, U, M = 0;
      for (p = b.length; M < p; M++) n.push(M);
      D = 0;
      for (var K = 2 * n.length; 0 < n.length;) {
        K--;
        if (0 > K) {
          console.log("Infinite Loop! Holes left:" + n.length + ", Probably Hole outside Shape!");
          break
        }
        for (q = D; q < h.length; q++) {
          z = h[q];
          p = -1;
          for (M = 0; M < n.length; M++)
            if (G = n[M], E = z.x + ":" + z.y + ":" + G, void 0 === w[E]) {
              k = b[G];
              for (A = 0; A < k.length; A++)
                if (G = k[A], c(q, A) && !f(z, G) && !g(z, G)) {
                  p = A;
                  n.splice(M, 1);
                  D = h.slice(0, q + 1);
                  G = h.slice(q);
                  A = k.slice(p);
                  U = k.slice(0, p + 1);
                  h = D.concat(A).concat(U).concat(G);
                  D = q;
                  break
                }
              if (0 <= p) break;
              w[E] = !0
            }
          if (0 <= p) break
        }
      }
      return h
    }(a, b);
    var q = THREE.FontUtils.Triangulate(f, !1);
    f = 0;
    for (g = q.length; f < g; f++)
      for (k = q[f], h = 0; 3 > h; h++) n = k[h].x + ":" + k[h].y, n = p[n], void 0 !== n && (k[h] = n);
    return q.concat()
  },
  isClockWise: function(a) {
    return 0 > THREE.FontUtils.Triangulate.area(a)
  },
  b2p0: function(a, b) {
    var c = 1 - a;
    return c * c * b
  },
  b2p1: function(a, b) {
    return 2 * (1 - a) * a * b
  },
  b2p2: function(a, b) {
    return a * a * b
  },
  b2: function(a, b, c, d) {
    return this.b2p0(a, b) + this.b2p1(a, c) + this.b2p2(a, d)
  },
  b3p0: function(a, b) {
    var c = 1 - a;
    return c * c * c * b
  },
  b3p1: function(a, b) {
    var c = 1 - a;
    return 3 * c * c * a * b
  },
  b3p2: function(a, b) {
    return 3 * (1 - a) * a * a * b
  },
  b3p3: function(a, b) {
    return a * a * a * b
  },
  b3: function(a, b, c, d, e) {
    return this.b3p0(a, b) + this.b3p1(a, c) + this.b3p2(a, d) + this.b3p3(a, e)
  }
};
THREE.LineCurve = function(a, b) {
  this.v1 = a;
  this.v2 = b
};
THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.LineCurve.prototype.constructor = THREE.LineCurve;
THREE.LineCurve.prototype.getPoint = function(a) {
  var b = this.v2.clone().sub(this.v1);
  b.multiplyScalar(a).add(this.v1);
  return b
};
THREE.LineCurve.prototype.getPointAt = function(a) {
  return this.getPoint(a)
};
THREE.LineCurve.prototype.getTangent = function(a) {
  return this.v2.clone().sub(this.v1).normalize()
};
THREE.QuadraticBezierCurve = function(a, b, c) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c
};
THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
THREE.QuadraticBezierCurve.prototype.getPoint = function(a) {
  var b = new THREE.Vector2;
  b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
  b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
  return b
};
THREE.QuadraticBezierCurve.prototype.getTangent = function(a) {
  var b = new THREE.Vector2;
  b.x = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.x, this.v1.x, this.v2.x);
  b.y = THREE.Curve.Utils.tangentQuadraticBezier(a, this.v0.y, this.v1.y, this.v2.y);
  return b.normalize()
};
THREE.CubicBezierCurve = function(a, b, c, d) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
  this.v3 = d
};
THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
THREE.CubicBezierCurve.prototype.getPoint = function(a) {
  var b;
  b = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  a = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  return new THREE.Vector2(b, a)
};
THREE.CubicBezierCurve.prototype.getTangent = function(a) {
  var b;
  b = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  a = THREE.Curve.Utils.tangentCubicBezier(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  b = new THREE.Vector2(b, a);
  b.normalize();
  return b
};
THREE.SplineCurve = function(a) {
  this.points = void 0 == a ? [] : a
};
THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
THREE.SplineCurve.prototype.getPoint = function(a) {
  var b = this.points;
  a *= b.length - 1;
  var c = Math.floor(a);
  a -= c;
  var d = b[0 == c ? c : c - 1],
    e = b[c],
    f = b[c > b.length - 2 ? b.length - 1 : c + 1],
    b = b[c > b.length - 3 ? b.length - 1 : c + 2],
    c = new THREE.Vector2;
  c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a);
  c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a);
  return c
};
THREE.EllipseCurve = function(a, b, c, d, e, f, g) {
  this.aX = a;
  this.aY = b;
  this.xRadius = c;
  this.yRadius = d;
  this.aStartAngle = e;
  this.aEndAngle = f;
  this.aClockwise = g
};
THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
THREE.EllipseCurve.prototype.getPoint = function(a) {
  var b = this.aEndAngle - this.aStartAngle;
  0 > b && (b += 2 * Math.PI);
  b > 2 * Math.PI && (b -= 2 * Math.PI);
  a = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b;
  b = new THREE.Vector2;
  b.x = this.aX + this.xRadius * Math.cos(a);
  b.y = this.aY + this.yRadius * Math.sin(a);
  return b
};
THREE.ArcCurve = function(a, b, c, d, e, f) {
  THREE.EllipseCurve.call(this, a, b, c, c, d, e, f)
};
THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
THREE.LineCurve3 = THREE.Curve.create(function(a, b) {
  this.v1 = a;
  this.v2 = b
}, function(a) {
  var b = new THREE.Vector3;
  b.subVectors(this.v2, this.v1);
  b.multiplyScalar(a);
  b.add(this.v1);
  return b
});
THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(a, b, c) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c
}, function(a) {
  var b = new THREE.Vector3;
  b.x = THREE.Shape.Utils.b2(a, this.v0.x, this.v1.x, this.v2.x);
  b.y = THREE.Shape.Utils.b2(a, this.v0.y, this.v1.y, this.v2.y);
  b.z = THREE.Shape.Utils.b2(a, this.v0.z, this.v1.z, this.v2.z);
  return b
});
THREE.CubicBezierCurve3 = THREE.Curve.create(function(a, b, c, d) {
  this.v0 = a;
  this.v1 = b;
  this.v2 = c;
  this.v3 = d
}, function(a) {
  var b = new THREE.Vector3;
  b.x = THREE.Shape.Utils.b3(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x);
  b.y = THREE.Shape.Utils.b3(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y);
  b.z = THREE.Shape.Utils.b3(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z);
  return b
});
THREE.SplineCurve3 = THREE.Curve.create(function(a) {
  this.points = void 0 == a ? [] : a
}, function(a) {
  var b = this.points;
  a *= b.length - 1;
  var c = Math.floor(a);
  a -= c;
  var d = b[0 == c ? c : c - 1],
    e = b[c],
    f = b[c > b.length - 2 ? b.length - 1 : c + 1],
    b = b[c > b.length - 3 ? b.length - 1 : c + 2],
    c = new THREE.Vector3;
  c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a);
  c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a);
  c.z = THREE.Curve.Utils.interpolate(d.z, e.z, f.z, b.z, a);
  return c
});
THREE.ClosedSplineCurve3 = THREE.Curve.create(function(a) {
  this.points = void 0 == a ? [] : a
}, function(a) {
  var b = this.points;
  a *= b.length - 0;
  var c = Math.floor(a);
  a -= c;
  var c = c + (0 < c ? 0 : (Math.floor(Math.abs(c) / b.length) + 1) * b.length),
    d = b[(c - 1) % b.length],
    e = b[c % b.length],
    f = b[(c + 1) % b.length],
    b = b[(c + 2) % b.length],
    c = new THREE.Vector3;
  c.x = THREE.Curve.Utils.interpolate(d.x, e.x, f.x, b.x, a);
  c.y = THREE.Curve.Utils.interpolate(d.y, e.y, f.y, b.y, a);
  c.z = THREE.Curve.Utils.interpolate(d.z, e.z, f.z, b.z, a);
  return c
});
THREE.AnimationHandler = {
  LINEAR: 0,
  CATMULLROM: 1,
  CATMULLROM_FORWARD: 2,
  add: function() {
    console.warn("THREE.AnimationHandler.add() has been deprecated.")
  },
  get: function() {
    console.warn("THREE.AnimationHandler.get() has been deprecated.")
  },
  remove: function() {
    console.warn("THREE.AnimationHandler.remove() has been deprecated.")
  },
  animations: [],
  init: function(a) {
    if (!0 === a.initialized) return a;
    for (var b = 0; b < a.hierarchy.length; b++) {
      for (var c = 0; c < a.hierarchy[b].keys.length; c++)
        if (0 > a.hierarchy[b].keys[c].time && (a.hierarchy[b].keys[c].time = 0), void 0 !== a.hierarchy[b].keys[c].rot && !(a.hierarchy[b].keys[c].rot instanceof THREE.Quaternion)) {
          var d = a.hierarchy[b].keys[c].rot;
          a.hierarchy[b].keys[c].rot = (new THREE.Quaternion).fromArray(d)
        }
      if (a.hierarchy[b].keys.length && void 0 !== a.hierarchy[b].keys[0].morphTargets) {
        d = {};
        for (c = 0; c < a.hierarchy[b].keys.length; c++)
          for (var e = 0; e < a.hierarchy[b].keys[c].morphTargets.length; e++) {
            var f = a.hierarchy[b].keys[c].morphTargets[e];
            d[f] = -1
          }
        a.hierarchy[b].usedMorphTargets = d;
        for (c = 0; c < a.hierarchy[b].keys.length; c++) {
          var g = {};
          for (f in d) {
            for (e = 0; e < a.hierarchy[b].keys[c].morphTargets.length; e++)
              if (a.hierarchy[b].keys[c].morphTargets[e] === f) {
                g[f] = a.hierarchy[b].keys[c].morphTargetsInfluences[e];
                break
              }
            e === a.hierarchy[b].keys[c].morphTargets.length && (g[f] = 0)
          }
          a.hierarchy[b].keys[c].morphTargetsInfluences = g
        }
      }
      for (c = 1; c < a.hierarchy[b].keys.length; c++) a.hierarchy[b].keys[c].time === a.hierarchy[b].keys[c - 1].time && (a.hierarchy[b].keys.splice(c, 1), c--);
      for (c = 0; c < a.hierarchy[b].keys.length; c++) a.hierarchy[b].keys[c].index = c
    }
    a.initialized = !0;
    return a
  },
  parse: function(a) {
    var b = function(a, c) {
        c.push(a);
        for (var d = 0; d < a.children.length; d++) b(a.children[d], c)
      },
      c = [];
    if (a instanceof THREE.SkinnedMesh)
      for (var d = 0; d < a.skeleton.bones.length; d++) c.push(a.skeleton.bones[d]);
    else b(a, c);
    return c
  },
  play: function(a) {
    -1 === this.animations.indexOf(a) && this.animations.push(a)
  },
  stop: function(a) {
    a = this.animations.indexOf(a); - 1 !== a && this.animations.splice(a, 1)
  },
  update: function(a) {
    for (var b = 0; b < this.animations.length; b++) this.animations[b].resetBlendWeights();
    for (b = 0; b < this.animations.length; b++) this.animations[b].update(a)
  }
};
THREE.Animation = function(a, b) {
  this.root = a;
  this.data = THREE.AnimationHandler.init(b);
  this.hierarchy = THREE.AnimationHandler.parse(a);
  this.currentTime = 0;
  this.timeScale = 1;
  this.isPlaying = !1;
  this.loop = !0;
  this.weight = 0;
  this.interpolationType = THREE.AnimationHandler.LINEAR
};
THREE.Animation.prototype.keyTypes = ["pos", "rot", "scl"];
THREE.Animation.prototype.play = function(a, b) {
  this.currentTime = void 0 !== a ? a : 0;
  this.weight = void 0 !== b ? b : 1;
  this.isPlaying = !0;
  this.reset();
  THREE.AnimationHandler.play(this)
};
THREE.Animation.prototype.stop = function() {
  this.isPlaying = !1;
  THREE.AnimationHandler.stop(this)
};
THREE.Animation.prototype.reset = function() {
  for (var a = 0, b = this.hierarchy.length; a < b; a++) {
    var c = this.hierarchy[a];
    void 0 === c.animationCache && (c.animationCache = {
      animations: {},
      blending: {
        positionWeight: 0,
        quaternionWeight: 0,
        scaleWeight: 0
      }
    });
    void 0 === c.animationCache.animations[this.data.name] && (c.animationCache.animations[this.data.name] = {}, c.animationCache.animations[this.data.name].prevKey = {
      pos: 0,
      rot: 0,
      scl: 0
    }, c.animationCache.animations[this.data.name].nextKey = {
      pos: 0,
      rot: 0,
      scl: 0
    }, c.animationCache.animations[this.data.name].originalMatrix = c.matrix);
    for (var c = c.animationCache.animations[this.data.name], d = 0; 3 > d; d++) {
      for (var e = this.keyTypes[d], f = this.data.hierarchy[a].keys[0], g = this.getNextKeyWith(e, a, 1); g.time < this.currentTime && g.index > f.index;) f = g, g = this.getNextKeyWith(e, a, g.index + 1);
      c.prevKey[e] = f;
      c.nextKey[e] = g
    }
  }
};
THREE.Animation.prototype.resetBlendWeights = function() {
  for (var a = 0, b = this.hierarchy.length; a < b; a++) {
    var c = this.hierarchy[a];
    void 0 !== c.animationCache && (c.animationCache.blending.positionWeight = 0, c.animationCache.blending.quaternionWeight = 0, c.animationCache.blending.scaleWeight = 0)
  }
};
THREE.Animation.prototype.update = function() {
  var a = [],
    b = new THREE.Vector3,
    c = new THREE.Vector3,
    d = new THREE.Quaternion,
    e = function(a, b) {
      var c = [],
        d = [],
        e, q, m, t, s, r;
      e = (a.length - 1) * b;
      q = Math.floor(e);
      e -= q;
      c[0] = 0 === q ? q : q - 1;
      c[1] = q;
      c[2] = q > a.length - 2 ? q : q + 1;
      c[3] = q > a.length - 3 ? q : q + 2;
      q = a[c[0]];
      t = a[c[1]];
      s = a[c[2]];
      r = a[c[3]];
      c = e * e;
      m = e * c;
      d[0] = f(q[0], t[0], s[0], r[0], e, c, m);
      d[1] = f(q[1], t[1], s[1], r[1], e, c, m);
      d[2] = f(q[2], t[2], s[2], r[2], e, c, m);
      return d
    },
    f = function(a, b, c, d, e, f, m) {
      a = .5 * (c - a);
      d = .5 * (d - b);
      return (2 * (b - c) + a + d) * m + (-3 * (b - c) - 2 * a - d) * f + a * e + b
    };
  return function(f) {
    if (!1 !== this.isPlaying && (this.currentTime += f * this.timeScale, 0 !== this.weight)) {
      f = this.data.length;
      if (this.currentTime > f || 0 > this.currentTime) this.loop ? (this.currentTime %= f, 0 > this.currentTime && (this.currentTime += f), this.reset()) : this.stop();
      f = 0;
      for (var h = this.hierarchy.length; f < h; f++)
        for (var k = this.hierarchy[f], n = k.animationCache.animations[this.data.name], p = k.animationCache.blending, q = 0; 3 > q; q++) {
          var m = this.keyTypes[q],
            t = n.prevKey[m],
            s = n.nextKey[m];
          if (0 < this.timeScale && s.time <= this.currentTime || 0 > this.timeScale && t.time >= this.currentTime) {
            t = this.data.hierarchy[f].keys[0];
            for (s = this.getNextKeyWith(m, f, 1); s.time < this.currentTime && s.index > t.index;) t = s, s = this.getNextKeyWith(m, f, s.index + 1);
            n.prevKey[m] = t;
            n.nextKey[m] = s
          }
          var r = (this.currentTime - t.time) / (s.time - t.time),
            u = t[m],
            v = s[m];
          0 > r && (r = 0);
          1 < r && (r = 1);
          if ("pos" === m)
            if (this.interpolationType === THREE.AnimationHandler.LINEAR) c.x = u[0] + (v[0] - u[0]) * r, c.y = u[1] + (v[1] - u[1]) * r, c.z = u[2] + (v[2] - u[2]) * r, t = this.weight / (this.weight + p.positionWeight), k.position.lerp(c, t), p.positionWeight += this.weight;
            else {
              if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD) a[0] = this.getPrevKeyWith("pos", f, t.index - 1).pos, a[1] = u, a[2] = v, a[3] = this.getNextKeyWith("pos", f, s.index + 1).pos, r = .33 * r + .33, s = e(a, r), t = this.weight / (this.weight + p.positionWeight), p.positionWeight += this.weight, m = k.position, m.x += (s[0] - m.x) * t, m.y += (s[1] - m.y) * t, m.z += (s[2] - m.z) * t, this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (r = e(a, 1.01 * r), b.set(r[0], r[1], r[2]), b.sub(m), b.y = 0, b.normalize(), r = Math.atan2(b.x, b.z), k.rotation.set(0, r, 0))
            } else "rot" === m ? (THREE.Quaternion.slerp(u, v, d, r), 0 === p.quaternionWeight ? (k.quaternion.copy(d), p.quaternionWeight = this.weight) : (t = this.weight / (this.weight + p.quaternionWeight), THREE.Quaternion.slerp(k.quaternion, d, k.quaternion, t), p.quaternionWeight += this.weight)) : "scl" === m && (c.x = u[0] + (v[0] - u[0]) * r, c.y = u[1] + (v[1] - u[1]) * r, c.z = u[2] + (v[2] - u[2]) * r, t = this.weight / (this.weight + p.scaleWeight), k.scale.lerp(c, t), p.scaleWeight += this.weight)
        }
      return !0
    }
  }
}();
THREE.Animation.prototype.getNextKeyWith = function(a, b, c) {
  var d = this.data.hierarchy[b].keys;
  for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < d.length - 1 ? c : d.length - 1 : c % d.length; c < d.length; c++)
    if (void 0 !== d[c][a]) return d[c];
  return this.data.hierarchy[b].keys[0]
};
THREE.Animation.prototype.getPrevKeyWith = function(a, b, c) {
  var d = this.data.hierarchy[b].keys;
  for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + d.length; 0 <= c; c--)
    if (void 0 !== d[c][a]) return d[c];
  return this.data.hierarchy[b].keys[d.length - 1]
};
THREE.KeyFrameAnimation = function(a) {
  this.root = a.node;
  this.data = THREE.AnimationHandler.init(a);
  this.hierarchy = THREE.AnimationHandler.parse(this.root);
  this.currentTime = 0;
  this.timeScale = .001;
  this.isPlaying = !1;
  this.loop = this.isPaused = !0;
  a = 0;
  for (var b = this.hierarchy.length; a < b; a++) {
    var c = this.data.hierarchy[a].sids,
      d = this.hierarchy[a];
    if (this.data.hierarchy[a].keys.length && c) {
      for (var e = 0; e < c.length; e++) {
        var f = c[e],
          g = this.getNextKeyWith(f, a, 0);
        g && g.apply(f)
      }
      d.matrixAutoUpdate = !1;
      this.data.hierarchy[a].node.updateMatrix();
      d.matrixWorldNeedsUpdate = !0
    }
  }
};
THREE.KeyFrameAnimation.prototype.play = function(a) {
  this.currentTime = void 0 !== a ? a : 0;
  if (!1 === this.isPlaying) {
    this.isPlaying = !0;
    var b = this.hierarchy.length,
      c, d;
    for (a = 0; a < b; a++) c = this.hierarchy[a], d = this.data.hierarchy[a], void 0 === d.animationCache && (d.animationCache = {}, d.animationCache.prevKey = null, d.animationCache.nextKey = null, d.animationCache.originalMatrix = c.matrix), c = this.data.hierarchy[a].keys, c.length && (d.animationCache.prevKey = c[0], d.animationCache.nextKey = c[1], this.startTime = Math.min(c[0].time, this.startTime), this.endTime = Math.max(c[c.length - 1].time, this.endTime));
    this.update(0)
  }
  this.isPaused = !1;
  THREE.AnimationHandler.play(this)
};
THREE.KeyFrameAnimation.prototype.stop = function() {
  this.isPaused = this.isPlaying = !1;
  THREE.AnimationHandler.stop(this);
  for (var a = 0; a < this.data.hierarchy.length; a++) {
    var b = this.hierarchy[a],
      c = this.data.hierarchy[a];
    if (void 0 !== c.animationCache) {
      var d = c.animationCache.originalMatrix;
      d.copy(b.matrix);
      b.matrix = d;
      delete c.animationCache
    }
  }
};
THREE.KeyFrameAnimation.prototype.update = function(a) {
  if (!1 !== this.isPlaying) {
    this.currentTime += a * this.timeScale;
    a = this.data.length;
    !0 === this.loop && this.currentTime > a && (this.currentTime %= a);
    this.currentTime = Math.min(this.currentTime, a);
    a = 0;
    for (var b = this.hierarchy.length; a < b; a++) {
      var c = this.hierarchy[a],
        d = this.data.hierarchy[a],
        e = d.keys,
        d = d.animationCache;
      if (e.length) {
        var f = d.prevKey,
          g = d.nextKey;
        if (g.time <= this.currentTime) {
          for (; g.time < this.currentTime && g.index > f.index;) f = g, g = e[f.index + 1];
          d.prevKey = f;
          d.nextKey = g
        }
        g.time >= this.currentTime ? f.interpolate(g, this.currentTime) : f.interpolate(g, g.time);
        this.data.hierarchy[a].node.updateMatrix();
        c.matrixWorldNeedsUpdate = !0
      }
    }
  }
};
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function(a, b, c) {
  b = this.data.hierarchy[b].keys;
  for (c %= b.length; c < b.length; c++)
    if (b[c].hasTarget(a)) return b[c];
  return b[0]
};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function(a, b, c) {
  b = this.data.hierarchy[b].keys;
  for (c = 0 <= c ? c : c + b.length; 0 <= c; c--)
    if (b[c].hasTarget(a)) return b[c];
  return b[b.length - 1]
};
THREE.MorphAnimation = function(a) {
  this.mesh = a;
  this.frames = a.morphTargetInfluences.length;
  this.currentTime = 0;
  this.duration = 1E3;
  this.loop = !0;
  this.currentFrame = this.lastFrame = 0;
  this.isPlaying = !1
};
THREE.MorphAnimation.prototype = {
  constructor: THREE.MorphAnimation,
  play: function() {
    this.isPlaying = !0
  },
  pause: function() {
    this.isPlaying = !1
  },
  update: function(a) {
    if (!1 !== this.isPlaying) {
      this.currentTime += a;
      !0 === this.loop && this.currentTime > this.duration && (this.currentTime %= this.duration);
      this.currentTime = Math.min(this.currentTime, this.duration);
      a = this.duration / this.frames;
      var b = Math.floor(this.currentTime / a);
      b != this.currentFrame && (this.mesh.morphTargetInfluences[this.lastFrame] = 0, this.mesh.morphTargetInfluences[this.currentFrame] = 1, this.mesh.morphTargetInfluences[b] = 0, this.lastFrame = this.currentFrame, this.currentFrame = b);
      this.mesh.morphTargetInfluences[b] = this.currentTime % a / a;
      this.mesh.morphTargetInfluences[this.lastFrame] = 1 - this.mesh.morphTargetInfluences[b]
    }
  }
};
THREE.BoxGeometry = function(a, b, c, d, e, f) {
  function g(a, b, c, d, e, f, g, r) {
    var u, v = h.widthSegments,
      y = h.heightSegments,
      C = e / 2,
      x = f / 2,
      F = h.vertices.length;
    if ("x" === a && "y" === b || "y" === a && "x" === b) u = "z";
    else if ("x" === a && "z" === b || "z" === a && "x" === b) u = "y", y = h.depthSegments;
    else if ("z" === a && "y" === b || "y" === a && "z" === b) u = "x", v = h.depthSegments;
    var z = v + 1,
      G = y + 1,
      E = e / v,
      w = f / y,
      D = new THREE.Vector3;
    D[u] = 0 < g ? 1 : -1;
    for (e = 0; e < G; e++)
      for (f = 0; f < z; f++) {
        var A = new THREE.Vector3;
        A[a] = (f * E - C) * c;
        A[b] = (e * w - x) * d;
        A[u] = g;
        h.vertices.push(A)
      }
    for (e = 0; e < y; e++)
      for (f = 0; f < v; f++) x = f + z * e, a = f + z * (e + 1), b = f + 1 + z * (e + 1), c = f + 1 + z * e, d = new THREE.Vector2(f / v, 1 - e / y), g = new THREE.Vector2(f / v, 1 - (e + 1) / y), u = new THREE.Vector2((f + 1) / v, 1 - (e + 1) / y), C = new THREE.Vector2((f + 1) / v, 1 - e / y), x = new THREE.Face3(x + F, a + F, c + F), x.normal.copy(D), x.vertexNormals.push(D.clone(), D.clone(), D.clone()), x.materialIndex = r, h.faces.push(x), h.faceVertexUvs[0].push([d, g, C]), x = new THREE.Face3(a + F, b + F, c + F), x.normal.copy(D), x.vertexNormals.push(D.clone(), D.clone(), D.clone()), x.materialIndex = r, h.faces.push(x), h.faceVertexUvs[0].push([g.clone(), u, C.clone()])
  }
  THREE.Geometry.call(this);
  this.type = "BoxGeometry";
  this.parameters = {
    width: a,
    height: b,
    depth: c,
    widthSegments: d,
    heightSegments: e,
    depthSegments: f
  };
  this.widthSegments = d || 1;
  this.heightSegments = e || 1;
  this.depthSegments = f || 1;
  var h = this;
  d = a / 2;
  e = b / 2;
  f = c / 2;
  g("z", "y", -1, -1, c, b, d, 0);
  g("z", "y", 1, -1, c, b, -d, 1);
  g("x", "z", 1, 1, a, c, e, 2);
  g("x", "z", 1, -1, a, c, -e, 3);
  g("x", "y", 1, -1, a, b, f, 4);
  g("x", "y", -1, -1, a, b, -f, 5);
  this.mergeVertices()
};
THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
THREE.CircleGeometry = function(a, b, c, d) {
  THREE.Geometry.call(this);
  this.type = "CircleGeometry";
  this.parameters = {
    radius: a,
    segments: b,
    thetaStart: c,
    thetaLength: d
  };
  a = a || 50;
  b = void 0 !== b ? Math.max(3, b) : 8;
  c = void 0 !== c ? c : 0;
  d = void 0 !== d ? d : 2 * Math.PI;
  var e, f = [];
  e = new THREE.Vector3;
  var g = new THREE.Vector2(.5, .5);
  this.vertices.push(e);
  f.push(g);
  for (e = 0; e <= b; e++) {
    var h = new THREE.Vector3,
      k = c + e / b * d;
    h.x = a * Math.cos(k);
    h.y = a * Math.sin(k);
    this.vertices.push(h);
    f.push(new THREE.Vector2((h.x / a + 1) / 2, (h.y / a + 1) / 2))
  }
  c = new THREE.Vector3(0, 0, 1);
  for (e = 1; e <= b; e++) this.faces.push(new THREE.Face3(e, e + 1, 0, [c.clone(), c.clone(), c.clone()])), this.faceVertexUvs[0].push([f[e].clone(), f[e + 1].clone(), g.clone()]);
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
THREE.CubeGeometry = function(a, b, c, d, e, f) {
  console.warn("THREE.CubeGeometry has been renamed to THREE.BoxGeometry.");
  return new THREE.BoxGeometry(a, b, c, d, e, f)
};
THREE.CylinderGeometry = function(a, b, c, d, e, f, g, h) {
  THREE.Geometry.call(this);
  this.type = "CylinderGeometry";
  this.parameters = {
    radiusTop: a,
    radiusBottom: b,
    height: c,
    radialSegments: d,
    heightSegments: e,
    openEnded: f,
    thetaStart: g,
    thetaLength: h
  };
  a = void 0 !== a ? a : 20;
  b = void 0 !== b ? b : 20;
  c = void 0 !== c ? c : 100;
  d = d || 8;
  e = e || 1;
  f = void 0 !== f ? f : !1;
  g = void 0 !== g ? g : 0;
  h = void 0 !== h ? h : 2 * Math.PI;
  var k = c / 2,
    n, p, q = [],
    m = [];
  for (p = 0; p <= e; p++) {
    var t = [],
      s = [],
      r = p / e,
      u = r * (b - a) + a;
    for (n = 0; n <= d; n++) {
      var v = n / d,
        y = new THREE.Vector3;
      y.x = u * Math.sin(v * h + g);
      y.y = -r * c + k;
      y.z = u * Math.cos(v * h + g);
      this.vertices.push(y);
      t.push(this.vertices.length - 1);
      s.push(new THREE.Vector2(v, 1 - r))
    }
    q.push(t);
    m.push(s)
  }
  c = (b - a) / c;
  for (n = 0; n < d; n++)
    for (0 !== a ? (g = this.vertices[q[0][n]].clone(), h = this.vertices[q[0][n + 1]].clone()) : (g = this.vertices[q[1][n]].clone(), h = this.vertices[q[1][n + 1]].clone()), g.setY(Math.sqrt(g.x * g.x + g.z * g.z) * c).normalize(), h.setY(Math.sqrt(h.x * h.x + h.z * h.z) * c).normalize(), p = 0; p < e; p++) {
      var t = q[p][n],
        s = q[p + 1][n],
        r = q[p + 1][n + 1],
        u = q[p][n + 1],
        v = g.clone(),
        y = g.clone(),
        C = h.clone(),
        x = h.clone(),
        F = m[p][n].clone(),
        z = m[p + 1][n].clone(),
        G = m[p + 1][n + 1].clone(),
        E = m[p][n + 1].clone();
      this.faces.push(new THREE.Face3(t, s, u, [v, y, x]));
      this.faceVertexUvs[0].push([F, z, E]);
      this.faces.push(new THREE.Face3(s, r, u, [y.clone(), C, x.clone()]));
      this.faceVertexUvs[0].push([z.clone(), G, E.clone()])
    }
  if (!1 === f && 0 < a)
    for (this.vertices.push(new THREE.Vector3(0, k, 0)), n = 0; n < d; n++) t = q[0][n], s = q[0][n + 1], r = this.vertices.length - 1, v = new THREE.Vector3(0, 1, 0), y = new THREE.Vector3(0, 1, 0), C = new THREE.Vector3(0, 1, 0), F = m[0][n].clone(), z = m[0][n + 1].clone(), G = new THREE.Vector2(z.x, 0), this.faces.push(new THREE.Face3(t, s, r, [v, y, C])), this.faceVertexUvs[0].push([F, z, G]);
  if (!1 === f && 0 < b)
    for (this.vertices.push(new THREE.Vector3(0, -k, 0)), n = 0; n < d; n++) t = q[e][n + 1], s = q[e][n], r = this.vertices.length - 1, v = new THREE.Vector3(0, -1, 0), y = new THREE.Vector3(0, -1, 0), C = new THREE.Vector3(0, -1, 0), F = m[e][n + 1].clone(), z = m[e][n].clone(), G = new THREE.Vector2(z.x, 1), this.faces.push(new THREE.Face3(t, s, r, [v, y, C])), this.faceVertexUvs[0].push([F, z, G]);
  this.computeFaceNormals()
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
THREE.ExtrudeGeometry = function(a, b) {
  "undefined" !== typeof a && (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", a = a instanceof Array ? a : [a], this.addShapeList(a, b), this.computeFaceNormals())
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
THREE.ExtrudeGeometry.prototype.addShapeList = function(a, b) {
  for (var c = a.length, d = 0; d < c; d++) this.addShape(a[d], b)
};
THREE.ExtrudeGeometry.prototype.addShape = function(a, b) {
  function c(a, b, c) {
    b || console.log("die");
    return b.clone().multiplyScalar(c).add(a)
  }

  function d(a, b, c) {
    var d = 1,
      d = a.x - b.x,
      e = a.y - b.y,
      f = c.x - a.x,
      g = c.y - a.y,
      h = d * d + e * e;
    if (1E-10 < Math.abs(d * g - e * f)) {
      var k = Math.sqrt(h),
        m = Math.sqrt(f * f + g * g),
        h = b.x - e / k;
      b = b.y + d / k;
      f = ((c.x - g / m - h) * g - (c.y + f / m - b) * f) / (d * g - e * f);
      c = h + d * f - a.x;
      a = b + e * f - a.y;
      d = c * c + a * a;
      if (2 >= d) return new THREE.Vector2(c, a);
      d = Math.sqrt(d / 2)
    } else a = !1, 1E-10 < d ? 1E-10 < f && (a = !0) : -1E-10 > d ? -1E-10 > f && (a = !0) : Math.sign(e) == Math.sign(g) && (a = !0), a ? (c = -e, a = d, d = Math.sqrt(h)) : (c = d, a = e, d = Math.sqrt(h / 2));
    return new THREE.Vector2(c / d, a / d)
  }

  function e(a, b) {
    var c, d;
    for (H = a.length; 0 <= --H;) {
      c = H;
      d = H - 1;
      0 > d && (d = a.length - 1);
      for (var e = 0, f = t + 2 * p, e = 0; e < f; e++) {
        var g = ga * e,
          h = ga * (e + 1),
          k = b + c + g,
          g = b + d + g,
          m = b + d + h,
          h = b + c + h,
          k = k + U,
          g = g + U,
          m = m + U,
          h = h + U;
        A.faces.push(new THREE.Face3(k, g, h, null, null, y));
        A.faces.push(new THREE.Face3(g, m, h, null, null, y));
        k = C.generateSideWallUV(A, k, g, m, h);
        A.faceVertexUvs[0].push([k[0], k[1], k[3]]);
        A.faceVertexUvs[0].push([k[1], k[2], k[3]])
      }
    }
  }

  function f(a, b, c) {
    A.vertices.push(new THREE.Vector3(a, b, c))
  }

  function g(a, b, c) {
    a += U;
    b += U;
    c += U;
    A.faces.push(new THREE.Face3(a, b, c, null, null, v));
    a = C.generateTopUV(A, a, b, c);
    A.faceVertexUvs[0].push(a)
  }
  var h = void 0 !== b.amount ? b.amount : 100,
    k = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
    n = void 0 !== b.bevelSize ? b.bevelSize : k - 2,
    p = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
    q = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
    m = void 0 !== b.curveSegments ? b.curveSegments : 12,
    t = void 0 !== b.steps ? b.steps : 1,
    s = b.extrudePath,
    r, u = !1,
    v = b.material,
    y = b.extrudeMaterial,
    C = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,
    x, F, z, G;
  s && (r = s.getSpacedPoints(t), u = !0, q = !1, x = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(s, t, !1), F = new THREE.Vector3, z = new THREE.Vector3, G = new THREE.Vector3);
  q || (n = k = p = 0);
  var E, w, D, A = this,
    U = this.vertices.length,
    s = a.extractPoints(m),
    m = s.shape,
    M = s.holes;
  if (s = !THREE.Shape.Utils.isClockWise(m)) {
    m = m.reverse();
    w = 0;
    for (D = M.length; w < D; w++) E = M[w], THREE.Shape.Utils.isClockWise(E) && (M[w] = E.reverse());
    s = !1
  }
  var K = THREE.Shape.Utils.triangulateShape(m, M),
    L = m;
  w = 0;
  for (D = M.length; w < D; w++) E = M[w], m = m.concat(E);
  var N, T, Q, W, O, ga = m.length,
    ea, xa = K.length,
    s = [],
    H = 0;
  Q = L.length;
  N = Q - 1;
  for (T = H + 1; H < Q; H++, N++, T++) N === Q && (N = 0), T === Q && (T = 0), s[H] = d(L[H], L[N], L[T]);
  var $a = [],
    qa, ya = s.concat();
  w = 0;
  for (D = M.length; w < D; w++) {
    E = M[w];
    qa = [];
    H = 0;
    Q = E.length;
    N = Q - 1;
    for (T = H + 1; H < Q; H++, N++, T++) N === Q && (N = 0), T === Q && (T = 0), qa[H] = d(E[H], E[N], E[T]);
    $a.push(qa);
    ya = ya.concat(qa)
  }
  for (N = 0; N < p; N++) {
    Q = N / p;
    W = k * (1 - Q);
    T = n * Math.sin(Q * Math.PI / 2);
    H = 0;
    for (Q = L.length; H < Q; H++) O = c(L[H], s[H], T), f(O.x, O.y, -W);
    w = 0;
    for (D = M.length; w < D; w++)
      for (E = M[w], qa = $a[w], H = 0, Q = E.length; H < Q; H++) O = c(E[H], qa[H], T), f(O.x, O.y, -W)
  }
  T = n;
  for (H = 0; H < ga; H++) O = q ? c(m[H], ya[H], T) : m[H], u ? (z.copy(x.normals[0]).multiplyScalar(O.x), F.copy(x.binormals[0]).multiplyScalar(O.y), G.copy(r[0]).add(z).add(F), f(G.x, G.y, G.z)) : f(O.x, O.y, 0);
  for (Q = 1; Q <= t; Q++)
    for (H = 0; H < ga; H++) O = q ? c(m[H], ya[H], T) : m[H], u ? (z.copy(x.normals[Q]).multiplyScalar(O.x), F.copy(x.binormals[Q]).multiplyScalar(O.y), G.copy(r[Q]).add(z).add(F), f(G.x, G.y, G.z)) : f(O.x, O.y, h / t * Q);
  for (N = p - 1; 0 <= N; N--) {
    Q = N / p;
    W = k * (1 - Q);
    T = n * Math.sin(Q * Math.PI / 2);
    H = 0;
    for (Q = L.length; H < Q; H++) O = c(L[H], s[H], T), f(O.x, O.y, h + W);
    w = 0;
    for (D = M.length; w < D; w++)
      for (E = M[w], qa = $a[w], H = 0, Q = E.length; H < Q; H++) O = c(E[H], qa[H], T), u ? f(O.x, O.y + r[t - 1].y, r[t - 1].x + W) : f(O.x, O.y, h + W)
  }(function() {
    if (q) {
      var a;
      a = 0 * ga;
      for (H = 0; H < xa; H++) ea = K[H], g(ea[2] + a, ea[1] + a, ea[0] + a);
      a = t + 2 * p;
      a *= ga;
      for (H = 0; H < xa; H++) ea = K[H], g(ea[0] + a, ea[1] + a, ea[2] + a)
    } else {
      for (H = 0; H < xa; H++) ea = K[H], g(ea[2], ea[1], ea[0]);
      for (H = 0; H < xa; H++) ea = K[H], g(ea[0] + ga * t, ea[1] + ga * t, ea[2] + ga * t)
    }
  })();
  (function() {
    var a = 0;
    e(L, a);
    a += L.length;
    w = 0;
    for (D = M.length; w < D; w++) E = M[w], e(E, a), a += E.length
  })()
};
THREE.ExtrudeGeometry.WorldUVGenerator = {
  generateTopUV: function(a, b, c, d) {
    a = a.vertices;
    b = a[b];
    c = a[c];
    d = a[d];
    return [new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y), new THREE.Vector2(d.x, d.y)]
  },
  generateSideWallUV: function(a, b, c, d, e) {
    a = a.vertices;
    b = a[b];
    c = a[c];
    d = a[d];
    e = a[e];
    return .01 > Math.abs(b.y - c.y) ? [new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z), new THREE.Vector2(e.x, 1 - e.z)] : [new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y, 1 - d.z), new THREE.Vector2(e.y, 1 - e.z)]
  }
};
THREE.ShapeGeometry = function(a, b) {
  THREE.Geometry.call(this);
  this.type = "ShapeGeometry";
  !1 === a instanceof Array && (a = [a]);
  this.addShapeList(a, b);
  this.computeFaceNormals()
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
THREE.ShapeGeometry.prototype.addShapeList = function(a, b) {
  for (var c = 0, d = a.length; c < d; c++) this.addShape(a[c], b);
  return this
};
THREE.ShapeGeometry.prototype.addShape = function(a, b) {
  void 0 === b && (b = {});
  var c = b.material,
    d = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator,
    e, f, g, h = this.vertices.length;
  e = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
  var k = e.shape,
    n = e.holes;
  if (!THREE.Shape.Utils.isClockWise(k))
    for (k = k.reverse(), e = 0, f = n.length; e < f; e++) g = n[e], THREE.Shape.Utils.isClockWise(g) && (n[e] = g.reverse());
  var p = THREE.Shape.Utils.triangulateShape(k, n);
  e = 0;
  for (f = n.length; e < f; e++) g = n[e], k = k.concat(g);
  n = k.length;
  f = p.length;
  for (e = 0; e < n; e++) g = k[e], this.vertices.push(new THREE.Vector3(g.x, g.y, 0));
  for (e = 0; e < f; e++) n = p[e], k = n[0] + h, g = n[1] + h, n = n[2] + h, this.faces.push(new THREE.Face3(k, g, n, null, null, c)), this.faceVertexUvs[0].push(d.generateTopUV(this, k, g, n))
};
THREE.LatheGeometry = function(a, b, c, d) {
  THREE.Geometry.call(this);
  this.type = "LatheGeometry";
  this.parameters = {
    points: a,
    segments: b,
    phiStart: c,
    phiLength: d
  };
  b = b || 12;
  c = c || 0;
  d = d || 2 * Math.PI;
  for (var e = 1 / (a.length - 1), f = 1 / b, g = 0, h = b; g <= h; g++)
    for (var k = c + g * f * d, n = Math.cos(k), p = Math.sin(k), k = 0, q = a.length; k < q; k++) {
      var m = a[k],
        t = new THREE.Vector3;
      t.x = n * m.x - p * m.y;
      t.y = p * m.x + n * m.y;
      t.z = m.z;
      this.vertices.push(t)
    }
  c = a.length;
  g = 0;
  for (h = b; g < h; g++)
    for (k = 0, q = a.length - 1; k < q; k++) {
      b = p = k + c * g;
      d = p + c;
      var n = p + 1 + c,
        p = p + 1,
        m = g * f,
        t = k * e,
        s = m + f,
        r = t + e;
      this.faces.push(new THREE.Face3(b, d, p));
      this.faceVertexUvs[0].push([new THREE.Vector2(m, t), new THREE.Vector2(s, t), new THREE.Vector2(m, r)]);
      this.faces.push(new THREE.Face3(d, n, p));
      this.faceVertexUvs[0].push([new THREE.Vector2(s, t), new THREE.Vector2(s, r), new THREE.Vector2(m, r)])
    }
  this.mergeVertices();
  this.computeFaceNormals();
  this.computeVertexNormals()
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
THREE.PlaneGeometry = function(a, b, c, d) {
  console.info("THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.");
  THREE.Geometry.call(this);
  this.type = "PlaneGeometry";
  this.parameters = {
    width: a,
    height: b,
    widthSegments: c,
    heightSegments: d
  };
  this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a, b, c, d))
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
THREE.PlaneBufferGeometry = function(a, b, c, d) {
  THREE.BufferGeometry.call(this);
  this.type = "PlaneBufferGeometry";
  this.parameters = {
    width: a,
    height: b,
    widthSegments: c,
    heightSegments: d
  };
  var e = a / 2,
    f = b / 2;
  c = c || 1;
  d = d || 1;
  var g = c + 1,
    h = d + 1,
    k = a / c,
    n = b / d;
  b = new Float32Array(g * h * 3);
  a = new Float32Array(g * h * 3);
  for (var p = new Float32Array(g * h * 2), q = 0, m = 0, t = 0; t < h; t++)
    for (var s = t * n - f, r = 0; r < g; r++) b[q] = r * k - e, b[q + 1] = -s, a[q + 2] = 1, p[m] = r / c, p[m + 1] = 1 - t / d, q += 3, m += 2;
  q = 0;
  e = new(65535 < b.length / 3 ? Uint32Array : Uint16Array)(c * d * 6);
  for (t = 0; t < d; t++)
    for (r = 0; r < c; r++) f = r + g * (t + 1), h = r + 1 + g * (t + 1), k = r + 1 + g * t, e[q] = r + g * t, e[q + 1] = f, e[q + 2] = k, e[q + 3] = f, e[q + 4] = h, e[q + 5] = k, q += 6;
  this.addAttribute("index", new THREE.BufferAttribute(e, 1));
  this.addAttribute("position", new THREE.BufferAttribute(b, 3));
  this.addAttribute("normal", new THREE.BufferAttribute(a, 3));
  this.addAttribute("uv", new THREE.BufferAttribute(p, 2))
};
THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
THREE.RingGeometry = function(a, b, c, d, e, f) {
  THREE.Geometry.call(this);
  this.type = "RingGeometry";
  this.parameters = {
    innerRadius: a,
    outerRadius: b,
    thetaSegments: c,
    phiSegments: d,
    thetaStart: e,
    thetaLength: f
  };
  a = a || 0;
  b = b || 50;
  e = void 0 !== e ? e : 0;
  f = void 0 !== f ? f : 2 * Math.PI;
  c = void 0 !== c ? Math.max(3, c) : 8;
  d = void 0 !== d ? Math.max(1, d) : 8;
  var g, h = [],
    k = a,
    n = (b - a) / d;
  for (a = 0; a < d + 1; a++) {
    for (g = 0; g < c + 1; g++) {
      var p = new THREE.Vector3,
        q = e + g / c * f;
      p.x = k * Math.cos(q);
      p.y = k * Math.sin(q);
      this.vertices.push(p);
      h.push(new THREE.Vector2((p.x / b + 1) / 2, (p.y / b + 1) / 2))
    }
    k += n
  }
  b = new THREE.Vector3(0, 0, 1);
  for (a = 0; a < d; a++)
    for (e = a * (c + 1), g = 0; g < c; g++) f = q = g + e, n = q + c + 1, p = q + c + 2, this.faces.push(new THREE.Face3(f, n, p, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([h[f].clone(), h[n].clone(), h[p].clone()]), f = q, n = q + c + 2, p = q + 1, this.faces.push(new THREE.Face3(f, n, p, [b.clone(), b.clone(), b.clone()])), this.faceVertexUvs[0].push([h[f].clone(), h[n].clone(), h[p].clone()]);
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3, k)
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
THREE.SphereGeometry = function(a, b, c, d, e, f, g) {
  THREE.Geometry.call(this);
  this.type = "SphereGeometry";
  this.parameters = {
    radius: a,
    widthSegments: b,
    heightSegments: c,
    phiStart: d,
    phiLength: e,
    thetaStart: f,
    thetaLength: g
  };
  a = a || 50;
  b = Math.max(3, Math.floor(b) || 8);
  c = Math.max(2, Math.floor(c) || 6);
  d = void 0 !== d ? d : 0;
  e = void 0 !== e ? e : 2 * Math.PI;
  f = void 0 !== f ? f : 0;
  g = void 0 !== g ? g : Math.PI;
  var h, k, n = [],
    p = [];
  for (k = 0; k <= c; k++) {
    var q = [],
      m = [];
    for (h = 0; h <= b; h++) {
      var t = h / b,
        s = k / c,
        r = new THREE.Vector3;
      r.x = -a * Math.cos(d + t * e) * Math.sin(f + s * g);
      r.y = a * Math.cos(f + s * g);
      r.z = a * Math.sin(d + t * e) * Math.sin(f + s * g);
      this.vertices.push(r);
      q.push(this.vertices.length - 1);
      m.push(new THREE.Vector2(t, 1 - s))
    }
    n.push(q);
    p.push(m)
  }
  for (k = 0; k < c; k++)
    for (h = 0; h < b; h++) {
      d = n[k][h + 1];
      e = n[k][h];
      f = n[k + 1][h];
      g = n[k + 1][h + 1];
      var q = this.vertices[d].clone().normalize(),
        m = this.vertices[e].clone().normalize(),
        t = this.vertices[f].clone().normalize(),
        s = this.vertices[g].clone().normalize(),
        r = p[k][h + 1].clone(),
        u = p[k][h].clone(),
        v = p[k + 1][h].clone(),
        y = p[k + 1][h + 1].clone();
      Math.abs(this.vertices[d].y) === a ? (r.x = (r.x + u.x) / 2, this.faces.push(new THREE.Face3(d, f, g, [q, t, s])), this.faceVertexUvs[0].push([r, v, y])) : Math.abs(this.vertices[f].y) === a ? (v.x = (v.x + y.x) / 2, this.faces.push(new THREE.Face3(d, e, f, [q, m, t])), this.faceVertexUvs[0].push([r, u, v])) : (this.faces.push(new THREE.Face3(d, e, g, [q, m, s])), this.faceVertexUvs[0].push([r, u, y]), this.faces.push(new THREE.Face3(e, f, g, [m.clone(), t, s.clone()])), this.faceVertexUvs[0].push([u.clone(), v, y.clone()]))
    }
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
THREE.TextGeometry = function(a, b) {
  b = b || {};
  var c = THREE.FontUtils.generateShapes(a, b);
  b.amount = void 0 !== b.height ? b.height : 50;
  void 0 === b.bevelThickness && (b.bevelThickness = 10);
  void 0 === b.bevelSize && (b.bevelSize = 8);
  void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
  THREE.ExtrudeGeometry.call(this, c, b);
  this.type = "TextGeometry"
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
THREE.TorusGeometry = function(a, b, c, d, e) {
  THREE.Geometry.call(this);
  this.type = "TorusGeometry";
  this.parameters = {
    radius: a,
    tube: b,
    radialSegments: c,
    tubularSegments: d,
    arc: e
  };
  a = a || 100;
  b = b || 40;
  c = c || 8;
  d = d || 6;
  e = e || 2 * Math.PI;
  for (var f = new THREE.Vector3, g = [], h = [], k = 0; k <= c; k++)
    for (var n = 0; n <= d; n++) {
      var p = n / d * e,
        q = k / c * Math.PI * 2;
      f.x = a * Math.cos(p);
      f.y = a * Math.sin(p);
      var m = new THREE.Vector3;
      m.x = (a + b * Math.cos(q)) * Math.cos(p);
      m.y = (a + b * Math.cos(q)) * Math.sin(p);
      m.z = b * Math.sin(q);
      this.vertices.push(m);
      g.push(new THREE.Vector2(n / d, k / c));
      h.push(m.clone().sub(f).normalize())
    }
  for (k = 1; k <= c; k++)
    for (n = 1; n <= d; n++) a = (d + 1) * k + n - 1, b = (d + 1) * (k - 1) + n - 1, e = (d + 1) * (k - 1) + n, f = (d + 1) * k + n, p = new THREE.Face3(a, b, f, [h[a].clone(), h[b].clone(), h[f].clone()]), this.faces.push(p), this.faceVertexUvs[0].push([g[a].clone(), g[b].clone(), g[f].clone()]), p = new THREE.Face3(b, e, f, [h[b].clone(), h[e].clone(), h[f].clone()]), this.faces.push(p), this.faceVertexUvs[0].push([g[b].clone(), g[e].clone(), g[f].clone()]);
  this.computeFaceNormals()
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
THREE.TorusKnotGeometry = function(a, b, c, d, e, f, g) {
  function h(a, b, c, d, e) {
    var f = Math.cos(a),
      g = Math.sin(a);
    a *= b / c;
    b = Math.cos(a);
    f *= d * (2 + b) * .5;
    g = d * (2 + b) * g * .5;
    d = e * d * Math.sin(a) * .5;
    return new THREE.Vector3(f, g, d)
  }
  THREE.Geometry.call(this);
  this.type = "TorusKnotGeometry";
  this.parameters = {
    radius: a,
    tube: b,
    radialSegments: c,
    tubularSegments: d,
    p: e,
    q: f,
    heightScale: g
  };
  a = a || 100;
  b = b || 40;
  c = c || 64;
  d = d || 8;
  e = e || 2;
  f = f || 3;
  g = g || 1;
  for (var k = Array(c), n = new THREE.Vector3, p = new THREE.Vector3, q = new THREE.Vector3, m = 0; m < c; ++m) {
    k[m] = Array(d);
    var t = m / c * 2 * e * Math.PI,
      s = h(t, f, e, a, g),
      t = h(t + .01, f, e, a, g);
    n.subVectors(t, s);
    p.addVectors(t, s);
    q.crossVectors(n, p);
    p.crossVectors(q, n);
    q.normalize();
    p.normalize();
    for (t = 0; t < d; ++t) {
      var r = t / d * 2 * Math.PI,
        u = -b * Math.cos(r),
        r = b * Math.sin(r),
        v = new THREE.Vector3;
      v.x = s.x + u * p.x + r * q.x;
      v.y = s.y + u * p.y + r * q.y;
      v.z = s.z + u * p.z + r * q.z;
      k[m][t] = this.vertices.push(v) - 1
    }
  }
  for (m = 0; m < c; ++m)
    for (t = 0; t < d; ++t) e = (m + 1) % c, f = (t + 1) % d, a = k[m][t], b = k[e][t], e = k[e][f], f = k[m][f], g = new THREE.Vector2(m / c, t / d), n = new THREE.Vector2((m + 1) / c, t / d), p = new THREE.Vector2((m + 1) / c, (t + 1) / d), q = new THREE.Vector2(m / c, (t + 1) / d), this.faces.push(new THREE.Face3(a, b, f)), this.faceVertexUvs[0].push([g, n, q]), this.faces.push(new THREE.Face3(b, e, f)), this.faceVertexUvs[0].push([n.clone(), p, q.clone()]);
  this.computeFaceNormals();
  this.computeVertexNormals()
};
THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
THREE.TubeGeometry = function(a, b, c, d, e, f) {
  THREE.Geometry.call(this);
  this.type = "TubeGeometry";
  this.parameters = {
    path: a,
    segments: b,
    radius: c,
    radialSegments: d,
    closed: e
  };
  b = b || 64;
  c = c || 1;
  d = d || 8;
  e = e || !1;
  f = f || THREE.TubeGeometry.NoTaper;
  var g = [],
    h, k, n = b + 1,
    p, q, m, t, s, r = new THREE.Vector3,
    u, v, y;
  u = new THREE.TubeGeometry.FrenetFrames(a, b, e);
  v = u.normals;
  y = u.binormals;
  this.tangents = u.tangents;
  this.normals = v;
  this.binormals = y;
  for (u = 0; u < n; u++)
    for (g[u] = [], p = u / (n - 1), s = a.getPointAt(p), h = v[u], k = y[u], m = c * f(p), p = 0; p < d; p++) q = p / d * 2 * Math.PI, t = -m * Math.cos(q), q = m * Math.sin(q), r.copy(s), r.x += t * h.x + q * k.x, r.y += t * h.y + q * k.y, r.z += t * h.z + q * k.z, g[u][p] = this.vertices.push(new THREE.Vector3(r.x, r.y, r.z)) - 1;
  for (u = 0; u < b; u++)
    for (p = 0; p < d; p++) f = e ? (u + 1) % b : u + 1, n = (p + 1) % d, a = g[u][p], c = g[f][p], f = g[f][n], n = g[u][n], r = new THREE.Vector2(u / b, p / d), v = new THREE.Vector2((u + 1) / b, p / d), y = new THREE.Vector2((u + 1) / b, (p + 1) / d), h = new THREE.Vector2(u / b, (p + 1) / d), this.faces.push(new THREE.Face3(a, c, n)), this.faceVertexUvs[0].push([r, v, h]), this.faces.push(new THREE.Face3(c, f, n)), this.faceVertexUvs[0].push([v.clone(), y, h.clone()]);
  this.computeFaceNormals();
  this.computeVertexNormals()
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
THREE.TubeGeometry.NoTaper = function(a) {
  return 1
};
THREE.TubeGeometry.SinusoidalTaper = function(a) {
  return Math.sin(Math.PI * a)
};
THREE.TubeGeometry.FrenetFrames = function(a, b, c) {
  new THREE.Vector3;
  var d = new THREE.Vector3;
  new THREE.Vector3;
  var e = [],
    f = [],
    g = [],
    h = new THREE.Vector3,
    k = new THREE.Matrix4;
  b += 1;
  var n, p, q;
  this.tangents = e;
  this.normals = f;
  this.binormals = g;
  for (n = 0; n < b; n++) p = n / (b - 1), e[n] = a.getTangentAt(p), e[n].normalize();
  f[0] = new THREE.Vector3;
  g[0] = new THREE.Vector3;
  a = Number.MAX_VALUE;
  n = Math.abs(e[0].x);
  p = Math.abs(e[0].y);
  q = Math.abs(e[0].z);
  n <= a && (a = n, d.set(1, 0, 0));
  p <= a && (a = p, d.set(0, 1, 0));
  q <= a && d.set(0, 0, 1);
  h.crossVectors(e[0], d).normalize();
  f[0].crossVectors(e[0], h);
  g[0].crossVectors(e[0], f[0]);
  for (n = 1; n < b; n++) f[n] = f[n - 1].clone(), g[n] = g[n - 1].clone(), h.crossVectors(e[n - 1], e[n]), 1E-4 < h.length() && (h.normalize(), d = Math.acos(THREE.Math.clamp(e[n - 1].dot(e[n]), -1, 1)), f[n].applyMatrix4(k.makeRotationAxis(h, d))), g[n].crossVectors(e[n], f[n]);
  if (c)
    for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), n = 1; n < b; n++) f[n].applyMatrix4(k.makeRotationAxis(e[n], d * n)), g[n].crossVectors(e[n], f[n])
};
THREE.PolyhedronGeometry = function(a, b, c, d) {
  function e(a) {
    var b = a.normalize().clone();
    b.index = k.vertices.push(b) - 1;
    var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + .5;
    a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5;
    b.uv = new THREE.Vector2(c, 1 - a);
    return b
  }

  function f(a, b, c) {
    var d = new THREE.Face3(a.index, b.index, c.index, [a.clone(), b.clone(), c.clone()]);
    k.faces.push(d);
    u.copy(a).add(b).add(c).divideScalar(3);
    d = Math.atan2(u.z, -u.x);
    k.faceVertexUvs[0].push([h(a.uv, a, d), h(b.uv, b, d), h(c.uv, c, d)])
  }

  function g(a, b) {
    var c = Math.pow(2, b);
    Math.pow(4, b);
    for (var d = e(k.vertices[a.a]), g = e(k.vertices[a.b]), h = e(k.vertices[a.c]), m = [], n = 0; n <= c; n++) {
      m[n] = [];
      for (var p = e(d.clone().lerp(h, n / c)), q = e(g.clone().lerp(h, n / c)), s = c - n, r = 0; r <= s; r++) m[n][r] = 0 == r && n == c ? p : e(p.clone().lerp(q, r / s))
    }
    for (n = 0; n < c; n++)
      for (r = 0; r < 2 * (c - n) - 1; r++) d = Math.floor(r / 2), 0 == r % 2 ? f(m[n][d + 1], m[n + 1][d], m[n][d]) : f(m[n][d + 1], m[n + 1][d + 1], m[n + 1][d])
  }

  function h(a, b, c) {
    0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));
    0 === b.x && 0 === b.z && (a = new THREE.Vector2(c / 2 / Math.PI + .5, a.y));
    return a.clone()
  }
  THREE.Geometry.call(this);
  this.type = "PolyhedronGeometry";
  this.parameters = {
    vertices: a,
    indices: b,
    radius: c,
    detail: d
  };
  c = c || 1;
  d = d || 0;
  for (var k = this, n = 0, p = a.length; n < p; n += 3) e(new THREE.Vector3(a[n], a[n + 1], a[n + 2]));
  a = this.vertices;
  for (var q = [], m = n = 0, p = b.length; n < p; n += 3, m++) {
    var t = a[b[n]],
      s = a[b[n + 1]],
      r = a[b[n + 2]];
    q[m] = new THREE.Face3(t.index, s.index, r.index, [t.clone(), s.clone(), r.clone()])
  }
  for (var u = new THREE.Vector3, n = 0, p = q.length; n < p; n++) g(q[n], d);
  n = 0;
  for (p = this.faceVertexUvs[0].length; n < p; n++) b = this.faceVertexUvs[0][n], d = b[0].x, a = b[1].x, q = b[2].x, m = Math.max(d, Math.max(a, q)), t = Math.min(d, Math.min(a, q)), .9 < m && .1 > t && (.2 > d && (b[0].x += 1), .2 > a && (b[1].x += 1), .2 > q && (b[2].x += 1));
  n = 0;
  for (p = this.vertices.length; n < p; n++) this.vertices[n].multiplyScalar(c);
  this.mergeVertices();
  this.computeFaceNormals();
  this.boundingSphere = new THREE.Sphere(new THREE.Vector3, c)
};
THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
THREE.DodecahedronGeometry = function(a, b) {
  this.parameters = {
    radius: a,
    detail: b
  };
  var c = (1 + Math.sqrt(5)) / 2,
    d = 1 / c;
  THREE.PolyhedronGeometry.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b)
};
THREE.DodecahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
THREE.IcosahedronGeometry = function(a, b) {
  var c = (1 + Math.sqrt(5)) / 2;
  THREE.PolyhedronGeometry.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b);
  this.type = "IcosahedronGeometry";
  this.parameters = {
    radius: a,
    detail: b
  }
};
THREE.IcosahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
THREE.OctahedronGeometry = function(a, b) {
  this.parameters = {
    radius: a,
    detail: b
  };
  THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b);
  this.type = "OctahedronGeometry";
  this.parameters = {
    radius: a,
    detail: b
  }
};
THREE.OctahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
THREE.TetrahedronGeometry = function(a, b) {
  THREE.PolyhedronGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b);
  this.type = "TetrahedronGeometry";
  this.parameters = {
    radius: a,
    detail: b
  }
};
THREE.TetrahedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
THREE.ParametricGeometry = function(a, b, c) {
  THREE.Geometry.call(this);
  this.type = "ParametricGeometry";
  this.parameters = {
    func: a,
    slices: b,
    stacks: c
  };
  var d = this.vertices,
    e = this.faces,
    f = this.faceVertexUvs[0],
    g, h, k, n, p = b + 1;
  for (g = 0; g <= c; g++)
    for (n = g / c, h = 0; h <= b; h++) k = h / b, k = a(k, n), d.push(k);
  var q, m, t, s;
  for (g = 0; g < c; g++)
    for (h = 0; h < b; h++) a = g * p + h, d = g * p + h + 1, n = (g + 1) * p + h + 1, k = (g + 1) * p + h, q = new THREE.Vector2(h / b, g / c), m = new THREE.Vector2((h + 1) / b, g / c), t = new THREE.Vector2((h + 1) / b, (g + 1) / c), s = new THREE.Vector2(h / b, (g + 1) / c), e.push(new THREE.Face3(a, d, k)), f.push([q, m, s]), e.push(new THREE.Face3(d, n, k)), f.push([m.clone(), t, s.clone()]);
  this.computeFaceNormals();
  this.computeVertexNormals()
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
THREE.AxisHelper = function(a) {
  a = a || 1;
  var b = new Float32Array([0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a]),
    c = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);
  a = new THREE.BufferGeometry;
  a.addAttribute("position", new THREE.BufferAttribute(b, 3));
  a.addAttribute("color", new THREE.BufferAttribute(c, 3));
  b = new THREE.LineBasicMaterial({
    vertexColors: THREE.VertexColors
  });
  THREE.Line.call(this, a, b, THREE.LinePieces)
};
THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
THREE.ArrowHelper = function() {
  var a = new THREE.Geometry;
  a.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
  var b = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
  b.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0));
  return function(c, d, e, f, g, h) {
    THREE.Object3D.call(this);
    void 0 === f && (f = 16776960);
    void 0 === e && (e = 1);
    void 0 === g && (g = .2 * e);
    void 0 === h && (h = .2 * g);
    this.position.copy(d);
    this.line = new THREE.Line(a, new THREE.LineBasicMaterial({
      color: f
    }));
    this.line.matrixAutoUpdate = !1;
    this.add(this.line);
    this.cone = new THREE.Mesh(b, new THREE.MeshBasicMaterial({
      color: f
    }));
    this.cone.matrixAutoUpdate = !1;
    this.add(this.cone);
    this.setDirection(c);
    this.setLength(e, g, h)
  }
}();
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
THREE.ArrowHelper.prototype.setDirection = function() {
  var a = new THREE.Vector3,
    b;
  return function(c) {.99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(), b = Math.acos(c.y), this.quaternion.setFromAxisAngle(a, b))
  }
}();
THREE.ArrowHelper.prototype.setLength = function(a, b, c) {
  void 0 === b && (b = .2 * a);
  void 0 === c && (c = .2 * b);
  this.line.scale.set(1, a - b, 1);
  this.line.updateMatrix();
  this.cone.scale.set(c, b, c);
  this.cone.position.y = a;
  this.cone.updateMatrix()
};
THREE.ArrowHelper.prototype.setColor = function(a) {
  this.line.material.color.set(a);
  this.cone.material.color.set(a)
};
THREE.BoxHelper = function(a) {
  var b = new THREE.BufferGeometry;
  b.addAttribute("position", new THREE.BufferAttribute(new Float32Array(72), 3));
  THREE.Line.call(this, b, new THREE.LineBasicMaterial({
    color: 16776960
  }), THREE.LinePieces);
  void 0 !== a && this.update(a)
};
THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
THREE.BoxHelper.prototype.update = function(a) {
  var b = a.geometry;
  null === b.boundingBox && b.computeBoundingBox();
  var c = b.boundingBox.min,
    b = b.boundingBox.max,
    d = this.geometry.attributes.position.array;
  d[0] = b.x;
  d[1] = b.y;
  d[2] = b.z;
  d[3] = c.x;
  d[4] = b.y;
  d[5] = b.z;
  d[6] = c.x;
  d[7] = b.y;
  d[8] = b.z;
  d[9] = c.x;
  d[10] = c.y;
  d[11] = b.z;
  d[12] = c.x;
  d[13] = c.y;
  d[14] = b.z;
  d[15] = b.x;
  d[16] = c.y;
  d[17] = b.z;
  d[18] = b.x;
  d[19] = c.y;
  d[20] = b.z;
  d[21] = b.x;
  d[22] = b.y;
  d[23] = b.z;
  d[24] = b.x;
  d[25] = b.y;
  d[26] = c.z;
  d[27] = c.x;
  d[28] = b.y;
  d[29] = c.z;
  d[30] = c.x;
  d[31] = b.y;
  d[32] = c.z;
  d[33] = c.x;
  d[34] = c.y;
  d[35] = c.z;
  d[36] = c.x;
  d[37] = c.y;
  d[38] = c.z;
  d[39] = b.x;
  d[40] = c.y;
  d[41] = c.z;
  d[42] = b.x;
  d[43] = c.y;
  d[44] = c.z;
  d[45] = b.x;
  d[46] = b.y;
  d[47] = c.z;
  d[48] = b.x;
  d[49] = b.y;
  d[50] = b.z;
  d[51] = b.x;
  d[52] = b.y;
  d[53] = c.z;
  d[54] = c.x;
  d[55] = b.y;
  d[56] = b.z;
  d[57] = c.x;
  d[58] = b.y;
  d[59] = c.z;
  d[60] = c.x;
  d[61] = c.y;
  d[62] = b.z;
  d[63] = c.x;
  d[64] = c.y;
  d[65] = c.z;
  d[66] = b.x;
  d[67] = c.y;
  d[68] = b.z;
  d[69] = b.x;
  d[70] = c.y;
  d[71] = c.z;
  this.geometry.attributes.position.needsUpdate = !0;
  this.geometry.computeBoundingSphere();
  this.matrix = a.matrixWorld;
  this.matrixAutoUpdate = !1
};
THREE.BoundingBoxHelper = function(a, b) {
  var c = void 0 !== b ? b : 8947848;
  this.object = a;
  this.box = new THREE.Box3;
  THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
    color: c,
    wireframe: !0
  }))
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
THREE.BoundingBoxHelper.prototype.update = function() {
  this.box.setFromObject(this.object);
  this.box.size(this.scale);
  this.box.center(this.position)
};
THREE.CameraHelper = function(a) {
  function b(a, b, d) {
    c(a, d);
    c(b, d)
  }

  function c(a, b) {
    d.vertices.push(new THREE.Vector3);
    d.colors.push(new THREE.Color(b));
    void 0 === f[a] && (f[a] = []);
    f[a].push(d.vertices.length - 1)
  }
  var d = new THREE.Geometry,
    e = new THREE.LineBasicMaterial({
      color: 16777215,
      vertexColors: THREE.FaceColors
    }),
    f = {};
  b("n1", "n2", 16755200);
  b("n2", "n4", 16755200);
  b("n4", "n3", 16755200);
  b("n3", "n1", 16755200);
  b("f1", "f2", 16755200);
  b("f2", "f4", 16755200);
  b("f4", "f3", 16755200);
  b("f3", "f1", 16755200);
  b("n1", "f1", 16755200);
  b("n2", "f2", 16755200);
  b("n3", "f3", 16755200);
  b("n4", "f4", 16755200);
  b("p", "n1", 16711680);
  b("p", "n2", 16711680);
  b("p", "n3", 16711680);
  b("p", "n4", 16711680);
  b("u1", "u2", 43775);
  b("u2", "u3", 43775);
  b("u3", "u1", 43775);
  b("c", "t", 16777215);
  b("p", "c", 3355443);
  b("cn1", "cn2", 3355443);
  b("cn3", "cn4", 3355443);
  b("cf1", "cf2", 3355443);
  b("cf3", "cf4", 3355443);
  THREE.Line.call(this, d, e, THREE.LinePieces);
  this.camera = a;
  this.matrix = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.pointMap = f;
  this.update()
};
THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
THREE.CameraHelper.prototype.update = function() {
  var a, b, c = new THREE.Vector3,
    d = new THREE.Camera,
    e = function(e, g, h, k) {
      c.set(g, h, k).unproject(d);
      e = b[e];
      if (void 0 !== e)
        for (g = 0, h = e.length; g < h; g++) a.vertices[e[g]].copy(c)
    };
  return function() {
    a = this.geometry;
    b = this.pointMap;
    d.projectionMatrix.copy(this.camera.projectionMatrix);
    e("c", 0, 0, -1);
    e("t", 0, 0, 1);
    e("n1", -1, -1, -1);
    e("n2", 1, -1, -1);
    e("n3", -1, 1, -1);
    e("n4", 1, 1, -1);
    e("f1", -1, -1, 1);
    e("f2", 1, -1, 1);
    e("f3", -1, 1, 1);
    e("f4", 1, 1, 1);
    e("u1", .7, 1.1, -1);
    e("u2", -.7, 1.1, -1);
    e("u3", 0, 2, -1);
    e("cf1", -1, 0, 1);
    e("cf2", 1, 0, 1);
    e("cf3", 0, -1, 1);
    e("cf4", 0, 1, 1);
    e("cn1", -1, 0, -1);
    e("cn2", 1, 0, -1);
    e("cn3", 0, -1, -1);
    e("cn4", 0, 1, -1);
    a.verticesNeedUpdate = !0
  }
}();
THREE.DirectionalLightHelper = function(a, b) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrix = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  b = b || 1;
  var c = new THREE.Geometry;
  c.vertices.push(new THREE.Vector3(-b, b, 0), new THREE.Vector3(b, b, 0), new THREE.Vector3(b, -b, 0), new THREE.Vector3(-b, -b, 0), new THREE.Vector3(-b, b, 0));
  var d = new THREE.LineBasicMaterial({
    fog: !1
  });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.lightPlane = new THREE.Line(c, d);
  this.add(this.lightPlane);
  c = new THREE.Geometry;
  c.vertices.push(new THREE.Vector3, new THREE.Vector3);
  d = new THREE.LineBasicMaterial({
    fog: !1
  });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  this.targetLine = new THREE.Line(c, d);
  this.add(this.targetLine);
  this.update()
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
THREE.DirectionalLightHelper.prototype.dispose = function() {
  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose()
};
THREE.DirectionalLightHelper.prototype.update = function() {
  var a = new THREE.Vector3,
    b = new THREE.Vector3,
    c = new THREE.Vector3;
  return function() {
    a.setFromMatrixPosition(this.light.matrixWorld);
    b.setFromMatrixPosition(this.light.target.matrixWorld);
    c.subVectors(b, a);
    this.lightPlane.lookAt(c);
    this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine.geometry.vertices[1].copy(c);
    this.targetLine.geometry.verticesNeedUpdate = !0;
    this.targetLine.material.color.copy(this.lightPlane.material.color)
  }
}();
THREE.EdgesHelper = function(a, b) {
  var c = void 0 !== b ? b : 16777215,
    d = [0, 0],
    e = {},
    f = function(a, b) {
      return a - b
    },
    g = ["a", "b", "c"],
    h = new THREE.BufferGeometry,
    k = a.geometry.clone();
  k.mergeVertices();
  k.computeFaceNormals();
  for (var n = k.vertices, k = k.faces, p = 0, q = 0, m = k.length; q < m; q++)
    for (var t = k[q], s = 0; 3 > s; s++) {
      d[0] = t[g[s]];
      d[1] = t[g[(s + 1) % 3]];
      d.sort(f);
      var r = d.toString();
      void 0 === e[r] ? (e[r] = {
        vert1: d[0],
        vert2: d[1],
        face1: q,
        face2: void 0
      }, p++) : e[r].face2 = q
    }
  d = new Float32Array(6 * p);
  f = 0;
  for (r in e)
    if (g = e[r], void 0 === g.face2 || .9999 > k[g.face1].normal.dot(k[g.face2].normal)) p = n[g.vert1], d[f++] = p.x, d[f++] = p.y, d[f++] = p.z, p = n[g.vert2], d[f++] = p.x, d[f++] = p.y, d[f++] = p.z;
  h.addAttribute("position", new THREE.BufferAttribute(d, 3));
  THREE.Line.call(this, h, new THREE.LineBasicMaterial({
    color: c
  }), THREE.LinePieces);
  this.matrix = a.matrixWorld;
  this.matrixAutoUpdate = !1
};
THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
THREE.FaceNormalsHelper = function(a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  a = void 0 !== c ? c : 16776960;
  d = void 0 !== d ? d : 1;
  b = new THREE.Geometry;
  c = 0;
  for (var e = this.object.geometry.faces.length; c < e; c++) b.vertices.push(new THREE.Vector3, new THREE.Vector3);
  THREE.Line.call(this, b, new THREE.LineBasicMaterial({
    color: a,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.normalMatrix = new THREE.Matrix3;
  this.update()
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
THREE.FaceNormalsHelper.prototype.update = function() {
  var a = this.geometry.vertices,
    b = this.object,
    c = b.geometry.vertices,
    d = b.geometry.faces,
    e = b.matrixWorld;
  b.updateMatrixWorld(!0);
  this.normalMatrix.getNormalMatrix(e);
  for (var f = b = 0, g = d.length; b < g; b++, f += 2) {
    var h = d[b];
    a[f].copy(c[h.a]).add(c[h.b]).add(c[h.c]).divideScalar(3).applyMatrix4(e);
    a[f + 1].copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(a[f])
  }
  this.geometry.verticesNeedUpdate = !0;
  return this
};
THREE.GridHelper = function(a, b) {
  var c = new THREE.Geometry,
    d = new THREE.LineBasicMaterial({
      vertexColors: THREE.VertexColors
    });
  this.color1 = new THREE.Color(4473924);
  this.color2 = new THREE.Color(8947848);
  for (var e = -a; e <= a; e += b) {
    c.vertices.push(new THREE.Vector3(-a, 0, e), new THREE.Vector3(a, 0, e), new THREE.Vector3(e, 0, -a), new THREE.Vector3(e, 0, a));
    var f = 0 === e ? this.color1 : this.color2;
    c.colors.push(f, f, f, f)
  }
  THREE.Line.call(this, c, d, THREE.LinePieces)
};
THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.constructor = THREE.GridHelper;
THREE.GridHelper.prototype.setColors = function(a, b) {
  this.color1.set(a);
  this.color2.set(b);
  this.geometry.colorsNeedUpdate = !0
};
THREE.HemisphereLightHelper = function(a, b, c, d) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrix = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.colors = [new THREE.Color, new THREE.Color];
  a = new THREE.SphereGeometry(b, 4, 2);
  a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
  for (b = 0; 8 > b; b++) a.faces[b].color = this.colors[4 > b ? 0 : 1];
  b = new THREE.MeshBasicMaterial({
    vertexColors: THREE.FaceColors,
    wireframe: !0
  });
  this.lightSphere = new THREE.Mesh(a, b);
  this.add(this.lightSphere);
  this.update()
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
THREE.HemisphereLightHelper.prototype.dispose = function() {
  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose()
};
THREE.HemisphereLightHelper.prototype.update = function() {
  var a = new THREE.Vector3;
  return function() {
    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
    this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
    this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
    this.lightSphere.geometry.colorsNeedUpdate = !0
  }
}();
THREE.PointLightHelper = function(a, b) {
  this.light = a;
  this.light.updateMatrixWorld();
  var c = new THREE.SphereGeometry(b, 4, 2),
    d = new THREE.MeshBasicMaterial({
      wireframe: !0,
      fog: !1
    });
  d.color.copy(this.light.color).multiplyScalar(this.light.intensity);
  THREE.Mesh.call(this, c, d);
  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = !1
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
THREE.PointLightHelper.prototype.dispose = function() {
  this.geometry.dispose();
  this.material.dispose()
};
THREE.PointLightHelper.prototype.update = function() {
  this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
};
THREE.SkeletonHelper = function(a) {
  this.bones = this.getBoneList(a);
  for (var b = new THREE.Geometry, c = 0; c < this.bones.length; c++) this.bones[c].parent instanceof THREE.Bone && (b.vertices.push(new THREE.Vector3), b.vertices.push(new THREE.Vector3), b.colors.push(new THREE.Color(0, 0, 1)), b.colors.push(new THREE.Color(0, 1, 0)));
  c = new THREE.LineBasicMaterial({
    vertexColors: THREE.VertexColors,
    depthTest: !1,
    depthWrite: !1,
    transparent: !0
  });
  THREE.Line.call(this, b, c, THREE.LinePieces);
  this.root = a;
  this.matrix = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  this.update()
};
THREE.SkeletonHelper.prototype = Object.create(THREE.Line.prototype);
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
THREE.SkeletonHelper.prototype.getBoneList = function(a) {
  var b = [];
  a instanceof THREE.Bone && b.push(a);
  for (var c = 0; c < a.children.length; c++) b.push.apply(b, this.getBoneList(a.children[c]));
  return b
};
THREE.SkeletonHelper.prototype.update = function() {
  for (var a = this.geometry, b = (new THREE.Matrix4).getInverse(this.root.matrixWorld), c = new THREE.Matrix4, d = 0, e = 0; e < this.bones.length; e++) {
    var f = this.bones[e];
    f.parent instanceof THREE.Bone && (c.multiplyMatrices(b, f.matrixWorld), a.vertices[d].setFromMatrixPosition(c), c.multiplyMatrices(b, f.parent.matrixWorld), a.vertices[d + 1].setFromMatrixPosition(c), d += 2)
  }
  a.verticesNeedUpdate = !0;
  a.computeBoundingSphere()
};
THREE.SpotLightHelper = function(a) {
  THREE.Object3D.call(this);
  this.light = a;
  this.light.updateMatrixWorld();
  this.matrix = a.matrixWorld;
  this.matrixAutoUpdate = !1;
  a = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0);
  a.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0));
  a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
  var b = new THREE.MeshBasicMaterial({
    wireframe: !0,
    fog: !1
  });
  this.cone = new THREE.Mesh(a, b);
  this.add(this.cone);
  this.update()
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
THREE.SpotLightHelper.prototype.dispose = function() {
  this.cone.geometry.dispose();
  this.cone.material.dispose()
};
THREE.SpotLightHelper.prototype.update = function() {
  var a = new THREE.Vector3,
    b = new THREE.Vector3;
  return function() {
    var c = this.light.distance ? this.light.distance : 1E4,
      d = c * Math.tan(this.light.angle);
    this.cone.scale.set(d, d, c);
    a.setFromMatrixPosition(this.light.matrixWorld);
    b.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(b.sub(a));
    this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
  }
}();
THREE.VertexNormalsHelper = function(a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  b = void 0 !== c ? c : 16711680;
  d = void 0 !== d ? d : 1;
  c = new THREE.Geometry;
  a = a.geometry.faces;
  for (var e = 0, f = a.length; e < f; e++)
    for (var g = 0, h = a[e].vertexNormals.length; g < h; g++) c.vertices.push(new THREE.Vector3, new THREE.Vector3);
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({
    color: b,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.normalMatrix = new THREE.Matrix3;
  this.update()
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
THREE.VertexNormalsHelper.prototype.update = function(a) {
  var b = new THREE.Vector3;
  return function(a) {
    a = ["a", "b", "c", "d"];
    this.object.updateMatrixWorld(!0);
    this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
    for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, n = f.length; k < n; k++)
      for (var p = f[k], q = 0, m = p.vertexNormals.length; q < m; q++) {
        var t = p.vertexNormals[q];
        d[h].copy(e[p[a[q]]]).applyMatrix4(g);
        b.copy(t).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
        b.add(d[h]);
        h += 1;
        d[h].copy(b);
        h += 1
      }
    this.geometry.verticesNeedUpdate = !0;
    return this
  }
}();
THREE.VertexTangentsHelper = function(a, b, c, d) {
  this.object = a;
  this.size = void 0 !== b ? b : 1;
  b = void 0 !== c ? c : 255;
  d = void 0 !== d ? d : 1;
  c = new THREE.Geometry;
  a = a.geometry.faces;
  for (var e = 0, f = a.length; e < f; e++)
    for (var g = 0, h = a[e].vertexTangents.length; g < h; g++) c.vertices.push(new THREE.Vector3), c.vertices.push(new THREE.Vector3);
  THREE.Line.call(this, c, new THREE.LineBasicMaterial({
    color: b,
    linewidth: d
  }), THREE.LinePieces);
  this.matrixAutoUpdate = !1;
  this.update()
};
THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;
THREE.VertexTangentsHelper.prototype.update = function(a) {
  var b = new THREE.Vector3;
  return function(a) {
    a = ["a", "b", "c", "d"];
    this.object.updateMatrixWorld(!0);
    for (var d = this.geometry.vertices, e = this.object.geometry.vertices, f = this.object.geometry.faces, g = this.object.matrixWorld, h = 0, k = 0, n = f.length; k < n; k++)
      for (var p = f[k], q = 0, m = p.vertexTangents.length; q < m; q++) {
        var t = p.vertexTangents[q];
        d[h].copy(e[p[a[q]]]).applyMatrix4(g);
        b.copy(t).transformDirection(g).multiplyScalar(this.size);
        b.add(d[h]);
        h += 1;
        d[h].copy(b);
        h += 1
      }
    this.geometry.verticesNeedUpdate = !0;
    return this
  }
}();
THREE.WireframeHelper = function(a, b) {
  var c = void 0 !== b ? b : 16777215,
    d = [0, 0],
    e = {},
    f = function(a, b) {
      return a - b
    },
    g = ["a", "b", "c"],
    h = new THREE.BufferGeometry;
  if (a.geometry instanceof THREE.Geometry) {
    for (var k = a.geometry.vertices, n = a.geometry.faces, p = 0, q = new Uint32Array(6 * n.length), m = 0, t = n.length; m < t; m++)
      for (var s = n[m], r = 0; 3 > r; r++) {
        d[0] = s[g[r]];
        d[1] = s[g[(r + 1) % 3]];
        d.sort(f);
        var u = d.toString();
        void 0 === e[u] && (q[2 * p] = d[0], q[2 * p + 1] = d[1], e[u] = !0, p++)
      }
    d = new Float32Array(6 * p);
    m = 0;
    for (t = p; m < t; m++)
      for (r = 0; 2 > r; r++) p = k[q[2 * m + r]], g = 6 * m + 3 * r, d[g + 0] = p.x, d[g + 1] = p.y, d[g + 2] = p.z;
    h.addAttribute("position", new THREE.BufferAttribute(d, 3))
  } else if (a.geometry instanceof THREE.BufferGeometry) {
    if (void 0 !== a.geometry.attributes.index) {
      k = a.geometry.attributes.position.array;
      t = a.geometry.attributes.index.array;
      n = a.geometry.drawcalls;
      p = 0;
      0 === n.length && (n = [{
        count: t.length,
        index: 0,
        start: 0
      }]);
      for (var q = new Uint32Array(2 * t.length), s = 0, v = n.length; s < v; ++s)
        for (var r = n[s].start, u = n[s].count, g = n[s].index, m = r, y = r + u; m < y; m += 3)
          for (r = 0; 3 > r; r++) d[0] = g + t[m + r], d[1] = g + t[m + (r + 1) % 3], d.sort(f), u = d.toString(), void 0 === e[u] && (q[2 * p] = d[0], q[2 * p + 1] = d[1], e[u] = !0, p++);
      d = new Float32Array(6 * p);
      m = 0;
      for (t = p; m < t; m++)
        for (r = 0; 2 > r; r++) g = 6 * m + 3 * r, p = 3 * q[2 * m + r], d[g + 0] = k[p], d[g + 1] = k[p + 1], d[g + 2] = k[p + 2]
    } else
      for (k = a.geometry.attributes.position.array, p = k.length / 3, q = p / 3, d = new Float32Array(6 * p), m = 0, t = q; m < t; m++)
        for (r = 0; 3 > r; r++) g = 18 * m + 6 * r, q = 9 * m + 3 * r, d[g + 0] = k[q], d[g + 1] = k[q + 1], d[g + 2] = k[q + 2], p = 9 * m + (r + 1) % 3 * 3, d[g + 3] = k[p], d[g + 4] = k[p + 1], d[g + 5] = k[p + 2];
    h.addAttribute("position", new THREE.BufferAttribute(d, 3))
  }
  THREE.Line.call(this, h, new THREE.LineBasicMaterial({
    color: c
  }), THREE.LinePieces);
  this.matrix = a.matrixWorld;
  this.matrixAutoUpdate = !1
};
THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
THREE.ImmediateRenderObject = function() {
  THREE.Object3D.call(this);
  this.render = function(a) {}
};
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
THREE.MorphBlendMesh = function(a, b) {
  THREE.Mesh.call(this, a, b);
  this.animationsMap = {};
  this.animationsList = [];
  var c = this.geometry.morphTargets.length;
  this.createAnimation("__default", 0, c - 1, c / 1);
  this.setAnimationWeight("__default", 1)
};
THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;
THREE.MorphBlendMesh.prototype.createAnimation = function(a, b, c, d) {
  b = {
    startFrame: b,
    endFrame: c,
    length: c - b + 1,
    fps: d,
    duration: (c - b) / d,
    lastFrame: 0,
    currentFrame: 0,
    active: !1,
    time: 0,
    direction: 1,
    weight: 1,
    directionBackwards: !1,
    mirroredLoop: !1
  };
  this.animationsMap[a] = b;
  this.animationsList.push(b)
};
THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(a) {
  for (var b = /([a-z]+)_?(\d+)/, c, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
    var h = e.morphTargets[f].name.match(b);
    if (h && 1 < h.length) {
      var k = h[1];
      d[k] || (d[k] = {
        start: Infinity,
        end: -Infinity
      });
      h = d[k];
      f < h.start && (h.start = f);
      f > h.end && (h.end = f);
      c || (c = k)
    }
  }
  for (k in d) h = d[k], this.createAnimation(k, h.start, h.end, a);
  this.firstAnimation = c
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(a) {
  if (a = this.animationsMap[a]) a.direction = 1, a.directionBackwards = !1
};
THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(a) {
  if (a = this.animationsMap[a]) a.direction = -1, a.directionBackwards = !0
};
THREE.MorphBlendMesh.prototype.setAnimationFPS = function(a, b) {
  var c = this.animationsMap[a];
  c && (c.fps = b, c.duration = (c.end - c.start) / c.fps)
};
THREE.MorphBlendMesh.prototype.setAnimationDuration = function(a, b) {
  var c = this.animationsMap[a];
  c && (c.duration = b, c.fps = (c.end - c.start) / c.duration)
};
THREE.MorphBlendMesh.prototype.setAnimationWeight = function(a, b) {
  var c = this.animationsMap[a];
  c && (c.weight = b)
};
THREE.MorphBlendMesh.prototype.setAnimationTime = function(a, b) {
  var c = this.animationsMap[a];
  c && (c.time = b)
};
THREE.MorphBlendMesh.prototype.getAnimationTime = function(a) {
  var b = 0;
  if (a = this.animationsMap[a]) b = a.time;
  return b
};
THREE.MorphBlendMesh.prototype.getAnimationDuration = function(a) {
  var b = -1;
  if (a = this.animationsMap[a]) b = a.duration;
  return b
};
THREE.MorphBlendMesh.prototype.playAnimation = function(a) {
  var b = this.animationsMap[a];
  b ? (b.time = 0, b.active = !0) : console.warn("animation[" + a + "] undefined")
};
THREE.MorphBlendMesh.prototype.stopAnimation = function(a) {
  if (a = this.animationsMap[a]) a.active = !1
};
THREE.MorphBlendMesh.prototype.update = function(a) {
  for (var b = 0, c = this.animationsList.length; b < c; b++) {
    var d = this.animationsList[b];
    if (d.active) {
      var e = d.duration / d.length;
      d.time += d.direction * a;
      if (d.mirroredLoop) {
        if (d.time > d.duration || 0 > d.time) d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1)
      } else d.time %= d.duration, 0 > d.time && (d.time += d.duration);
      var f = d.startFrame + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1),
        g = d.weight;
      f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] = 0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);
      e = d.time % e / e;
      d.directionBackwards && (e = 1 - e);
      this.morphTargetInfluences[d.currentFrame] = e * g;
      this.morphTargetInfluences[d.lastFrame] = (1 - e) * g
    }
  }
};
THREE.RenderableObject = function() {
  this.id = 0, this.object = null, this.z = 0
}, THREE.RenderableFace = function() {
  this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.v3 = new THREE.RenderableVertex, this.normalModel = new THREE.Vector3, this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3], this.vertexNormalsLength = 0, this.color = new THREE.Color, this.material = null, this.uvs = [new THREE.Vector2, new THREE.Vector2, new THREE.Vector2], this.z = 0
}, THREE.RenderableVertex = function() {
  this.position = new THREE.Vector3, this.positionWorld = new THREE.Vector3, this.positionScreen = new THREE.Vector4, this.visible = !0
}, THREE.RenderableVertex.prototype.copy = function(e) {
  this.positionWorld.copy(e.positionWorld), this.positionScreen.copy(e.positionScreen)
}, THREE.RenderableLine = function() {
  this.id = 0, this.v1 = new THREE.RenderableVertex, this.v2 = new THREE.RenderableVertex, this.vertexColors = [new THREE.Color, new THREE.Color], this.material = null, this.z = 0
}, THREE.RenderableSprite = function() {
  this.id = 0, this.object = null, this.x = 0, this.y = 0, this.z = 0, this.rotation = 0, this.scale = new THREE.Vector2, this.material = null
}, THREE.Projector = function() {
  function e() {
    if (c === R) {
      var e = new THREE.RenderableObject;
      return m.push(e), R++, c++, e
    }
    return m[c++]
  }

  function t() {
    if (p === T) {
      var e = new THREE.RenderableVertex;
      return y.push(e), T++, p++, e
    }
    return y[p++]
  }

  function r() {
    if (u === w) {
      var e = new THREE.RenderableFace;
      return H.push(e), w++, u++, e
    }
    return H[u++]
  }

  function i() {
    if (v === g) {
      var e = new THREE.RenderableLine;
      return b.push(e), g++, v++, e
    }
    return b[v++]
  }

  function o() {
    if (d === M) {
      var e = new THREE.RenderableSprite;
      return z.push(e), M++, d++, e
    }
    return z[d++]
  }

  function n(e, t) {
    return e.z !== t.z ? t.z - e.z : e.id !== t.id ? e.id - t.id : 0
  }

  function a(e, t) {
    var r = 0,
      i = 1,
      o = e.z + e.w,
      n = t.z + t.w,
      a = -e.z + e.w,
      s = -t.z + t.w;
    return o >= 0 && n >= 0 && a >= 0 && s >= 0 ? !0 : 0 > o && 0 > n || 0 > a && 0 > s ? !1 : (0 > o ? r = Math.max(r, o / (o - n)) : 0 > n && (i = Math.min(i, o / (o - n))), 0 > a ? r = Math.max(r, a / (a - s)) : 0 > s && (i = Math.min(i, a / (a - s))), r > i ? !1 : (e.lerp(t, r), t.lerp(e, 1 - i), !0))
  }
  var s, c, l, p, E, u, h, v, f, d, x, m = [],
    R = 0,
    y = [],
    T = 0,
    H = [],
    w = 0,
    b = [],
    g = 0,
    z = [],
    M = 0,
    V = {
      objects: [],
      lights: [],
      elements: []
    },
    S = new THREE.Vector3,
    j = new THREE.Vector3,
    L = new THREE.Vector3,
    k = new THREE.Vector3,
    C = new THREE.Vector4,
    N = new THREE.Box3(new THREE.Vector3(-1, -1, -1), new THREE.Vector3(1, 1, 1)),
    W = new THREE.Box3,
    B = new Array(3),
    P = (new Array(4), new THREE.Matrix4),
    F = new THREE.Matrix4,
    D = new THREE.Matrix4,
    I = new THREE.Matrix3,
    O = new THREE.Frustum,
    G = new THREE.Vector4,
    U = new THREE.Vector4;
  this.projectVector = function(e, t) {
    console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t)
  }, this.unprojectVector = function(e, t) {
    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t)
  }, this.pickingRay = function(e, t) {
    console.error("THREE.Projector: .pickingRay() has been removed.")
  };
  var A = function() {
      var e = [],
        o = [],
        n = null,
        a = null,
        s = new THREE.Matrix3,
        c = function(t) {
          n = t, a = n.material, s.getNormalMatrix(n.matrixWorld), e.length = 0, o.length = 0
        },
        p = function(e) {
          var t = e.position,
            r = e.positionWorld,
            i = e.positionScreen;
          r.copy(t).applyMatrix4(x), i.copy(r).applyMatrix4(F);
          var o = 1 / i.w;
          i.x *= o, i.y *= o, i.z *= o, e.visible = i.x >= -1 && i.x <= 1 && i.y >= -1 && i.y <= 1 && i.z >= -1 && i.z <= 1
        },
        u = function(e, r, i) {
          l = t(), l.position.set(e, r, i), p(l)
        },
        v = function(t, r, i) {
          e.push(t, r, i)
        },
        f = function(e, t) {
          o.push(e, t)
        },
        d = function(e, t, r) {
          return e.visible === !0 || t.visible === !0 || r.visible === !0 ? !0 : (B[0] = e.positionScreen, B[1] = t.positionScreen, B[2] = r.positionScreen, N.isIntersectionBox(W.setFromPoints(B)))
        },
        m = function(e, t, r) {
          return (r.positionScreen.x - e.positionScreen.x) * (t.positionScreen.y - e.positionScreen.y) - (r.positionScreen.y - e.positionScreen.y) * (t.positionScreen.x - e.positionScreen.x) < 0
        },
        R = function(e, t) {
          var r = y[e],
            o = y[t];
          h = i(), h.id = n.id, h.v1.copy(r), h.v2.copy(o), h.z = (r.positionScreen.z + o.positionScreen.z) / 2, h.material = n.material, V.elements.push(h)
        },
        T = function(t, i, c) {
          var l = y[t],
            p = y[i],
            u = y[c];
          if (d(l, p, u) !== !1 && (a.side === THREE.DoubleSide || m(l, p, u) === !0)) {
            E = r(), E.id = n.id, E.v1.copy(l), E.v2.copy(p), E.v3.copy(u), E.z = (l.positionScreen.z + p.positionScreen.z + u.positionScreen.z) / 3;
            for (var h = 0; 3 > h; h++) {
              var v = 3 * arguments[h],
                f = E.vertexNormalsModel[h];
              f.set(e[v], e[v + 1], e[v + 2]), f.applyMatrix3(s).normalize();
              var x = 2 * arguments[h],
                R = E.uvs[h];
              R.set(o[x], o[x + 1])
            }
            E.vertexNormalsLength = 3, E.material = n.material, V.elements.push(E)
          }
        };
      return {
        setObject: c,
        projectVertex: p,
        checkTriangleVisibility: d,
        checkBackfaceCulling: m,
        pushVertex: u,
        pushNormal: v,
        pushUv: f,
        pushLine: R,
        pushTriangle: T
      }
    },
    q = new A;
  this.projectScene = function(l, m, R, T) {
    u = 0, v = 0, d = 0, V.elements.length = 0, l.autoUpdate === !0 && l.updateMatrixWorld(), void 0 === m.parent && m.updateMatrixWorld(), P.copy(m.matrixWorldInverse.getInverse(m.matrixWorld)), F.multiplyMatrices(m.projectionMatrix, P), O.setFromMatrix(F), c = 0, V.objects.length = 0, V.lights.length = 0, l.traverseVisible(function(t) {
      if (t instanceof THREE.Light) V.lights.push(t);
      else if (t instanceof THREE.Mesh || t instanceof THREE.Line || t instanceof THREE.Sprite) {
        if (t.material.visible === !1) return;
        (t.frustumCulled === !1 || O.intersectsObject(t) === !0) && (s = e(), s.id = t.id, s.object = t, null !== t.renderDepth ? s.z = t.renderDepth : (k.setFromMatrixPosition(t.matrixWorld), k.applyProjection(F), s.z = k.z), V.objects.push(s))
      }
    }), R === !0 && V.objects.sort(n);
    for (var H = 0, w = V.objects.length; w > H; H++) {
      var b = V.objects[H].object,
        g = b.geometry;
      if (q.setObject(b), x = b.matrixWorld, p = 0, b instanceof THREE.Mesh) {
        if (g instanceof THREE.BufferGeometry) {
          var z = g.attributes,
            M = g.offsets;
          if (void 0 === z.position) continue;
          for (var N = z.position.array, W = 0, B = N.length; B > W; W += 3) q.pushVertex(N[W], N[W + 1], N[W + 2]);
          if (void 0 !== z.normal)
            for (var A = z.normal.array, W = 0, B = A.length; B > W; W += 3) q.pushNormal(A[W], A[W + 1], A[W + 2]);
          if (void 0 !== z.uv)
            for (var J = z.uv.array, W = 0, B = J.length; B > W; W += 2) q.pushUv(J[W], J[W + 1]);
          if (void 0 !== z.index) {
            var K = z.index.array;
            if (M.length > 0)
              for (var H = 0; H < M.length; H++)
                for (var Q = M[H], X = Q.index, W = Q.start, B = Q.start + Q.count; B > W; W += 3) q.pushTriangle(K[W] + X, K[W + 1] + X, K[W + 2] + X);
            else
              for (var W = 0, B = K.length; B > W; W += 3) q.pushTriangle(K[W], K[W + 1], K[W + 2])
          } else
            for (var W = 0, B = N.length / 3; B > W; W += 3) q.pushTriangle(W, W + 1, W + 2)
        } else if (g instanceof THREE.Geometry) {
          var Y = g.vertices,
            Z = g.faces,
            $ = g.faceVertexUvs[0];
          I.getNormalMatrix(x);
          for (var _ = b.material instanceof THREE.MeshFaceMaterial, ee = _ === !0 ? b.material : null, te = 0, re = Y.length; re > te; te++) {
            var ie = Y[te];
            q.pushVertex(ie.x, ie.y, ie.z)
          }
          for (var oe = 0, ne = Z.length; ne > oe; oe++) {
            var ae = Z[oe],
              se = _ === !0 ? ee.materials[ae.materialIndex] : b.material;
            if (void 0 !== se) {
              var ce = se.side,
                le = y[ae.a],
                pe = y[ae.b],
                Ee = y[ae.c];
              if (se.morphTargets === !0) {
                var ue = g.morphTargets,
                  he = b.morphTargetInfluences,
                  ve = le.position,
                  fe = pe.position,
                  de = Ee.position;
                S.set(0, 0, 0), j.set(0, 0, 0), L.set(0, 0, 0);
                for (var xe = 0, me = ue.length; me > xe; xe++) {
                  var Re = he[xe];
                  if (0 !== Re) {
                    var ye = ue[xe].vertices;
                    S.x += (ye[ae.a].x - ve.x) * Re, S.y += (ye[ae.a].y - ve.y) * Re, S.z += (ye[ae.a].z - ve.z) * Re, j.x += (ye[ae.b].x - fe.x) * Re, j.y += (ye[ae.b].y - fe.y) * Re, j.z += (ye[ae.b].z - fe.z) * Re, L.x += (ye[ae.c].x - de.x) * Re, L.y += (ye[ae.c].y - de.y) * Re, L.z += (ye[ae.c].z - de.z) * Re
                  }
                }
                le.position.add(S), pe.position.add(j), Ee.position.add(L), q.projectVertex(le), q.projectVertex(pe), q.projectVertex(Ee)
              }
              if (q.checkTriangleVisibility(le, pe, Ee) !== !1) {
                var Te = q.checkBackfaceCulling(le, pe, Ee);
                if (ce !== THREE.DoubleSide) {
                  if (ce === THREE.FrontSide && Te === !1) continue;
                  if (ce === THREE.BackSide && Te === !0) continue
                }
                E = r(), E.id = b.id, E.v1.copy(le), E.v2.copy(pe), E.v3.copy(Ee), E.normalModel.copy(ae.normal), Te !== !1 || ce !== THREE.BackSide && ce !== THREE.DoubleSide || E.normalModel.negate(), E.normalModel.applyMatrix3(I).normalize();
                for (var He = ae.vertexNormals, we = 0, be = Math.min(He.length, 3); be > we; we++) {
                  var ge = E.vertexNormalsModel[we];
                  ge.copy(He[we]), Te !== !1 || ce !== THREE.BackSide && ce !== THREE.DoubleSide || ge.negate(), ge.applyMatrix3(I).normalize()
                }
                E.vertexNormalsLength = He.length;
                var ze = $[oe];
                if (void 0 !== ze)
                  for (var Me = 0; 3 > Me; Me++) E.uvs[Me].copy(ze[Me]);
                E.color = ae.color, E.material = se, E.z = (le.positionScreen.z + pe.positionScreen.z + Ee.positionScreen.z) / 3, V.elements.push(E)
              }
            }
          }
        }
      } else if (b instanceof THREE.Line) {
        if (g instanceof THREE.BufferGeometry) {
          var z = g.attributes;
          if (void 0 !== z.position) {
            for (var N = z.position.array, W = 0, B = N.length; B > W; W += 3) q.pushVertex(N[W], N[W + 1], N[W + 2]);
            if (void 0 !== z.index)
              for (var K = z.index.array, W = 0, B = K.length; B > W; W += 2) q.pushLine(K[W], K[W + 1]);
            else
              for (var Ve = b.mode === THREE.LinePieces ? 2 : 1, W = 0, B = N.length / 3 - 1; B > W; W += Ve) q.pushLine(W, W + 1)
          }
        } else if (g instanceof THREE.Geometry) {
          D.multiplyMatrices(F, x);
          var Y = b.geometry.vertices;
          if (0 === Y.length) continue;
          le = t(), le.positionScreen.copy(Y[0]).applyMatrix4(D);
          for (var Ve = b.mode === THREE.LinePieces ? 2 : 1, te = 1, re = Y.length; re > te; te++) le = t(), le.positionScreen.copy(Y[te]).applyMatrix4(D), (te + 1) % Ve > 0 || (pe = y[p - 2], G.copy(le.positionScreen), U.copy(pe.positionScreen), a(G, U) === !0 && (G.multiplyScalar(1 / G.w), U.multiplyScalar(1 / U.w), h = i(), h.id = b.id, h.v1.positionScreen.copy(G), h.v2.positionScreen.copy(U), h.z = Math.max(G.z, U.z), h.material = b.material, b.material.vertexColors === THREE.VertexColors && (h.vertexColors[0].copy(b.geometry.colors[te]), h.vertexColors[1].copy(b.geometry.colors[te - 1])), V.elements.push(h)))
        }
      } else if (b instanceof THREE.Sprite) {
        C.set(x.elements[12], x.elements[13], x.elements[14], 1), C.applyMatrix4(F);
        var Se = 1 / C.w;
        C.z *= Se, C.z >= -1 && C.z <= 1 && (f = o(), f.id = b.id, f.x = C.x * Se, f.y = C.y * Se, f.z = C.z, f.object = b, f.rotation = b.rotation, f.scale.x = b.scale.x * Math.abs(f.x - (C.x + m.projectionMatrix.elements[0]) / (C.w + m.projectionMatrix.elements[12])), f.scale.y = b.scale.y * Math.abs(f.y - (C.y + m.projectionMatrix.elements[5]) / (C.w + m.projectionMatrix.elements[13])), f.material = b.material, V.elements.push(f))
      }
    }
    return T === !0 && V.elements.sort(n), V
  }
};
THREE.SpriteCanvasMaterial = function(e) {
  THREE.Material.call(this), this.type = "SpriteCanvasMaterial", this.color = new THREE.Color(16777215), this.program = function(e, i) {}, this.setValues(e)
}, THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype), THREE.SpriteCanvasMaterial.prototype.clone = function() {
  var e = new THREE.SpriteCanvasMaterial;
  return THREE.Material.prototype.clone.call(this, e), e.color.copy(this.color), e.program = this.program, e
}, THREE.CanvasRenderer = function(e) {
  function i() {
    ve.setRGB(0, 0, 0), Re.setRGB(0, 0, 0), ue.setRGB(0, 0, 0);
    for (var e = 0, i = w.length; i > e; e++) {
      var t = w[e],
        n = t.color;
      t instanceof THREE.AmbientLight ? ve.add(n) : t instanceof THREE.DirectionalLight ? Re.add(n) : t instanceof THREE.PointLight && ue.add(n)
    }
  }

  function t(e, i, t) {
    for (var n = 0, o = w.length; o > n; n++) {
      var r = w[n];
      if (de.copy(r.color), r instanceof THREE.DirectionalLight) {
        var a = Se.setFromMatrixPosition(r.matrixWorld).normalize(),
          s = i.dot(a);
        if (0 >= s) continue;
        s *= r.intensity, t.add(de.multiplyScalar(s))
      } else if (r instanceof THREE.PointLight) {
        var a = Se.setFromMatrixPosition(r.matrixWorld),
          s = i.dot(Se.subVectors(a, e).normalize());
        if (0 >= s) continue;
        if (s *= 0 == r.distance ? 1 : 1 - Math.min(e.distanceTo(a) / r.distance, 1), 0 == s) continue;
        s *= r.intensity, t.add(de.multiplyScalar(s))
      }
    }
  }

  function n(e, i, t) {
    d(t.opacity), h(t.blending);
    var n = i.scale.x * K,
      o = i.scale.y * Q,
      r = .5 * Math.sqrt(n * n + o * o);
    if (ye.min.set(e.x - r, e.y - r), ye.max.set(e.x + r, e.y + r), t instanceof THREE.SpriteMaterial) {
      var a = t.map;
      if (null !== a && void 0 !== a.image) {
        a.hasEventListener("update", c) === !1 && (a.image.width > 0 && p(a), a.addEventListener("update", c));
        var s = he[a.id];
        R(void 0 !== s ? s : "rgba( 0, 0, 0, 1 )");
        var l = a.image,
          E = l.width * a.offset.x,
          f = l.height * a.offset.y,
          m = l.width * a.repeat.x,
          x = l.height * a.repeat.y,
          y = n / m,
          u = o / x;
        _.save(), _.translate(e.x, e.y), 0 !== t.rotation && _.rotate(t.rotation), _.translate(-n / 2, -o / 2), _.scale(y, u), _.translate(-E, -f), _.fillRect(E, f, m, x), _.restore()
      } else R(t.color.getStyle()), _.save(), _.translate(e.x, e.y), 0 !== t.rotation && _.rotate(t.rotation), _.scale(n, -o), _.fillRect(-.5, -.5, 1, 1), _.restore()
    } else t instanceof THREE.SpriteCanvasMaterial && (v(t.color.getStyle()), R(t.color.getStyle()), _.save(), _.translate(e.x, e.y), 0 !== t.rotation && _.rotate(t.rotation), _.scale(n, o), t.program(_), _.restore())
  }

  function o(e, i, t, n) {
    if (d(n.opacity), h(n.blending), _.beginPath(), _.moveTo(e.positionScreen.x, e.positionScreen.y), _.lineTo(i.positionScreen.x, i.positionScreen.y), n instanceof THREE.LineBasicMaterial) {
      if (m(n.linewidth), x(n.linecap), y(n.linejoin), n.vertexColors !== THREE.VertexColors) v(n.color.getStyle());
      else {
        var o = t.vertexColors[0].getStyle(),
          r = t.vertexColors[1].getStyle();
        if (o === r) v(o);
        else {
          try {
            var a = _.createLinearGradient(e.positionScreen.x, e.positionScreen.y, i.positionScreen.x, i.positionScreen.y);
            a.addColorStop(0, o), a.addColorStop(1, r)
          } catch (s) {
            a = o
          }
          v(a)
        }
      }
      _.stroke(), ye.expandByScalar(2 * n.linewidth)
    } else n instanceof THREE.LineDashedMaterial && (m(n.linewidth), x(n.linecap), y(n.linejoin), v(n.color.getStyle()), u([n.dashSize, n.gapSize]), _.stroke(), ye.expandByScalar(2 * n.linewidth), u([]))
  }

  function r(e, i, n, o, r, c, p, f) {
    I.info.render.vertices += 3, I.info.render.faces++, d(f.opacity), h(f.blending), b = e.positionScreen.x, P = e.positionScreen.y, B = i.positionScreen.x, z = i.positionScreen.y, V = n.positionScreen.x, j = n.positionScreen.y, a(b, P, B, z, V, j), (f instanceof THREE.MeshLambertMaterial || f instanceof THREE.MeshPhongMaterial) && null === f.map ? (Ee.copy(f.color), fe.copy(f.emissive), f.vertexColors === THREE.FaceColors && Ee.multiply(p.color), pe.copy(ve), Te.copy(e.positionWorld).add(i.positionWorld).add(n.positionWorld).divideScalar(3), t(Te, p.normalModel, pe), pe.multiply(Ee).add(fe), f.wireframe === !0 ? s(pe, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : l(pe)) : f instanceof THREE.MeshBasicMaterial || f instanceof THREE.MeshLambertMaterial || f instanceof THREE.MeshPhongMaterial ? null !== f.map ? f.map.mapping instanceof THREE.UVMapping && (N = p.uvs, E(b, P, B, z, V, j, N[o].x, N[o].y, N[r].x, N[r].y, N[c].x, N[c].y, f.map)) : null !== f.envMap ? f.envMap.mapping instanceof THREE.SphericalReflectionMapping ? (ge.copy(p.vertexNormalsModel[o]).applyMatrix3(we), D = .5 * ge.x + .5, W = .5 * ge.y + .5, ge.copy(p.vertexNormalsModel[r]).applyMatrix3(we), F = .5 * ge.x + .5, k = .5 * ge.y + .5, ge.copy(p.vertexNormalsModel[c]).applyMatrix3(we), O = .5 * ge.x + .5, G = .5 * ge.y + .5, E(b, P, B, z, V, j, D, W, F, k, O, G, f.envMap)) : f.envMap.mapping instanceof THREE.SphericalRefractionMapping && (ge.copy(p.vertexNormalsModel[o]).applyMatrix3(we), D = -.5 * ge.x + .5, W = -.5 * ge.y + .5, ge.copy(p.vertexNormalsModel[r]).applyMatrix3(we), F = -.5 * ge.x + .5, k = -.5 * ge.y + .5, ge.copy(p.vertexNormalsModel[c]).applyMatrix3(we), O = -.5 * ge.x + .5, G = -.5 * ge.y + .5, E(b, P, B, z, V, j, D, W, F, k, O, G, f.envMap)) : (pe.copy(f.color), f.vertexColors === THREE.FaceColors && pe.multiply(p.color), f.wireframe === !0 ? s(pe, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : l(pe)) : f instanceof THREE.MeshDepthMaterial ? (pe.r = pe.g = pe.b = 1 - S(e.positionScreen.z * e.positionScreen.w, H.near, H.far), f.wireframe === !0 ? s(pe, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : l(pe)) : f instanceof THREE.MeshNormalMaterial ? (ge.copy(p.normalModel).applyMatrix3(we), pe.setRGB(ge.x, ge.y, ge.z).multiplyScalar(.5).addScalar(.5), f.wireframe === !0 ? s(pe, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : l(pe)) : (pe.setRGB(1, 1, 1), f.wireframe === !0 ? s(pe, f.wireframeLinewidth, f.wireframeLinecap, f.wireframeLinejoin) : l(pe))
  }

  function a(e, i, t, n, o, r) {
    _.beginPath(), _.moveTo(e, i), _.lineTo(t, n), _.lineTo(o, r), _.closePath()
  }

  function s(e, i, t, n) {
    m(i), x(t), y(n), v(e.getStyle()), _.stroke(), ye.expandByScalar(2 * i)
  }

  function l(e) {
    R(e.getStyle()), _.fill()
  }

  function c(e) {
    p(e.target)
  }

  function p(e) {
    if (!(e instanceof THREE.CompressedTexture)) {
      var i = e.wrapS === THREE.RepeatWrapping,
        t = e.wrapT === THREE.RepeatWrapping,
        n = e.image,
        o = document.createElement("canvas");
      o.width = n.width, o.height = n.height;
      var r = o.getContext("2d");
      r.setTransform(1, 0, 0, -1, 0, n.height), r.drawImage(n, 0, 0), he[e.id] = _.createPattern(o, i === !0 && t === !0 ? "repeat" : i === !0 && t === !1 ? "repeat-x" : i === !1 && t === !0 ? "repeat-y" : "no-repeat")
    }
  }

  function E(e, i, t, n, o, r, a, s, l, E, f, d, h) {
    if (!(h instanceof THREE.DataTexture)) {
      h.hasEventListener("update", c) === !1 && (void 0 !== h.image && h.image.width > 0 && p(h), h.addEventListener("update", c));
      var m = he[h.id];
      if (void 0 === m) return R("rgba(0,0,0,1)"), void _.fill();
      R(m);
      var x, y, v, u, S, T, g, w, H = h.offset.x / h.repeat.x,
        M = h.offset.y / h.repeat.y,
        C = h.image.width * h.repeat.x,
        L = h.image.height * h.repeat.y;
      a = (a + H) * C, s = (s + M) * L, l = (l + H) * C, E = (E + M) * L, f = (f + H) * C, d = (d + M) * L, t -= e, n -= i, o -= e, r -= i, l -= a, E -= s, f -= a, d -= s, g = l * d - f * E, 0 !== g && (w = 1 / g, x = (d * t - E * o) * w, y = (d * n - E * r) * w, v = (l * o - f * t) * w, u = (l * r - f * n) * w, S = e - x * a - v * s, T = i - y * a - u * s, _.save(), _.transform(x, y, v, u, S, T), _.fill(), _.restore())
    }
  }

  function f(e, i, t) {
    var n, o = i.x - e.x,
      r = i.y - e.y,
      a = o * o + r * r;
    0 !== a && (n = t / Math.sqrt(a), o *= n, r *= n, i.x += o, i.y += r, e.x -= o, e.y -= r)
  }

  function d(e) {
    te !== e && (_.globalAlpha = e, te = e)
  }

  function h(e) {
    ne !== e && (e === THREE.NormalBlending ? _.globalCompositeOperation = "source-over" : e === THREE.AdditiveBlending ? _.globalCompositeOperation = "lighter" : e === THREE.SubtractiveBlending && (_.globalCompositeOperation = "darker"), ne = e)
  }

  function m(e) {
    ae !== e && (_.lineWidth = e, ae = e)
  }

  function x(e) {
    se !== e && (_.lineCap = e, se = e)
  }

  function y(e) {
    le !== e && (_.lineJoin = e, le = e)
  }

  function v(e) {
    oe !== e && (_.strokeStyle = e, oe = e)
  }

  function R(e) {
    re !== e && (_.fillStyle = e, re = e)
  }

  function u(e) {
    ce.length !== e.length && (_.setLineDash(e), ce = e)
  }
  console.log("THREE.CanvasRenderer", THREE.REVISION);
  var S = THREE.Math.smoothstep;
  e = e || {};
  var T, g, w, H, M, C, L, b, P, B, z, V, j, N, D, W, F, k, O, G, I = this,
    A = new THREE.Projector,
    q = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"),
    U = q.width,
    J = q.height,
    K = Math.floor(U / 2),
    Q = Math.floor(J / 2),
    X = 0,
    Y = 0,
    Z = U,
    $ = J,
    _ = q.getContext("2d", {
      alpha: e.alpha === !0
    }),
    ee = new THREE.Color(0),
    ie = 0,
    te = 1,
    ne = 0,
    oe = null,
    re = null,
    ae = null,
    se = null,
    le = null,
    ce = [],
    pe = (new THREE.RenderableVertex, new THREE.RenderableVertex, new THREE.Color),
    Ee = (new THREE.Color, new THREE.Color, new THREE.Color, new THREE.Color, new THREE.Color),
    fe = new THREE.Color,
    de = new THREE.Color,
    he = {},
    me = new THREE.Box2,
    xe = new THREE.Box2,
    ye = new THREE.Box2,
    ve = new THREE.Color,
    Re = new THREE.Color,
    ue = new THREE.Color,
    Se = new THREE.Vector3,
    Te = new THREE.Vector3,
    ge = new THREE.Vector3,
    we = new THREE.Matrix3;
  void 0 === _.setLineDash && (_.setLineDash = function() {}), this.domElement = q, this.devicePixelRatio = void 0 !== e.devicePixelRatio ? e.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1, this.autoClear = !0, this.sortObjects = !0, this.sortElements = !0, this.info = {
    render: {
      vertices: 0,
      faces: 0
    }
  }, this.supportsVertexTextures = function() {}, this.setFaceCulling = function() {}, this.setSize = function(e, i, t) {
    U = e * this.devicePixelRatio, J = i * this.devicePixelRatio, q.width = U, q.height = J, K = Math.floor(U / 2), Q = Math.floor(J / 2), t !== !1 && (q.style.width = e + "px", q.style.height = i + "px"), me.min.set(-K, -Q), me.max.set(K, Q), xe.min.set(-K, -Q), xe.max.set(K, Q), te = 1, ne = 0, oe = null, re = null, ae = null, se = null, le = null, this.setViewport(0, 0, e, i)
  }, this.setViewport = function(e, i, t, n) {
    X = e * this.devicePixelRatio, Y = i * this.devicePixelRatio, Z = t * this.devicePixelRatio, $ = n * this.devicePixelRatio
  }, this.setScissor = function() {}, this.enableScissorTest = function() {}, this.setClearColor = function(e, i) {
    ee.set(e), ie = void 0 !== i ? i : 1, xe.min.set(-K, -Q), xe.max.set(K, Q)
  }, this.setClearColorHex = function(e, i) {
    console.warn("THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead."), this.setClearColor(e, i)
  }, this.getClearColor = function() {
    return ee
  }, this.getClearAlpha = function() {
    return ie
  }, this.getMaxAnisotropy = function() {
    return 0
  }, this.clear = function() {
    xe.empty() === !1 && (xe.intersect(me), xe.expandByScalar(2), xe.min.x = xe.min.x + K, xe.min.y = -xe.min.y + Q, xe.max.x = xe.max.x + K, xe.max.y = -xe.max.y + Q, 1 > ie && _.clearRect(0 | xe.min.x, 0 | xe.min.y, xe.max.x - xe.min.x | 0, xe.max.y - xe.min.y | 0), ie > 0 && (h(THREE.NormalBlending), d(1), R("rgba(" + Math.floor(255 * ee.r) + "," + Math.floor(255 * ee.g) + "," + Math.floor(255 * ee.b) + "," + ie + ")"), _.fillRect(0 | xe.min.x, 0 | xe.min.y, xe.max.x - xe.min.x | 0, xe.max.y - xe.min.y | 0)), xe.makeEmpty())
  }, this.clearColor = function() {}, this.clearDepth = function() {}, this.clearStencil = function() {}, this.render = function(e, t) {
    if (t instanceof THREE.Camera == !1) return void console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
    this.autoClear === !0 && this.clear(), I.info.render.vertices = 0, I.info.render.faces = 0, _.setTransform(Z / U, 0, 0, -$ / J, X, J - Y), _.translate(K, Q), T = A.projectScene(e, t, this.sortObjects, this.sortElements), g = T.elements, w = T.lights, H = t, we.getNormalMatrix(t.matrixWorldInverse), i();
    for (var a = 0, s = g.length; s > a; a++) {
      var l = g[a],
        c = l.material;
      if (void 0 !== c && 0 !== c.opacity) {
        if (ye.makeEmpty(), l instanceof THREE.RenderableSprite) M = l, M.x *= K, M.y *= Q, n(M, l, c);
        else if (l instanceof THREE.RenderableLine) M = l.v1, C = l.v2, M.positionScreen.x *= K, M.positionScreen.y *= Q, C.positionScreen.x *= K, C.positionScreen.y *= Q, ye.setFromPoints([M.positionScreen, C.positionScreen]), me.isIntersectionBox(ye) === !0 && o(M, C, l, c);
        else if (l instanceof THREE.RenderableFace) {
          if (M = l.v1, C = l.v2, L = l.v3, M.positionScreen.z < -1 || M.positionScreen.z > 1) continue;
          if (C.positionScreen.z < -1 || C.positionScreen.z > 1) continue;
          if (L.positionScreen.z < -1 || L.positionScreen.z > 1) continue;
          M.positionScreen.x *= K, M.positionScreen.y *= Q, C.positionScreen.x *= K, C.positionScreen.y *= Q, L.positionScreen.x *= K, L.positionScreen.y *= Q, c.overdraw > 0 && (f(M.positionScreen, C.positionScreen, c.overdraw), f(C.positionScreen, L.positionScreen, c.overdraw), f(L.positionScreen, M.positionScreen, c.overdraw)), ye.setFromPoints([M.positionScreen, C.positionScreen, L.positionScreen]), me.isIntersectionBox(ye) === !0 && r(M, C, L, 0, 1, 2, l, c)
        }
        xe.union(ye)
      }
    }
    _.setTransform(1, 0, 0, 1, 0, 0)
  }
};


/*!
 * VERSION: 1.15.0
 * DATE: 2014-12-03
 * UPDATES AND DOCS AT: http://www.greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2014, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/

var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
    "use strict";
    _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
        var s = function(t) {
            var e, i = [],
              s = t.length;
            for (e = 0; e !== s; i.push(t[e++]));
            return i
          },
          r = function(t, e, s) {
            i.call(this, t, e, s), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = r.prototype.render
          },
          n = 1e-10,
          a = i._internals,
          o = a.isSelector,
          h = a.isArray,
          l = r.prototype = i.to({}, .1, {}),
          _ = [];
        r.version = "1.15.0", l.constructor = r, l.kill()._gc = !1, r.killTweensOf = r.killDelayedCallsTo = i.killTweensOf, r.getTweensOf = i.getTweensOf, r.lagSmoothing = i.lagSmoothing, r.ticker = i.ticker, r.render = i.render, l.invalidate = function() {
          return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), i.prototype.invalidate.call(this)
        }, l.updateTo = function(t, e) {
          var s, r = this.ratio,
            n = this.vars.immediateRender || t.immediateRender;
          e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
          for (s in t) this.vars[s] = t[s];
          if (this._initted || n)
            if (e) this._initted = !1, n && this.render(0, !0, !0);
            else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
            var a = this._time;
            this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
          } else if (this._time > 0 || n) {
            this._initted = !1, this._init();
            for (var o, h = 1 / (1 - r), l = this._firstPT; l;) o = l.s + l.c, l.c *= h, l.s = o - l.c, l = l._next
          }
          return this
        }, l.render = function(t, e, i) {
          this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
          var s, r, o, h, l, u, p, c, f = this._dirty ? this.totalDuration() : this._totalDuration,
            m = this._time,
            d = this._totalTime,
            g = this._cycle,
            v = this._duration,
            y = this._rawPrevTime;
          if (t >= f ? (this._totalTime = f, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = v, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (s = !0, r = "onComplete"), 0 === v && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (0 === t || 0 > y || y === n) && y !== t && (i = !0, y > n && (r = "onReverseComplete")), this._rawPrevTime = c = !e || t || y === t ? t : n)) : 1e-7 > t ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== d || 0 === v && y > 0 && y !== n) && (r = "onReverseComplete", s = this._reversed), 0 > t && (this._active = !1, 0 === v && (this._initted || !this.vars.lazy || i) && (y >= 0 && (i = !0), this._rawPrevTime = c = !e || t || y === t ? t : n)), this._initted || (i = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (h = v + this._repeatDelay, this._cycle = this._totalTime / h >> 0, 0 !== this._cycle && this._cycle === this._totalTime / h && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 0 !== (1 & this._cycle) && (this._time = v - this._time), this._time > v ? this._time = v : 0 > this._time && (this._time = 0)), this._easeType ? (l = this._time / v, u = this._easeType, p = this._easePower, (1 === u || 3 === u && l >= .5) && (l = 1 - l), 3 === u && (l *= 2), 1 === p ? l *= l : 2 === p ? l *= l * l : 3 === p ? l *= l * l * l : 4 === p && (l *= l * l * l * l), this.ratio = 1 === u ? 1 - l : 2 === u ? l : .5 > this._time / v ? l / 2 : 1 - l / 2) : this.ratio = this._ease.getRatio(this._time / v)), m === this._time && !i && g === this._cycle) return d !== this._totalTime && this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _)), void 0;
          if (!this._initted) {
            if (this._init(), !this._initted || this._gc) return;
            if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = m, this._totalTime = d, this._rawPrevTime = y, this._cycle = g, a.lazyTweens.push(this), this._lazy = [t, e], void 0;
            this._time && !s ? this.ratio = this._ease.getRatio(this._time / v) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
          }
          for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== m && t >= 0 && (this._active = !0), 0 === d && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === v) && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
          this._onUpdate && (0 > t && this._startAt && this._startTime && this._startAt.render(t, e, i), e || (this._totalTime !== d || s) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _)), this._cycle !== g && (e || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _)), r && (!this._gc || i) && (0 > t && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this.vars[r].apply(this.vars[r + "Scope"] || this, this.vars[r + "Params"] || _), 0 === v && this._rawPrevTime === n && c !== n && (this._rawPrevTime = 0))
        }, r.to = function(t, e, i) {
          return new r(t, e, i)
        }, r.from = function(t, e, i) {
          return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new r(t, e, i)
        }, r.fromTo = function(t, e, i, s) {
          return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new r(t, e, s)
        }, r.staggerTo = r.allTo = function(t, e, n, a, l, u, p) {
          a = a || 0;
          var c, f, m, d, g = n.delay || 0,
            v = [],
            y = function() {
              n.onComplete && n.onComplete.apply(n.onCompleteScope || this, arguments), l.apply(p || this, u || _)
            };
          for (h(t) || ("string" == typeof t && (t = i.selector(t) || t), o(t) && (t = s(t))), t = t || [], 0 > a && (t = s(t), t.reverse(), a *= -1), c = t.length - 1, m = 0; c >= m; m++) {
            f = {};
            for (d in n) f[d] = n[d];
            f.delay = g, m === c && l && (f.onComplete = y), v[m] = new r(t[m], e, f), g += a
          }
          return v
        }, r.staggerFrom = r.allFrom = function(t, e, i, s, n, a, o) {
          return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, r.staggerTo(t, e, i, s, n, a, o)
        }, r.staggerFromTo = r.allFromTo = function(t, e, i, s, n, a, o, h) {
          return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, r.staggerTo(t, e, s, n, a, o, h)
        }, r.delayedCall = function(t, e, i, s, n) {
          return new r(e, 0, {
            delay: t,
            onComplete: e,
            onCompleteParams: i,
            onCompleteScope: s,
            onReverseComplete: e,
            onReverseCompleteParams: i,
            onReverseCompleteScope: s,
            immediateRender: !1,
            useFrames: n,
            overwrite: 0
          })
        }, r.set = function(t, e) {
          return new r(t, 0, e)
        }, r.isTweening = function(t) {
          return i.getTweensOf(t, !0).length > 0
        };
        var u = function(t, e) {
            for (var s = [], r = 0, n = t._first; n;) n instanceof i ? s[r++] = n : (e && (s[r++] = n), s = s.concat(u(n, e)), r = s.length), n = n._next;
            return s
          },
          p = r.getAllTweens = function(e) {
            return u(t._rootTimeline, e).concat(u(t._rootFramesTimeline, e))
          };
        r.killAll = function(t, i, s, r) {
          null == i && (i = !0), null == s && (s = !0);
          var n, a, o, h = p(0 != r),
            l = h.length,
            _ = i && s && r;
          for (o = 0; l > o; o++) a = h[o], (_ || a instanceof e || (n = a.target === a.vars.onComplete) && s || i && !n) && (t ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
        }, r.killChildTweensOf = function(t, e) {
          if (null != t) {
            var n, l, _, u, p, c = a.tweenLookup;
            if ("string" == typeof t && (t = i.selector(t) || t), o(t) && (t = s(t)), h(t))
              for (u = t.length; --u > -1;) r.killChildTweensOf(t[u], e);
            else {
              n = [];
              for (_ in c)
                for (l = c[_].target.parentNode; l;) l === t && (n = n.concat(c[_].tweens)), l = l.parentNode;
              for (p = n.length, u = 0; p > u; u++) e && n[u].totalTime(n[u].totalDuration()), n[u]._enabled(!1, !1)
            }
          }
        };
        var c = function(t, i, s, r) {
          i = i !== !1, s = s !== !1, r = r !== !1;
          for (var n, a, o = p(r), h = i && s && r, l = o.length; --l > -1;) a = o[l], (h || a instanceof e || (n = a.target === a.vars.onComplete) && s || i && !n) && a.paused(t)
        };
        return r.pauseAll = function(t, e, i) {
          c(!0, t, e, i)
        }, r.resumeAll = function(t, e, i) {
          c(!1, t, e, i)
        }, r.globalTimeScale = function(e) {
          var s = t._rootTimeline,
            r = i.ticker.time;
          return arguments.length ? (e = e || n, s._startTime = r - (r - s._startTime) * s._timeScale / e, s = t._rootFramesTimeline, r = i.ticker.frame, s._startTime = r - (r - s._startTime) * s._timeScale / e, s._timeScale = t._rootTimeline._timeScale = e, e) : s._timeScale
        }, l.progress = function(t) {
          return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
        }, l.totalProgress = function(t) {
          return arguments.length ? this.totalTime(this.totalDuration() * t, !1) : this._totalTime / this.totalDuration()
        }, l.time = function(t, e) {
          return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
        }, l.duration = function(e) {
          return arguments.length ? t.prototype.duration.call(this, e) : this._duration
        }, l.totalDuration = function(t) {
          return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
        }, l.repeat = function(t) {
          return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
        }, l.repeatDelay = function(t) {
          return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
        }, l.yoyo = function(t) {
          return arguments.length ? (this._yoyo = t, this) : this._yoyo
        }, r
      }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) {
        var s = function(t) {
            e.call(this, t), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
            var i, s, r = this.vars;
            for (s in r) i = r[s], o(i) && -1 !== i.join("").indexOf("{self}") && (r[s] = this._swapSelfInParams(i));
            o(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
          },
          r = 1e-10,
          n = i._internals,
          a = n.isSelector,
          o = n.isArray,
          h = n.lazyTweens,
          l = n.lazyRender,
          _ = [],
          u = _gsScope._gsDefine.globals,
          p = function(t) {
            var e, i = {};
            for (e in t) i[e] = t[e];
            return i
          },
          c = function(t, e, i, s) {
            var r = t._timeline,
              n = r._totalTime;
            !e && this._forcingPlayhead || r._rawPrevTime === t._startTime || (r.pause(t._startTime), e && e.apply(s || r, i || _), this._forcingPlayhead && r.seek(n))
          },
          f = function(t) {
            var e, i = [],
              s = t.length;
            for (e = 0; e !== s; i.push(t[e++]));
            return i
          },
          m = s.prototype = new e;
        return s.version = "1.15.0", m.constructor = s, m.kill()._gc = m._forcingPlayhead = !1, m.to = function(t, e, s, r) {
          var n = s.repeat && u.TweenMax || i;
          return e ? this.add(new n(t, e, s), r) : this.set(t, s, r)
        }, m.from = function(t, e, s, r) {
          return this.add((s.repeat && u.TweenMax || i).from(t, e, s), r)
        }, m.fromTo = function(t, e, s, r, n) {
          var a = r.repeat && u.TweenMax || i;
          return e ? this.add(a.fromTo(t, e, s, r), n) : this.set(t, r, n)
        }, m.staggerTo = function(t, e, r, n, o, h, l, _) {
          var u, c = new s({
            onComplete: h,
            onCompleteParams: l,
            onCompleteScope: _,
            smoothChildTiming: this.smoothChildTiming
          });
          for ("string" == typeof t && (t = i.selector(t) || t), t = t || [], a(t) && (t = f(t)), n = n || 0, 0 > n && (t = f(t), t.reverse(), n *= -1), u = 0; t.length > u; u++) r.startAt && (r.startAt = p(r.startAt)), c.to(t[u], e, p(r), u * n);
          return this.add(c, o)
        }, m.staggerFrom = function(t, e, i, s, r, n, a, o) {
          return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, s, r, n, a, o)
        }, m.staggerFromTo = function(t, e, i, s, r, n, a, o, h) {
          return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, s, r, n, a, o, h)
        }, m.call = function(t, e, s, r) {
          return this.add(i.delayedCall(0, t, e, s), r)
        }, m.set = function(t, e, s) {
          return s = this._parseTimeOrLabel(s, 0, !0), null == e.immediateRender && (e.immediateRender = s === this._time && !this._paused), this.add(new i(t, 0, e), s)
        }, s.exportRoot = function(t, e) {
          t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming = !0);
          var r, n, a = new s(t),
            o = a._timeline;
          for (null == e && (e = !0), o._remove(a, !0), a._startTime = 0, a._rawPrevTime = a._time = a._totalTime = o._time, r = o._first; r;) n = r._next, e && r instanceof i && r.target === r.vars.onComplete || a.add(r, r._startTime - r._delay), r = n;
          return o.add(a, 0), a
        }, m.add = function(r, n, a, h) {
          var l, _, u, p, c, f;
          if ("number" != typeof n && (n = this._parseTimeOrLabel(n, 0, !0, r)), !(r instanceof t)) {
            if (r instanceof Array || r && r.push && o(r)) {
              for (a = a || "normal", h = h || 0, l = n, _ = r.length, u = 0; _ > u; u++) o(p = r[u]) && (p = new s({
                tweens: p
              })), this.add(p, l), "string" != typeof p && "function" != typeof p && ("sequence" === a ? l = p._startTime + p.totalDuration() / p._timeScale : "start" === a && (p._startTime -= p.delay())), l += h;
              return this._uncache(!0)
            }
            if ("string" == typeof r) return this.addLabel(r, n);
            if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
            r = i.delayedCall(0, r)
          }
          if (e.prototype.add.call(this, r, n), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
            for (c = this, f = c.rawTime() > r._startTime; c._timeline;) f && c._timeline.smoothChildTiming ? c.totalTime(c._totalTime, !0) : c._gc && c._enabled(!0, !1), c = c._timeline;
          return this
        }, m.remove = function(e) {
          if (e instanceof t) return this._remove(e, !1);
          if (e instanceof Array || e && e.push && o(e)) {
            for (var i = e.length; --i > -1;) this.remove(e[i]);
            return this
          }
          return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
        }, m._remove = function(t, i) {
          e.prototype._remove.call(this, t, i);
          var s = this._last;
          return s ? this._time > s._startTime + s._totalDuration / s._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
        }, m.append = function(t, e) {
          return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
        }, m.insert = m.insertMultiple = function(t, e, i, s) {
          return this.add(t, e || 0, i, s)
        }, m.appendMultiple = function(t, e, i, s) {
          return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, s)
        }, m.addLabel = function(t, e) {
          return this._labels[t] = this._parseTimeOrLabel(e), this
        }, m.addPause = function(t, e, s, r) {
          var n = i.delayedCall(0, c, ["{self}", e, s, r], this);
          return n.data = "isPause", this.add(n, t)
        }, m.removeLabel = function(t) {
          return delete this._labels[t], this
        }, m.getLabelTime = function(t) {
          return null != this._labels[t] ? this._labels[t] : -1
        }, m._parseTimeOrLabel = function(e, i, s, r) {
          var n;
          if (r instanceof t && r.timeline === this) this.remove(r);
          else if (r && (r instanceof Array || r.push && o(r)))
            for (n = r.length; --n > -1;) r[n] instanceof t && r[n].timeline === this && this.remove(r[n]);
          if ("string" == typeof i) return this._parseTimeOrLabel(i, s && "number" == typeof e && null == this._labels[i] ? e - this.duration() : 0, s);
          if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = this.duration());
          else {
            if (n = e.indexOf("="), -1 === n) return null == this._labels[e] ? s ? this._labels[e] = this.duration() + i : i : this._labels[e] + i;
            i = parseInt(e.charAt(n - 1) + "1", 10) * Number(e.substr(n + 1)), e = n > 1 ? this._parseTimeOrLabel(e.substr(0, n - 1), 0, s) : this.duration()
          }
          return Number(e) + i
        }, m.seek = function(t, e) {
          return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), e !== !1)
        }, m.stop = function() {
          return this.paused(!0)
        }, m.gotoAndPlay = function(t, e) {
          return this.play(t, e)
        }, m.gotoAndStop = function(t, e) {
          return this.pause(t, e)
        }, m.render = function(t, e, i) {
          this._gc && this._enabled(!0, !1);
          var s, n, a, o, u, p = this._dirty ? this.totalDuration() : this._totalDuration,
            c = this._time,
            f = this._startTime,
            m = this._timeScale,
            d = this._paused;
          if (t >= p ? (this._totalTime = this._time = p, this._reversed || this._hasPausedChild() || (n = !0, o = "onComplete", 0 === this._duration && (0 === t || 0 > this._rawPrevTime || this._rawPrevTime === r) && this._rawPrevTime !== t && this._first && (u = !0, this._rawPrevTime > r && (o = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, t = p + 1e-4) : 1e-7 > t ? (this._totalTime = this._time = 0, (0 !== c || 0 === this._duration && this._rawPrevTime !== r && (this._rawPrevTime > 0 || 0 > t && this._rawPrevTime >= 0)) && (o = "onReverseComplete", n = this._reversed), 0 > t ? (this._active = !1, this._rawPrevTime >= 0 && this._first && (u = !0), this._rawPrevTime = t) : (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, t = 0, this._initted || (u = !0))) : this._totalTime = this._time = this._rawPrevTime = t, this._time !== c && this._first || i || u) {
            if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== c && t > 0 && (this._active = !0), 0 === c && this.vars.onStart && 0 !== this._time && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _)), this._time >= c)
              for (s = this._first; s && (a = s._next, !this._paused || d);)(s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a;
            else
              for (s = this._last; s && (a = s._prev, !this._paused || d);)(s._active || c >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a;
            this._onUpdate && (e || (h.length && l(), this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _))), o && (this._gc || (f === this._startTime || m !== this._timeScale) && (0 === this._time || p >= this.totalDuration()) && (n && (h.length && l(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[o] && this.vars[o].apply(this.vars[o + "Scope"] || this, this.vars[o + "Params"] || _)))
          }
        }, m._hasPausedChild = function() {
          for (var t = this._first; t;) {
            if (t._paused || t instanceof s && t._hasPausedChild()) return !0;
            t = t._next
          }
          return !1
        }, m.getChildren = function(t, e, s, r) {
          r = r || -9999999999;
          for (var n = [], a = this._first, o = 0; a;) r > a._startTime || (a instanceof i ? e !== !1 && (n[o++] = a) : (s !== !1 && (n[o++] = a), t !== !1 && (n = n.concat(a.getChildren(!0, e, s)), o = n.length))), a = a._next;
          return n
        }, m.getTweensOf = function(t, e) {
          var s, r, n = this._gc,
            a = [],
            o = 0;
          for (n && this._enabled(!0, !0), s = i.getTweensOf(t), r = s.length; --r > -1;)(s[r].timeline === this || e && this._contains(s[r])) && (a[o++] = s[r]);
          return n && this._enabled(!1, !0), a
        }, m.recent = function() {
          return this._recent
        }, m._contains = function(t) {
          for (var e = t.timeline; e;) {
            if (e === this) return !0;
            e = e.timeline
          }
          return !1
        }, m.shiftChildren = function(t, e, i) {
          i = i || 0;
          for (var s, r = this._first, n = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
          if (e)
            for (s in n) n[s] >= i && (n[s] += t);
          return this._uncache(!0)
        }, m._kill = function(t, e) {
          if (!t && !e) return this._enabled(!1, !1);
          for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), s = i.length, r = !1; --s > -1;) i[s]._kill(t, e) && (r = !0);
          return r
        }, m.clear = function(t) {
          var e = this.getChildren(!1, !0, !0),
            i = e.length;
          for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
          return t !== !1 && (this._labels = {}), this._uncache(!0)
        }, m.invalidate = function() {
          for (var e = this._first; e;) e.invalidate(), e = e._next;
          return t.prototype.invalidate.call(this)
        }, m._enabled = function(t, i) {
          if (t === this._gc)
            for (var s = this._first; s;) s._enabled(t, !0), s = s._next;
          return e.prototype._enabled.call(this, t, i)
        }, m.totalTime = function() {
          this._forcingPlayhead = !0;
          var e = t.prototype.totalTime.apply(this, arguments);
          return this._forcingPlayhead = !1, e
        }, m.duration = function(t) {
          return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
        }, m.totalDuration = function(t) {
          if (!arguments.length) {
            if (this._dirty) {
              for (var e, i, s = 0, r = this._last, n = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > n && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : n = r._startTime, 0 > r._startTime && !r._paused && (s -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale), this.shiftChildren(-r._startTime, !1, -9999999999), n = 0), i = r._startTime + r._totalDuration / r._timeScale, i > s && (s = i), r = e;
              this._duration = this._totalDuration = s, this._dirty = !1
            }
            return this._totalDuration
          }
          return 0 !== this.totalDuration() && 0 !== t && this.timeScale(this._totalDuration / t), this
        }, m.usesFrames = function() {
          for (var e = this._timeline; e._timeline;) e = e._timeline;
          return e === t._rootFramesTimeline
        }, m.rawTime = function() {
          return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
        }, s
      }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, e, i) {
        var s = function(e) {
            t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0
          },
          r = 1e-10,
          n = [],
          a = e._internals,
          o = a.lazyTweens,
          h = a.lazyRender,
          l = new i(null, null, 1, 0),
          _ = s.prototype = new t;
        return _.constructor = s, _.kill()._gc = !1, s.version = "1.15.0", _.invalidate = function() {
          return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this)
        }, _.addCallback = function(t, i, s, r) {
          return this.add(e.delayedCall(0, t, s, r), i)
        }, _.removeCallback = function(t, e) {
          if (t)
            if (null == e) this._kill(null, t);
            else
              for (var i = this.getTweensOf(t, !1), s = i.length, r = this._parseTimeOrLabel(e); --s > -1;) i[s]._startTime === r && i[s]._enabled(!1, !1);
          return this
        }, _.tweenTo = function(t, i) {
          i = i || {};
          var s, r, a, o = {
            ease: l,
            overwrite: i.delay ? 2 : 1,
            useFrames: this.usesFrames(),
            immediateRender: !1
          };
          for (r in i) o[r] = i[r];
          return o.time = this._parseTimeOrLabel(t), s = Math.abs(Number(o.time) - this._time) / this._timeScale || .001, a = new e(this, s, o), o.onStart = function() {
            a.target.paused(!0), a.vars.time !== a.target.time() && s === a.duration() && a.duration(Math.abs(a.vars.time - a.target.time()) / a.target._timeScale), i.onStart && i.onStart.apply(i.onStartScope || a, i.onStartParams || n)
          }, a
        }, _.tweenFromTo = function(t, e, i) {
          i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
            onComplete: this.seek,
            onCompleteParams: [t],
            onCompleteScope: this
          }, i.immediateRender = i.immediateRender !== !1;
          var s = this.tweenTo(e, i);
          return s.duration(Math.abs(s.vars.time - t) / this._timeScale || .001)
        }, _.render = function(t, e, i) {
          this._gc && this._enabled(!0, !1);
          var s, a, l, _, u, p, c = this._dirty ? this.totalDuration() : this._totalDuration,
            f = this._duration,
            m = this._time,
            d = this._totalTime,
            g = this._startTime,
            v = this._timeScale,
            y = this._rawPrevTime,
            T = this._paused,
            w = this._cycle;
          if (t >= c ? (this._locked || (this._totalTime = c, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (a = !0, _ = "onComplete", 0 === this._duration && (0 === t || 0 > y || y === r) && y !== t && this._first && (u = !0, y > r && (_ = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : r, this._yoyo && 0 !== (1 & this._cycle) ? this._time = t = 0 : (this._time = f, t = f + 1e-4)) : 1e-7 > t ? (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== m || 0 === f && y !== r && (y > 0 || 0 > t && y >= 0) && !this._locked) && (_ = "onReverseComplete", a = this._reversed), 0 > t ? (this._active = !1, y >= 0 && this._first && (u = !0), this._rawPrevTime = t) : (this._rawPrevTime = f || !e || t || this._rawPrevTime === t ? t : r, t = 0, this._initted || (u = !0))) : (0 === f && 0 > y && (u = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (p = f + this._repeatDelay, this._cycle = this._totalTime / p >> 0, 0 !== this._cycle && this._cycle === this._totalTime / p && this._cycle--, this._time = this._totalTime - this._cycle * p, this._yoyo && 0 !== (1 & this._cycle) && (this._time = f - this._time), this._time > f ? (this._time = f, t = f + 1e-4) : 0 > this._time ? this._time = t = 0 : t = this._time))), this._cycle !== w && !this._locked) {
            var x = this._yoyo && 0 !== (1 & w),
              b = x === (this._yoyo && 0 !== (1 & this._cycle)),
              P = this._totalTime,
              S = this._cycle,
              k = this._rawPrevTime,
              R = this._time;
            if (this._totalTime = w * f, w > this._cycle ? x = !x : this._totalTime += f, this._time = m, this._rawPrevTime = 0 === f ? y - 1e-4 : y, this._cycle = w, this._locked = !0, m = x ? 0 : f, this.render(m, e, 0 === f), e || this._gc || this.vars.onRepeat && this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || n), b && (m = x ? f + 1e-4 : -1e-4, this.render(m, !0, !1)), this._locked = !1, this._paused && !T) return;
            this._time = R, this._totalTime = P, this._cycle = S, this._rawPrevTime = k
          }
          if (!(this._time !== m && this._first || i || u)) return d !== this._totalTime && this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || n)), void 0;
          if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== d && t > 0 && (this._active = !0), 0 === d && this.vars.onStart && 0 !== this._totalTime && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || n)), this._time >= m)
            for (s = this._first; s && (l = s._next, !this._paused || T);)(s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = l;
          else
            for (s = this._last; s && (l = s._prev, !this._paused || T);)(s._active || m >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = l;
          this._onUpdate && (e || (o.length && h(), this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || n))), _ && (this._locked || this._gc || (g === this._startTime || v !== this._timeScale) && (0 === this._time || c >= this.totalDuration()) && (a && (o.length && h(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[_] && this.vars[_].apply(this.vars[_ + "Scope"] || this, this.vars[_ + "Params"] || n)))
        }, _.getActive = function(t, e, i) {
          null == t && (t = !0), null == e && (e = !0), null == i && (i = !1);
          var s, r, n = [],
            a = this.getChildren(t, e, i),
            o = 0,
            h = a.length;
          for (s = 0; h > s; s++) r = a[s], r.isActive() && (n[o++] = r);
          return n
        }, _.getLabelAfter = function(t) {
          t || 0 !== t && (t = this._time);
          var e, i = this.getLabelsArray(),
            s = i.length;
          for (e = 0; s > e; e++)
            if (i[e].time > t) return i[e].name;
          return null
        }, _.getLabelBefore = function(t) {
          null == t && (t = this._time);
          for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
            if (t > e[i].time) return e[i].name;
          return null
        }, _.getLabelsArray = function() {
          var t, e = [],
            i = 0;
          for (t in this._labels) e[i++] = {
            time: this._labels[t],
            name: t
          };
          return e.sort(function(t, e) {
            return t.time - e.time
          }), e
        }, _.progress = function(t, e) {
          return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
        }, _.totalProgress = function(t, e) {
          return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
        }, _.totalDuration = function(e) {
          return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
        }, _.time = function(t, e) {
          return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time
        }, _.repeat = function(t) {
          return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
        }, _.repeatDelay = function(t) {
          return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
        }, _.yoyo = function(t) {
          return arguments.length ? (this._yoyo = t, this) : this._yoyo
        }, _.currentLabel = function(t) {
          return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8)
        }, s
      }, !0),
      function() {
        var t = 180 / Math.PI,
          e = [],
          i = [],
          s = [],
          r = {},
          n = _gsScope._gsDefine.globals,
          a = function(t, e, i, s) {
            this.a = t, this.b = e, this.c = i, this.d = s, this.da = s - t, this.ca = i - t, this.ba = e - t
          },
          o = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
          h = function(t, e, i, s) {
            var r = {
                a: t
              },
              n = {},
              a = {},
              o = {
                c: s
              },
              h = (t + e) / 2,
              l = (e + i) / 2,
              _ = (i + s) / 2,
              u = (h + l) / 2,
              p = (l + _) / 2,
              c = (p - u) / 8;
            return r.b = h + (t - h) / 4, n.b = u + c, r.c = n.a = (r.b + n.b) / 2, n.c = a.a = (u + p) / 2, a.b = p - c, o.b = _ + (s - _) / 4, a.c = o.a = (a.b + o.b) / 2, [r, n, a, o]
          },
          l = function(t, r, n, a, o) {
            var l, _, u, p, c, f, m, d, g, v, y, T, w, x = t.length - 1,
              b = 0,
              P = t[0].a;
            for (l = 0; x > l; l++) c = t[b], _ = c.a, u = c.d, p = t[b + 1].d, o ? (y = e[l], T = i[l], w = .25 * (T + y) * r / (a ? .5 : s[l] || .5), f = u - (u - _) * (a ? .5 * r : 0 !== y ? w / y : 0), m = u + (p - u) * (a ? .5 * r : 0 !== T ? w / T : 0), d = u - (f + ((m - f) * (3 * y / (y + T) + .5) / 4 || 0))) : (f = u - .5 * (u - _) * r, m = u + .5 * (p - u) * r, d = u - (f + m) / 2), f += d, m += d, c.c = g = f, c.b = 0 !== l ? P : P = c.a + .6 * (c.c - c.a), c.da = u - _, c.ca = g - _, c.ba = P - _, n ? (v = h(_, P, g, u), t.splice(b, 1, v[0], v[1], v[2], v[3]), b += 4) : b++, P = m;
            c = t[b], c.b = P, c.c = P + .4 * (c.d - P), c.da = c.d - c.a, c.ca = c.c - c.a, c.ba = P - c.a, n && (v = h(c.a, P, c.c, c.d), t.splice(b, 1, v[0], v[1], v[2], v[3]))
          },
          _ = function(t, s, r, n) {
            var o, h, l, _, u, p, c = [];
            if (n)
              for (t = [n].concat(t), h = t.length; --h > -1;) "string" == typeof(p = t[h][s]) && "=" === p.charAt(1) && (t[h][s] = n[s] + Number(p.charAt(0) + p.substr(2)));
            if (o = t.length - 2, 0 > o) return c[0] = new a(t[0][s], 0, 0, t[-1 > o ? 0 : 1][s]), c;
            for (h = 0; o > h; h++) l = t[h][s], _ = t[h + 1][s], c[h] = new a(l, 0, 0, _), r && (u = t[h + 2][s], e[h] = (e[h] || 0) + (_ - l) * (_ - l), i[h] = (i[h] || 0) + (u - _) * (u - _));
            return c[h] = new a(t[h][s], 0, 0, t[h + 1][s]), c
          },
          u = function(t, n, a, h, u, p) {
            var c, f, m, d, g, v, y, T, w = {},
              x = [],
              b = p || t[0];
            u = "string" == typeof u ? "," + u + "," : o, null == n && (n = 1);
            for (f in t[0]) x.push(f);
            if (t.length > 1) {
              for (T = t[t.length - 1], y = !0, c = x.length; --c > -1;)
                if (f = x[c], Math.abs(b[f] - T[f]) > .05) {
                  y = !1;
                  break
                }
              y && (t = t.concat(), p && t.unshift(p), t.push(t[1]), p = t[t.length - 3])
            }
            for (e.length = i.length = s.length = 0, c = x.length; --c > -1;) f = x[c], r[f] = -1 !== u.indexOf("," + f + ","), w[f] = _(t, f, r[f], p);
            for (c = e.length; --c > -1;) e[c] = Math.sqrt(e[c]), i[c] = Math.sqrt(i[c]);
            if (!h) {
              for (c = x.length; --c > -1;)
                if (r[f])
                  for (m = w[x[c]], v = m.length - 1, d = 0; v > d; d++) g = m[d + 1].da / i[d] + m[d].da / e[d], s[d] = (s[d] || 0) + g * g;
              for (c = s.length; --c > -1;) s[c] = Math.sqrt(s[c])
            }
            for (c = x.length, d = a ? 4 : 1; --c > -1;) f = x[c], m = w[f], l(m, n, a, h, r[f]), y && (m.splice(0, d), m.splice(m.length - d, d));
            return w
          },
          p = function(t, e, i) {
            e = e || "soft";
            var s, r, n, o, h, l, _, u, p, c, f, m = {},
              d = "cubic" === e ? 3 : 2,
              g = "soft" === e,
              v = [];
            if (g && i && (t = [i].concat(t)), null == t || d + 1 > t.length) throw "invalid Bezier data";
            for (p in t[0]) v.push(p);
            for (l = v.length; --l > -1;) {
              for (p = v[l], m[p] = h = [], c = 0, u = t.length, _ = 0; u > _; _++) s = null == i ? t[_][p] : "string" == typeof(f = t[_][p]) && "=" === f.charAt(1) ? i[p] + Number(f.charAt(0) + f.substr(2)) : Number(f), g && _ > 1 && u - 1 > _ && (h[c++] = (s + h[c - 2]) / 2), h[c++] = s;
              for (u = c - d + 1, c = 0, _ = 0; u > _; _ += d) s = h[_], r = h[_ + 1], n = h[_ + 2], o = 2 === d ? 0 : h[_ + 3], h[c++] = f = 3 === d ? new a(s, r, n, o) : new a(s, (2 * r + s) / 3, (2 * r + n) / 3, n);
              h.length = c
            }
            return m
          },
          c = function(t, e, i) {
            for (var s, r, n, a, o, h, l, _, u, p, c, f = 1 / i, m = t.length; --m > -1;)
              for (p = t[m], n = p.a, a = p.d - n, o = p.c - n, h = p.b - n, s = r = 0, _ = 1; i >= _; _++) l = f * _, u = 1 - l, s = r - (r = (l * l * a + 3 * u * (l * o + u * h)) * l), c = m * i + _ - 1, e[c] = (e[c] || 0) + s * s
          },
          f = function(t, e) {
            e = e >> 0 || 6;
            var i, s, r, n, a = [],
              o = [],
              h = 0,
              l = 0,
              _ = e - 1,
              u = [],
              p = [];
            for (i in t) c(t[i], a, e);
            for (r = a.length, s = 0; r > s; s++) h += Math.sqrt(a[s]), n = s % e, p[n] = h, n === _ && (l += h, n = s / e >> 0, u[n] = p, o[n] = l, h = 0, p = []);
            return {
              length: l,
              lengths: o,
              segments: u
            }
          },
          m = _gsScope._gsDefine.plugin({
            propName: "bezier",
            priority: -1,
            version: "1.3.4",
            API: 2,
            global: !0,
            init: function(t, e, i) {
              this._target = t, e instanceof Array && (e = {
                values: e
              }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
              var s, r, n, a, o, h = e.values || [],
                l = {},
                _ = h[0],
                c = e.autoRotate || i.vars.orientToBezier;
              this._autoRotate = c ? c instanceof Array ? c : [
                ["x", "y", "rotation", c === !0 ? 0 : Number(c) || 0]
              ] : null;
              for (s in _) this._props.push(s);
              for (n = this._props.length; --n > -1;) s = this._props[n], this._overwriteProps.push(s), r = this._func[s] = "function" == typeof t[s], l[s] = r ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)]() : parseFloat(t[s]), o || l[s] !== h[0][s] && (o = l);
              if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? u(h, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, o) : p(h, e.type, l), this._segCount = this._beziers[s].length, this._timeRes) {
                var m = f(this._beziers, this._timeRes);
                this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
              }
              if (c = this._autoRotate)
                for (this._initialRotations = [], c[0] instanceof Array || (this._autoRotate = c = [c]), n = c.length; --n > -1;) {
                  for (a = 0; 3 > a; a++) s = c[n][a], this._func[s] = "function" == typeof t[s] ? t[s.indexOf("set") || "function" != typeof t["get" + s.substr(3)] ? s : "get" + s.substr(3)] : !1;
                  s = c[n][2], this._initialRotations[n] = this._func[s] ? this._func[s].call(this._target) : this._target[s]
                }
              return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
            },
            set: function(e) {
              var i, s, r, n, a, o, h, l, _, u, p = this._segCount,
                c = this._func,
                f = this._target,
                m = e !== this._startRatio;
              if (this._timeRes) {
                if (_ = this._lengths, u = this._curSeg, e *= this._length, r = this._li, e > this._l2 && p - 1 > r) {
                  for (l = p - 1; l > r && e >= (this._l2 = _[++r]););
                  this._l1 = _[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0]
                } else if (this._l1 > e && r > 0) {
                  for (; r > 0 && (this._l1 = _[--r]) >= e;);
                  0 === r && this._l1 > e ? this._l1 = 0 : r++, this._l2 = _[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
                }
                if (i = r, e -= this._l1, r = this._si, e > this._s2 && u.length - 1 > r) {
                  for (l = u.length - 1; l > r && e >= (this._s2 = u[++r]););
                  this._s1 = u[r - 1], this._si = r
                } else if (this._s1 > e && r > 0) {
                  for (; r > 0 && (this._s1 = u[--r]) >= e;);
                  0 === r && this._s1 > e ? this._s1 = 0 : r++, this._s2 = u[r], this._si = r
                }
                o = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec
              } else i = 0 > e ? 0 : e >= 1 ? p - 1 : p * e >> 0, o = (e - i * (1 / p)) * p;
              for (s = 1 - o, r = this._props.length; --r > -1;) n = this._props[r], a = this._beziers[n][i], h = (o * o * a.da + 3 * s * (o * a.ca + s * a.ba)) * o + a.a, this._round[n] && (h = Math.round(h)), c[n] ? f[n](h) : f[n] = h;
              if (this._autoRotate) {
                var d, g, v, y, T, w, x, b = this._autoRotate;
                for (r = b.length; --r > -1;) n = b[r][2], w = b[r][3] || 0, x = b[r][4] === !0 ? 1 : t, a = this._beziers[b[r][0]], d = this._beziers[b[r][1]], a && d && (a = a[i], d = d[i], g = a.a + (a.b - a.a) * o, y = a.b + (a.c - a.b) * o, g += (y - g) * o, y += (a.c + (a.d - a.c) * o - y) * o, v = d.a + (d.b - d.a) * o, T = d.b + (d.c - d.b) * o, v += (T - v) * o, T += (d.c + (d.d - d.c) * o - T) * o, h = m ? Math.atan2(T - v, y - g) * x + w : this._initialRotations[r], c[n] ? f[n](h) : f[n] = h)
              }
            }
          }),
          d = m.prototype;
        m.bezierThrough = u, m.cubicToQuadratic = h, m._autoCSS = !0, m.quadraticToCubic = function(t, e, i) {
          return new a(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
        }, m._cssRegister = function() {
          var t = n.CSSPlugin;
          if (t) {
            var e = t._internals,
              i = e._parseToProxy,
              s = e._setPluginRatio,
              r = e.CSSPropTween;
            e._registerComplexSpecialProp("bezier", {
              parser: function(t, e, n, a, o, h) {
                e instanceof Array && (e = {
                  values: e
                }), h = new m;
                var l, _, u, p = e.values,
                  c = p.length - 1,
                  f = [],
                  d = {};
                if (0 > c) return o;
                for (l = 0; c >= l; l++) u = i(t, p[l], a, o, h, c !== l), f[l] = u.end;
                for (_ in e) d[_] = e[_];
                return d.values = f, o = new r(t, "bezier", 0, 0, u.pt, 2), o.data = u, o.plugin = h, o.setRatio = s, 0 === d.autoRotate && (d.autoRotate = !0), !d.autoRotate || d.autoRotate instanceof Array || (l = d.autoRotate === !0 ? 0 : Number(d.autoRotate), d.autoRotate = null != u.end.left ? [
                  ["left", "top", "rotation", l, !1]
                ] : null != u.end.x ? [
                  ["x", "y", "rotation", l, !1]
                ] : !1), d.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform), h._onInitTween(u.proxy, d, a._tween), o
              }
            })
          }
        }, d._roundProps = function(t, e) {
          for (var i = this._overwriteProps, s = i.length; --s > -1;)(t[i[s]] || t.bezier || t.bezierThrough) && (this._round[i[s]] = e)
        }, d._kill = function(t) {
          var e, i, s = this._props;
          for (e in this._beziers)
            if (e in t)
              for (delete this._beziers[e], delete this._func[e], i = s.length; --i > -1;) s[i] === e && s.splice(i, 1);
          return this._super._kill.call(this, t)
        }
      }(), _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(t, e) {
        var i, s, r, n, a = function() {
            t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = a.prototype.setRatio
          },
          o = _gsScope._gsDefine.globals,
          h = {},
          l = a.prototype = new t("css");
        l.constructor = a, a.version = "1.15.0", a.API = 2, a.defaultTransformPerspective = 0, a.defaultSkewType = "compensated", l = "px", a.suffixMap = {
          top: l,
          right: l,
          bottom: l,
          left: l,
          width: l,
          height: l,
          fontSize: l,
          padding: l,
          margin: l,
          perspective: l,
          lineHeight: ""
        };
        var _, u, p, c, f, m, d = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
          g = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
          v = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
          y = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
          T = /(?:\d|\-|\+|=|#|\.)*/g,
          w = /opacity *= *([^)]*)/i,
          x = /opacity:([^;]*)/i,
          b = /alpha\(opacity *=.+?\)/i,
          P = /^(rgb|hsl)/,
          S = /([A-Z])/g,
          k = /-([a-z])/gi,
          R = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
          A = function(t, e) {
            return e.toUpperCase()
          },
          C = /(?:Left|Right|Width)/i,
          O = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
          D = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
          M = /,(?=[^\)]*(?:\(|$))/gi,
          z = Math.PI / 180,
          I = 180 / Math.PI,
          E = {},
          F = document,
          N = function(t) {
            return F.createElementNS ? F.createElementNS("http://www.w3.org/1999/xhtml", t) : F.createElement(t)
          },
          L = N("div"),
          X = N("img"),
          U = a._internals = {
            _specialProps: h
          },
          Y = navigator.userAgent,
          B = function() {
            var t = Y.indexOf("Android"),
              e = N("a");
            return p = -1 !== Y.indexOf("Safari") && -1 === Y.indexOf("Chrome") && (-1 === t || Number(Y.substr(t + 8, 1)) > 3), f = p && 6 > Number(Y.substr(Y.indexOf("Version/") + 8, 1)), c = -1 !== Y.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(Y) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(Y)) && (m = parseFloat(RegExp.$1)), e ? (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity)) : !1
          }(),
          j = function(t) {
            return w.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
          },
          q = function(t) {
            window.console && console.log(t)
          },
          V = "",
          G = "",
          W = function(t, e) {
            e = e || L;
            var i, s, r = e.style;
            if (void 0 !== r[t]) return t;
            for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], s = 5; --s > -1 && void 0 === r[i[s] + t];);
            return s >= 0 ? (G = 3 === s ? "ms" : i[s], V = "-" + G.toLowerCase() + "-", G + t) : null
          },
          Z = F.defaultView ? F.defaultView.getComputedStyle : function() {},
          Q = a.getStyle = function(t, e, i, s, r) {
            var n;
            return B || "opacity" !== e ? (!s && t.style[e] ? n = t.style[e] : (i = i || Z(t)) ? n = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(S, "-$1").toLowerCase()) : t.currentStyle && (n = t.currentStyle[e]), null == r || n && "none" !== n && "auto" !== n && "auto auto" !== n ? n : r) : j(t)
          },
          $ = U.convertToPixels = function(t, i, s, r, n) {
            if ("px" === r || !r) return s;
            if ("auto" === r || !s) return 0;
            var o, h, l, _ = C.test(i),
              u = t,
              p = L.style,
              c = 0 > s;
            if (c && (s = -s), "%" === r && -1 !== i.indexOf("border")) o = s / 100 * (_ ? t.clientWidth : t.clientHeight);
            else {
              if (p.cssText = "border:0 solid red;position:" + Q(t, "position") + ";line-height:0;", "%" !== r && u.appendChild) p[_ ? "borderLeftWidth" : "borderTopWidth"] = s + r;
              else {
                if (u = t.parentNode || F.body, h = u._gsCache, l = e.ticker.frame, h && _ && h.time === l) return h.width * s / 100;
                p[_ ? "width" : "height"] = s + r
              }
              u.appendChild(L), o = parseFloat(L[_ ? "offsetWidth" : "offsetHeight"]), u.removeChild(L), _ && "%" === r && a.cacheWidths !== !1 && (h = u._gsCache = u._gsCache || {}, h.time = l, h.width = 100 * (o / s)), 0 !== o || n || (o = $(t, i, s, r, !0))
            }
            return c ? -o : o
          },
          H = U.calculateOffset = function(t, e, i) {
            if ("absolute" !== Q(t, "position", i)) return 0;
            var s = "left" === e ? "Left" : "Top",
              r = Q(t, "margin" + s, i);
            return t["offset" + s] - ($(t, e, parseFloat(r), r.replace(T, "")) || 0)
          },
          K = function(t, e) {
            var i, s, r = {};
            if (e = e || Z(t, null))
              if (i = e.length)
                for (; --i > -1;) r[e[i].replace(k, A)] = e.getPropertyValue(e[i]);
              else
                for (i in e) r[i] = e[i];
            else if (e = t.currentStyle || t.style)
              for (i in e) "string" == typeof i && void 0 === r[i] && (r[i.replace(k, A)] = e[i]);
            return B || (r.opacity = j(t)), s = Me(t, e, !1), r.rotation = s.rotation, r.skewX = s.skewX, r.scaleX = s.scaleX, r.scaleY = s.scaleY, r.x = s.x, r.y = s.y, Se && (r.z = s.z, r.rotationX = s.rotationX, r.rotationY = s.rotationY, r.scaleZ = s.scaleZ), r.filters && delete r.filters, r
          },
          J = function(t, e, i, s, r) {
            var n, a, o, h = {},
              l = t.style;
            for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (n = i[a]) || r && r[a]) && -1 === a.indexOf("Origin") && ("number" == typeof n || "string" == typeof n) && (h[a] = "auto" !== n || "left" !== a && "top" !== a ? "" !== n && "auto" !== n && "none" !== n || "string" != typeof e[a] || "" === e[a].replace(y, "") ? n : 0 : H(t, a), void 0 !== l[a] && (o = new ce(l, a, l[a], o)));
            if (s)
              for (a in s) "className" !== a && (h[a] = s[a]);
            return {
              difs: h,
              firstMPT: o
            }
          },
          te = {
            width: ["Left", "Right"],
            height: ["Top", "Bottom"]
          },
          ee = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
          ie = function(t, e, i) {
            var s = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
              r = te[e],
              n = r.length;
            for (i = i || Z(t, null); --n > -1;) s -= parseFloat(Q(t, "padding" + r[n], i, !0)) || 0, s -= parseFloat(Q(t, "border" + r[n] + "Width", i, !0)) || 0;
            return s
          },
          se = function(t, e) {
            (null == t || "" === t || "auto" === t || "auto auto" === t) && (t = "0 0");
            var i = t.split(" "),
              s = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0],
              r = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1];
            return null == r ? r = "0" : "center" === r && (r = "50%"), ("center" === s || isNaN(parseFloat(s)) && -1 === (s + "").indexOf("=")) && (s = "50%"), e && (e.oxp = -1 !== s.indexOf("%"), e.oyp = -1 !== r.indexOf("%"), e.oxr = "=" === s.charAt(1), e.oyr = "=" === r.charAt(1), e.ox = parseFloat(s.replace(y, "")), e.oy = parseFloat(r.replace(y, ""))), s + " " + r + (i.length > 2 ? " " + i[2] : "")
          },
          re = function(t, e) {
            return "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e)
          },
          ne = function(t, e) {
            return null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t)
          },
          ae = function(t, e, i, s) {
            var r, n, a, o, h = 1e-6;
            return null == t ? o = e : "number" == typeof t ? o = t : (r = 360, n = t.split("_"), a = Number(n[0].replace(y, "")) * (-1 === t.indexOf("rad") ? 1 : I) - ("=" === t.charAt(1) ? 0 : e), n.length && (s && (s[i] = e + a), -1 !== t.indexOf("short") && (a %= r, a !== a % (r / 2) && (a = 0 > a ? a + r : a - r)), -1 !== t.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * r) % r - (0 | a / r) * r : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * r) % r - (0 | a / r) * r)), o = e + a), h > o && o > -h && (o = 0), o
          },
          oe = {
            aqua: [0, 255, 255],
            lime: [0, 255, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, 255],
            navy: [0, 0, 128],
            white: [255, 255, 255],
            fuchsia: [255, 0, 255],
            olive: [128, 128, 0],
            yellow: [255, 255, 0],
            orange: [255, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [255, 0, 0],
            pink: [255, 192, 203],
            cyan: [0, 255, 255],
            transparent: [255, 255, 255, 0]
          },
          he = function(t, e, i) {
            return t = 0 > t ? t + 1 : t > 1 ? t - 1 : t, 0 | 255 * (1 > 6 * t ? e + 6 * (i - e) * t : .5 > t ? i : 2 > 3 * t ? e + 6 * (i - e) * (2 / 3 - t) : e) + .5
          },
          le = a.parseColor = function(t) {
            var e, i, s, r, n, a;
            return t && "" !== t ? "number" == typeof t ? [t >> 16, 255 & t >> 8, 255 & t] : ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), oe[t] ? oe[t] : "#" === t.charAt(0) ? (4 === t.length && (e = t.charAt(1), i = t.charAt(2), s = t.charAt(3), t = "#" + e + e + i + i + s + s), t = parseInt(t.substr(1), 16), [t >> 16, 255 & t >> 8, 255 & t]) : "hsl" === t.substr(0, 3) ? (t = t.match(d), r = Number(t[0]) % 360 / 360, n = Number(t[1]) / 100, a = Number(t[2]) / 100, i = .5 >= a ? a * (n + 1) : a + n - a * n, e = 2 * a - i, t.length > 3 && (t[3] = Number(t[3])), t[0] = he(r + 1 / 3, e, i), t[1] = he(r, e, i), t[2] = he(r - 1 / 3, e, i), t) : (t = t.match(d) || oe.transparent, t[0] = Number(t[0]), t[1] = Number(t[1]), t[2] = Number(t[2]), t.length > 3 && (t[3] = Number(t[3])), t)) : oe.black
          },
          _e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";
        for (l in oe) _e += "|" + l + "\\b";
        _e = RegExp(_e + ")", "gi");
        var ue = function(t, e, i, s) {
            if (null == t) return function(t) {
              return t
            };
            var r, n = e ? (t.match(_e) || [""])[0] : "",
              a = t.split(n).join("").match(v) || [],
              o = t.substr(0, t.indexOf(a[0])),
              h = ")" === t.charAt(t.length - 1) ? ")" : "",
              l = -1 !== t.indexOf(" ") ? " " : ",",
              _ = a.length,
              u = _ > 0 ? a[0].replace(d, "") : "";
            return _ ? r = e ? function(t) {
              var e, p, c, f;
              if ("number" == typeof t) t += u;
              else if (s && M.test(t)) {
                for (f = t.replace(M, "|").split("|"), c = 0; f.length > c; c++) f[c] = r(f[c]);
                return f.join(",")
              }
              if (e = (t.match(_e) || [n])[0], p = t.split(e).join("").match(v) || [], c = p.length, _ > c--)
                for (; _ > ++c;) p[c] = i ? p[0 | (c - 1) / 2] : a[c];
              return o + p.join(l) + l + e + h + (-1 !== t.indexOf("inset") ? " inset" : "")
            } : function(t) {
              var e, n, p;
              if ("number" == typeof t) t += u;
              else if (s && M.test(t)) {
                for (n = t.replace(M, "|").split("|"), p = 0; n.length > p; p++) n[p] = r(n[p]);
                return n.join(",")
              }
              if (e = t.match(v) || [], p = e.length, _ > p--)
                for (; _ > ++p;) e[p] = i ? e[0 | (p - 1) / 2] : a[p];
              return o + e.join(l) + h
            } : function(t) {
              return t
            }
          },
          pe = function(t) {
            return t = t.split(","),
              function(e, i, s, r, n, a, o) {
                var h, l = (i + "").split(" ");
                for (o = {}, h = 0; 4 > h; h++) o[t[h]] = l[h] = l[h] || l[(h - 1) / 2 >> 0];
                return r.parse(e, o, n, a)
              }
          },
          ce = (U._setPluginRatio = function(t) {
            this.plugin.setRatio(t);
            for (var e, i, s, r, n = this.data, a = n.proxy, o = n.firstMPT, h = 1e-6; o;) e = a[o.v], o.r ? e = Math.round(e) : h > e && e > -h && (e = 0), o.t[o.p] = e, o = o._next;
            if (n.autoRotate && (n.autoRotate.rotation = a.rotation), 1 === t)
              for (o = n.firstMPT; o;) {
                if (i = o.t, i.type) {
                  if (1 === i.type) {
                    for (r = i.xs0 + i.s + i.xs1, s = 1; i.l > s; s++) r += i["xn" + s] + i["xs" + (s + 1)];
                    i.e = r
                  }
                } else i.e = i.s + i.xs0;
                o = o._next
              }
          }, function(t, e, i, s, r) {
            this.t = t, this.p = e, this.v = i, this.r = r, s && (s._prev = this, this._next = s)
          }),
          fe = (U._parseToProxy = function(t, e, i, s, r, n) {
            var a, o, h, l, _, u = s,
              p = {},
              c = {},
              f = i._transform,
              m = E;
            for (i._transform = null, E = e, s = _ = i.parse(t, e, s, r), E = m, n && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); s && s !== u;) {
              if (1 >= s.type && (o = s.p, c[o] = s.s + s.c, p[o] = s.s, n || (l = new ce(s, "s", o, l, s.r), s.c = 0), 1 === s.type))
                for (a = s.l; --a > 0;) h = "xn" + a, o = s.p + "_" + h, c[o] = s.data[h], p[o] = s[h], n || (l = new ce(s, h, o, l, s.rxp[h]));
              s = s._next
            }
            return {
              proxy: p,
              end: c,
              firstMPT: l,
              pt: _
            }
          }, U.CSSPropTween = function(t, e, s, r, a, o, h, l, _, u, p) {
            this.t = t, this.p = e, this.s = s, this.c = r, this.n = h || e, t instanceof fe || n.push(this.n), this.r = l, this.type = o || 0, _ && (this.pr = _, i = !0), this.b = void 0 === u ? s : u, this.e = void 0 === p ? s + r : p, a && (this._next = a, a._prev = this)
          }),
          me = a.parseComplex = function(t, e, i, s, r, n, a, o, h, l) {
            i = i || n || "", a = new fe(t, e, 0, 0, a, l ? 2 : 1, null, !1, o, i, s), s += "";
            var u, p, c, f, m, v, y, T, w, x, b, S, k = i.split(", ").join(",").split(" "),
              R = s.split(", ").join(",").split(" "),
              A = k.length,
              C = _ !== !1;
            for ((-1 !== s.indexOf(",") || -1 !== i.indexOf(",")) && (k = k.join(" ").replace(M, ", ").split(" "), R = R.join(" ").replace(M, ", ").split(" "), A = k.length), A !== R.length && (k = (n || "").split(" "), A = k.length), a.plugin = h, a.setRatio = l, u = 0; A > u; u++)
              if (f = k[u], m = R[u], T = parseFloat(f), T || 0 === T) a.appendXtra("", T, re(m, T), m.replace(g, ""), C && -1 !== m.indexOf("px"), !0);
              else if (r && ("#" === f.charAt(0) || oe[f] || P.test(f))) S = "," === m.charAt(m.length - 1) ? ")," : ")", f = le(f), m = le(m), w = f.length + m.length > 6, w && !B && 0 === m[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(R[u]).join("transparent")) : (B || (w = !1), a.appendXtra(w ? "rgba(" : "rgb(", f[0], m[0] - f[0], ",", !0, !0).appendXtra("", f[1], m[1] - f[1], ",", !0).appendXtra("", f[2], m[2] - f[2], w ? "," : S, !0), w && (f = 4 > f.length ? 1 : f[3], a.appendXtra("", f, (4 > m.length ? 1 : m[3]) - f, S, !1)));
            else if (v = f.match(d)) {
              if (y = m.match(g), !y || y.length !== v.length) return a;
              for (c = 0, p = 0; v.length > p; p++) b = v[p], x = f.indexOf(b, c), a.appendXtra(f.substr(c, x - c), Number(b), re(y[p], b), "", C && "px" === f.substr(x + b.length, 2), 0 === p), c = x + b.length;
              a["xs" + a.l] += f.substr(c)
            } else a["xs" + a.l] += a.l ? " " + f : f;
            if (-1 !== s.indexOf("=") && a.data) {
              for (S = a.xs0 + a.data.s, u = 1; a.l > u; u++) S += a["xs" + u] + a.data["xn" + u];
              a.e = S + a["xs" + u]
            }
            return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
          },
          de = 9;
        for (l = fe.prototype, l.l = l.pr = 0; --de > 0;) l["xn" + de] = 0, l["xs" + de] = "";
        l.xs0 = "", l._next = l._prev = l.xfirst = l.data = l.plugin = l.setRatio = l.rxp = null, l.appendXtra = function(t, e, i, s, r, n) {
          var a = this,
            o = a.l;
          return a["xs" + o] += n && o ? " " + t : t || "", i || 0 === o || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = s || "", o > 0 ? (a.data["xn" + o] = e + i, a.rxp["xn" + o] = r, a["xn" + o] = e, a.plugin || (a.xfirst = new fe(a, "xn" + o, e, i, a.xfirst || a, 0, a.n, r, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
            s: e + i
          }, a.rxp = {}, a.s = e, a.c = i, a.r = r, a)) : (a["xs" + o] += e + (s || ""), a)
        };
        var ge = function(t, e) {
            e = e || {}, this.p = e.prefix ? W(t) || t : t, h[t] = h[this.p] = this, this.format = e.formatter || ue(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0
          },
          ve = U._registerComplexSpecialProp = function(t, e, i) {
            "object" != typeof e && (e = {
              parser: i
            });
            var s, r, n = t.split(","),
              a = e.defaultValue;
            for (i = i || [a], s = 0; n.length > s; s++) e.prefix = 0 === s && e.prefix, e.defaultValue = i[s] || a, r = new ge(n[s], e)
          },
          ye = function(t) {
            if (!h[t]) {
              var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
              ve(t, {
                parser: function(t, i, s, r, n, a, l) {
                  var _ = o.com.greensock.plugins[e];
                  return _ ? (_._cssRegister(), h[s].parse(t, i, s, r, n, a, l)) : (q("Error: " + e + " js file not loaded."), n)
                }
              })
            }
          };
        l = ge.prototype, l.parseComplex = function(t, e, i, s, r, n) {
          var a, o, h, l, _, u, p = this.keyword;
          if (this.multi && (M.test(i) || M.test(e) ? (o = e.replace(M, "|").split("|"), h = i.replace(M, "|").split("|")) : p && (o = [e], h = [i])), h) {
            for (l = h.length > o.length ? h.length : o.length, a = 0; l > a; a++) e = o[a] = o[a] || this.dflt, i = h[a] = h[a] || this.dflt, p && (_ = e.indexOf(p), u = i.indexOf(p), _ !== u && (i = -1 === u ? h : o, i[a] += " " + p));
            e = o.join(", "), i = h.join(", ")
          }
          return me(t, this.p, e, i, this.clrs, this.dflt, s, this.pr, r, n)
        }, l.parse = function(t, e, i, s, n, a) {
          return this.parseComplex(t.style, this.format(Q(t, this.p, r, !1, this.dflt)), this.format(e), n, a)
        }, a.registerSpecialProp = function(t, e, i) {
          ve(t, {
            parser: function(t, s, r, n, a, o) {
              var h = new fe(t, r, 0, 0, a, 2, r, !1, i);
              return h.plugin = o, h.setRatio = e(t, s, n._tween, r), h
            },
            priority: i
          })
        };
        var Te, we = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
          xe = W("transform"),
          be = V + "transform",
          Pe = W("transformOrigin"),
          Se = null !== W("perspective"),
          ke = U.Transform = function() {
            this.perspective = parseFloat(a.defaultTransformPerspective) || 0, this.force3D = a.defaultForce3D !== !1 && Se ? a.defaultForce3D || "auto" : !1
          },
          Re = window.SVGElement,
          Ae = function(t, e, i) {
            var s, r = F.createElementNS("http://www.w3.org/2000/svg", t),
              n = /([a-z])([A-Z])/g;
            for (s in i) r.setAttributeNS(null, s.replace(n, "$1-$2").toLowerCase(), i[s]);
            return e.appendChild(r), r
          },
          Ce = document.documentElement,
          Oe = function() {
            var t, e, i, s = m || /Android/i.test(Y) && !window.chrome;
            return F.createElementNS && !s && (t = Ae("svg", Ce), e = Ae("rect", t, {
              width: 100,
              height: 50,
              x: 100
            }), i = e.getBoundingClientRect().width, e.style[Pe] = "50% 50%", e.style[xe] = "scaleX(0.5)", s = i === e.getBoundingClientRect().width, Ce.removeChild(t)), s
          }(),
          De = function(t, e, i) {
            var s = t.getBBox();
            e = se(e).split(" "), i.xOrigin = (-1 !== e[0].indexOf("%") ? parseFloat(e[0]) / 100 * s.width : parseFloat(e[0])) + s.x, i.yOrigin = (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * s.height : parseFloat(e[1])) + s.y
          },
          Me = U.getTransform = function(t, e, i, s) {
            if (t._gsTransform && i && !s) return t._gsTransform;
            var n, o, h, l, _, u, p, c, f, m, d = i ? t._gsTransform || new ke : new ke,
              g = 0 > d.scaleX,
              v = 2e-5,
              y = 1e5,
              T = Se ? parseFloat(Q(t, Pe, e, !1, "0 0 0").split(" ")[2]) || d.zOrigin || 0 : 0,
              w = parseFloat(a.defaultTransformPerspective) || 0;
            if (xe ? o = Q(t, be, e, !0) : t.currentStyle && (o = t.currentStyle.filter.match(O), o = o && 4 === o.length ? [o[0].substr(4), Number(o[2].substr(4)), Number(o[1].substr(4)), o[3].substr(4), d.x || 0, d.y || 0].join(",") : ""), n = !o || "none" === o || "matrix(1, 0, 0, 1, 0, 0)" === o, d.svg = !!(Re && "function" == typeof t.getBBox && t.getCTM && (!t.parentNode || t.parentNode.getBBox && t.parentNode.getCTM)), d.svg && (De(t, Q(t, Pe, r, !1, "50% 50%") + "", d), Te = a.useSVGTransformAttr || Oe, h = t.getAttribute("transform"), n && h && -1 !== h.indexOf("matrix") && (o = h, n = 0)), !n) {
              for (h = (o || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], l = h.length; --l > -1;) _ = Number(h[l]), h[l] = (u = _ - (_ |= 0)) ? (0 | u * y + (0 > u ? -.5 : .5)) / y + _ : _;
              if (16 === h.length) {
                var x = h[8],
                  b = h[9],
                  P = h[10],
                  S = h[12],
                  k = h[13],
                  R = h[14];
                d.zOrigin && (R = -d.zOrigin, S = x * R - h[12], k = b * R - h[13], R = P * R + d.zOrigin - h[14]);
                var A, C, D, M, z, E = h[0],
                  F = h[1],
                  N = h[2],
                  L = h[3],
                  X = h[4],
                  U = h[5],
                  Y = h[6],
                  B = h[7],
                  j = h[11],
                  q = Math.atan2(F, U);
                d.rotation = q * I, q && (M = Math.cos(-q), z = Math.sin(-q), E = E * M + X * z, C = F * M + U * z, U = F * -z + U * M, Y = N * -z + Y * M, F = C), q = Math.atan2(x, E), d.rotationY = q * I, q && (M = Math.cos(-q), z = Math.sin(-q), A = E * M - x * z, C = F * M - b * z, D = N * M - P * z, b = F * z + b * M, P = N * z + P * M, j = L * z + j * M, E = A, F = C, N = D), q = Math.atan2(Y, P), d.rotationX = q * I, q && (M = Math.cos(-q), z = Math.sin(-q), A = X * M + x * z, C = U * M + b * z, D = Y * M + P * z, x = X * -z + x * M, b = U * -z + b * M, P = Y * -z + P * M, j = B * -z + j * M, X = A, U = C, Y = D), d.scaleX = (0 | Math.sqrt(E * E + F * F) * y + .5) / y, d.scaleY = (0 | Math.sqrt(U * U + b * b) * y + .5) / y, d.scaleZ = (0 | Math.sqrt(Y * Y + P * P) * y + .5) / y, d.skewX = 0, d.perspective = j ? 1 / (0 > j ? -j : j) : 0, d.x = S, d.y = k, d.z = R
              } else if (!(Se && !s && h.length && d.x === h[4] && d.y === h[5] && (d.rotationX || d.rotationY) || void 0 !== d.x && "none" === Q(t, "display", e))) {
                var V = h.length >= 6,
                  G = V ? h[0] : 1,
                  W = h[1] || 0,
                  Z = h[2] || 0,
                  $ = V ? h[3] : 1;
                d.x = h[4] || 0, d.y = h[5] || 0, p = Math.sqrt(G * G + W * W), c = Math.sqrt($ * $ + Z * Z), f = G || W ? Math.atan2(W, G) * I : d.rotation || 0, m = Z || $ ? Math.atan2(Z, $) * I + f : d.skewX || 0, Math.abs(m) > 90 && 270 > Math.abs(m) && (g ? (p *= -1, m += 0 >= f ? 180 : -180, f += 0 >= f ? 180 : -180) : (c *= -1, m += 0 >= m ? 180 : -180)), d.scaleX = p, d.scaleY = c, d.rotation = f, d.skewX = m, Se && (d.rotationX = d.rotationY = d.z = 0, d.perspective = w, d.scaleZ = 1)
              }
              d.zOrigin = T;
              for (l in d) v > d[l] && d[l] > -v && (d[l] = 0)
            }
            return i && (t._gsTransform = d), d
          },
          ze = function(t) {
            var e, i, s = this.data,
              r = -s.rotation * z,
              n = r + s.skewX * z,
              a = 1e5,
              o = (0 | Math.cos(r) * s.scaleX * a) / a,
              h = (0 | Math.sin(r) * s.scaleX * a) / a,
              l = (0 | Math.sin(n) * -s.scaleY * a) / a,
              _ = (0 | Math.cos(n) * s.scaleY * a) / a,
              u = this.t.style,
              p = this.t.currentStyle;
            if (p) {
              i = h, h = -l, l = -i, e = p.filter, u.filter = "";
              var c, f, d = this.t.offsetWidth,
                g = this.t.offsetHeight,
                v = "absolute" !== p.position,
                y = "progid:DXImageTransform.Microsoft.Matrix(M11=" + o + ", M12=" + h + ", M21=" + l + ", M22=" + _,
                x = s.x + d * s.xPercent / 100,
                b = s.y + g * s.yPercent / 100;
              if (null != s.ox && (c = (s.oxp ? .01 * d * s.ox : s.ox) - d / 2, f = (s.oyp ? .01 * g * s.oy : s.oy) - g / 2, x += c - (c * o + f * h), b += f - (c * l + f * _)), v ? (c = d / 2, f = g / 2, y += ", Dx=" + (c - (c * o + f * h) + x) + ", Dy=" + (f - (c * l + f * _) + b) + ")") : y += ", sizingMethod='auto expand')", u.filter = -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? e.replace(D, y) : y + " " + e, (0 === t || 1 === t) && 1 === o && 0 === h && 0 === l && 1 === _ && (v && -1 === y.indexOf("Dx=0, Dy=0") || w.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf("gradient(" && e.indexOf("Alpha")) && u.removeAttribute("filter")), !v) {
                var P, S, k, R = 8 > m ? 1 : -1;
                for (c = s.ieOffsetX || 0, f = s.ieOffsetY || 0, s.ieOffsetX = Math.round((d - ((0 > o ? -o : o) * d + (0 > h ? -h : h) * g)) / 2 + x), s.ieOffsetY = Math.round((g - ((0 > _ ? -_ : _) * g + (0 > l ? -l : l) * d)) / 2 + b), de = 0; 4 > de; de++) S = ee[de], P = p[S], i = -1 !== P.indexOf("px") ? parseFloat(P) : $(this.t, S, parseFloat(P), P.replace(T, "")) || 0, k = i !== s[S] ? 2 > de ? -s.ieOffsetX : -s.ieOffsetY : 2 > de ? c - s.ieOffsetX : f - s.ieOffsetY, u[S] = (s[S] = Math.round(i - k * (0 === de || 2 === de ? 1 : R))) + "px"
              }
            }
          },
          Ie = U.set3DTransformRatio = function(t) {
            var e, i, s, r, n, a, o, h, l, _, u, p, f, m, d, g, v, y, T, w, x, b, P, S, k, R = this.data,
              A = this.t.style,
              C = R.rotation * z,
              O = R.scaleX,
              D = R.scaleY,
              M = R.scaleZ,
              I = R.x,
              E = R.y,
              F = R.z,
              N = R.perspective;
            if (!(1 !== t && 0 !== t || "auto" !== R.force3D || R.rotationY || R.rotationX || 1 !== M || N || F)) return Ee.call(this, t), void 0;
            if (c) {
              var L = 1e-4;
              L > O && O > -L && (O = M = 2e-5), L > D && D > -L && (D = M = 2e-5), !N || R.z || R.rotationX || R.rotationY || (N = 0)
            }
            if (C || R.skewX) y = Math.cos(C), T = Math.sin(C), e = y, n = T, R.skewX && (C -= R.skewX * z, y = Math.cos(C), T = Math.sin(C), "simple" === R.skewType && (w = Math.tan(R.skewX * z), w = Math.sqrt(1 + w * w), y *= w, T *= w)), i = -T, a = y;
            else {
              if (!(R.rotationY || R.rotationX || 1 !== M || N || R.svg)) return A[xe] = (R.xPercent || R.yPercent ? "translate(" + R.xPercent + "%," + R.yPercent + "%) translate3d(" : "translate3d(") + I + "px," + E + "px," + F + "px)" + (1 !== O || 1 !== D ? " scale(" + O + "," + D + ")" : ""), void 0;
              e = a = 1, i = n = 0
            }
            u = 1, s = r = o = h = l = _ = p = f = m = 0, d = N ? -1 / N : 0, g = R.zOrigin, v = 1e5, k = ",", C = R.rotationY * z, C && (y = Math.cos(C), T = Math.sin(C), l = u * -T, f = d * -T, s = e * T, o = n * T, u *= y, d *= y, e *= y, n *= y), C = R.rotationX * z, C && (y = Math.cos(C), T = Math.sin(C), w = i * y + s * T, x = a * y + o * T, b = _ * y + u * T, P = m * y + d * T, s = i * -T + s * y, o = a * -T + o * y, u = _ * -T + u * y, d = m * -T + d * y, i = w, a = x, _ = b, m = P), 1 !== M && (s *= M, o *= M, u *= M, d *= M), 1 !== D && (i *= D, a *= D, _ *= D, m *= D), 1 !== O && (e *= O, n *= O, l *= O, f *= O), g && (p -= g, r = s * p, h = o * p, p = u * p + g), R.svg && (r += R.xOrigin - (R.xOrigin * e + R.yOrigin * i), h += R.yOrigin - (R.xOrigin * n + R.yOrigin * a)), r = (w = (r += I) - (r |= 0)) ? (0 | w * v + (0 > w ? -.5 : .5)) / v + r : r, h = (w = (h += E) - (h |= 0)) ? (0 | w * v + (0 > w ? -.5 : .5)) / v + h : h, p = (w = (p += F) - (p |= 0)) ? (0 | w * v + (0 > w ? -.5 : .5)) / v + p : p, S = R.xPercent || R.yPercent ? "translate(" + R.xPercent + "%," + R.yPercent + "%) matrix3d(" : "matrix3d(", S += (0 | e * v) / v + k + (0 | n * v) / v + k + (0 | l * v) / v, S += k + (0 | f * v) / v + k + (0 | i * v) / v + k + (0 | a * v) / v, S += k + (0 | _ * v) / v + k + (0 | m * v) / v + k + (0 | s * v) / v, S += k + (0 | o * v) / v + k + (0 | u * v) / v + k + (0 | d * v) / v, S += k + r + k + h + k + p + k + (N ? 1 + -p / N : 1) + ")", A[xe] = S
          },
          Ee = U.set2DTransformRatio = function(t) {
            var e, i, s, r, n, a, o, h, l, _, u, p = this.data,
              c = this.t,
              f = c.style,
              m = p.x,
              d = p.y;
            return !(p.rotationX || p.rotationY || p.z || p.force3D === !0 || "auto" === p.force3D && 1 !== t && 0 !== t) || p.svg && Te || !Se ? (r = p.scaleX, n = p.scaleY, p.rotation || p.skewX || p.svg ? (e = p.rotation * z, i = e - p.skewX * z, s = 1e5, a = Math.cos(e) * r, o = Math.sin(e) * r, h = Math.sin(i) * -n, l = Math.cos(i) * n, p.svg && (m += p.xOrigin - (p.xOrigin * a + p.yOrigin * h), d += p.yOrigin - (p.xOrigin * o + p.yOrigin * l), u = 1e-6, u > m && m > -u && (m = 0), u > d && d > -u && (d = 0)), _ = (0 | a * s) / s + "," + (0 | o * s) / s + "," + (0 | h * s) / s + "," + (0 | l * s) / s + "," + m + "," + d + ")", p.svg && Te ? c.setAttribute("transform", "matrix(" + _) : f[xe] = (p.xPercent || p.yPercent ? "translate(" + p.xPercent + "%," + p.yPercent + "%) matrix(" : "matrix(") + _) : f[xe] = (p.xPercent || p.yPercent ? "translate(" + p.xPercent + "%," + p.yPercent + "%) matrix(" : "matrix(") + r + ",0,0," + n + "," + m + "," + d + ")", void 0) : (this.setRatio = Ie, Ie.call(this, t), void 0)
          };
        l = ke.prototype, l.x = l.y = l.z = l.skewX = l.skewY = l.rotation = l.rotationX = l.rotationY = l.zOrigin = l.xPercent = l.yPercent = 0, l.scaleX = l.scaleY = l.scaleZ = 1, ve("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent", {
          parser: function(t, e, i, s, n, o, h) {
            if (s._lastParsedTransform === h) return n;
            s._lastParsedTransform = h;
            var l, _, u, p, c, f, m, d = s._transform = Me(t, r, !0, h.parseTransform),
              g = t.style,
              v = 1e-6,
              y = we.length,
              T = h,
              w = {};
            if ("string" == typeof T.transform && xe) u = L.style, u[xe] = T.transform, u.display = "block", u.position = "absolute", F.body.appendChild(L), l = Me(L, null, !1), F.body.removeChild(L);
            else if ("object" == typeof T) {
              if (l = {
                  scaleX: ne(null != T.scaleX ? T.scaleX : T.scale, d.scaleX),
                  scaleY: ne(null != T.scaleY ? T.scaleY : T.scale, d.scaleY),
                  scaleZ: ne(T.scaleZ, d.scaleZ),
                  x: ne(T.x, d.x),
                  y: ne(T.y, d.y),
                  z: ne(T.z, d.z),
                  xPercent: ne(T.xPercent, d.xPercent),
                  yPercent: ne(T.yPercent, d.yPercent),
                  perspective: ne(T.transformPerspective, d.perspective)
                }, m = T.directionalRotation, null != m)
                if ("object" == typeof m)
                  for (u in m) T[u] = m[u];
                else T.rotation = m;
                "string" == typeof T.x && -1 !== T.x.indexOf("%") && (l.x = 0, l.xPercent = ne(T.x, d.xPercent)), "string" == typeof T.y && -1 !== T.y.indexOf("%") && (l.y = 0, l.yPercent = ne(T.y, d.yPercent)), l.rotation = ae("rotation" in T ? T.rotation : "shortRotation" in T ? T.shortRotation + "_short" : "rotationZ" in T ? T.rotationZ : d.rotation, d.rotation, "rotation", w), Se && (l.rotationX = ae("rotationX" in T ? T.rotationX : "shortRotationX" in T ? T.shortRotationX + "_short" : d.rotationX || 0, d.rotationX, "rotationX", w), l.rotationY = ae("rotationY" in T ? T.rotationY : "shortRotationY" in T ? T.shortRotationY + "_short" : d.rotationY || 0, d.rotationY, "rotationY", w)), l.skewX = null == T.skewX ? d.skewX : ae(T.skewX, d.skewX), l.skewY = null == T.skewY ? d.skewY : ae(T.skewY, d.skewY), (_ = l.skewY - d.skewY) && (l.skewX += _, l.rotation += _)
            }
            for (Se && null != T.force3D && (d.force3D = T.force3D, f = !0), d.skewType = T.skewType || d.skewType || a.defaultSkewType, c = d.force3D || d.z || d.rotationX || d.rotationY || l.z || l.rotationX || l.rotationY || l.perspective, c || null == T.scale || (l.scaleZ = 1); --y > -1;) i = we[y], p = l[i] - d[i], (p > v || -v > p || null != T[i] || null != E[i]) && (f = !0, n = new fe(d, i, d[i], p, n), i in w && (n.e = w[i]), n.xs0 = 0, n.plugin = o, s._overwriteProps.push(n.n));
            return p = T.transformOrigin, p && d.svg && (De(t, p, l), n = new fe(d, "xOrigin", d.xOrigin, l.xOrigin - d.xOrigin, n, -1, "transformOrigin"), n.b = d.xOrigin, n.e = n.xs0 = l.xOrigin, n = new fe(d, "yOrigin", d.yOrigin, l.yOrigin - d.yOrigin, n, -1, "transformOrigin"), n.b = d.yOrigin, n.e = n.xs0 = l.yOrigin, p = "0px 0px"), (p || Se && c && d.zOrigin) && (xe ? (f = !0, i = Pe, p = (p || Q(t, i, r, !1, "50% 50%")) + "", n = new fe(g, i, 0, 0, n, -1, "transformOrigin"), n.b = g[i], n.plugin = o, Se ? (u = d.zOrigin, p = p.split(" "), d.zOrigin = (p.length > 2 && (0 === u || "0px" !== p[2]) ? parseFloat(p[2]) : u) || 0, n.xs0 = n.e = p[0] + " " + (p[1] || "50%") + " 0px", n = new fe(d, "zOrigin", 0, 0, n, -1, n.n), n.b = u, n.xs0 = n.e = d.zOrigin) : n.xs0 = n.e = p) : se(p + "", d)), f && (s._transformType = d.svg && Te || !c && 3 !== this._transformType ? 2 : 3), n
          },
          prefix: !0
        }), ve("boxShadow", {
          defaultValue: "0px 0px 0px 0px #999",
          prefix: !0,
          color: !0,
          multi: !0,
          keyword: "inset"
        }), ve("borderRadius", {
          defaultValue: "0px",
          parser: function(t, e, i, n, a) {
            e = this.format(e);
            var o, h, l, _, u, p, c, f, m, d, g, v, y, T, w, x, b = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
              P = t.style;
            for (m = parseFloat(t.offsetWidth), d = parseFloat(t.offsetHeight), o = e.split(" "), h = 0; b.length > h; h++) this.p.indexOf("border") && (b[h] = W(b[h])), u = _ = Q(t, b[h], r, !1, "0px"), -1 !== u.indexOf(" ") && (_ = u.split(" "), u = _[0], _ = _[1]), p = l = o[h], c = parseFloat(u), v = u.substr((c + "").length), y = "=" === p.charAt(1), y ? (f = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), f *= parseFloat(p), g = p.substr((f + "").length - (0 > f ? 1 : 0)) || "") : (f = parseFloat(p), g = p.substr((f + "").length)), "" === g && (g = s[i] || v), g !== v && (T = $(t, "borderLeft", c, v), w = $(t, "borderTop", c, v), "%" === g ? (u = 100 * (T / m) + "%", _ = 100 * (w / d) + "%") : "em" === g ? (x = $(t, "borderLeft", 1, "em"), u = T / x + "em", _ = w / x + "em") : (u = T + "px", _ = w + "px"), y && (p = parseFloat(u) + f + g, l = parseFloat(_) + f + g)), a = me(P, b[h], u + " " + _, p + " " + l, !1, "0px", a);
            return a
          },
          prefix: !0,
          formatter: ue("0px 0px 0px 0px", !1, !0)
        }), ve("backgroundPosition", {
          defaultValue: "0 0",
          parser: function(t, e, i, s, n, a) {
            var o, h, l, _, u, p, c = "background-position",
              f = r || Z(t, null),
              d = this.format((f ? m ? f.getPropertyValue(c + "-x") + " " + f.getPropertyValue(c + "-y") : f.getPropertyValue(c) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
              g = this.format(e);
            if (-1 !== d.indexOf("%") != (-1 !== g.indexOf("%")) && (p = Q(t, "backgroundImage").replace(R, ""), p && "none" !== p)) {
              for (o = d.split(" "), h = g.split(" "), X.setAttribute("src", p), l = 2; --l > -1;) d = o[l], _ = -1 !== d.indexOf("%"), _ !== (-1 !== h[l].indexOf("%")) && (u = 0 === l ? t.offsetWidth - X.width : t.offsetHeight - X.height, o[l] = _ ? parseFloat(d) / 100 * u + "px" : 100 * (parseFloat(d) / u) + "%");
              d = o.join(" ")
            }
            return this.parseComplex(t.style, d, g, n, a)
          },
          formatter: se
        }), ve("backgroundSize", {
          defaultValue: "0 0",
          formatter: se
        }), ve("perspective", {
          defaultValue: "0px",
          prefix: !0
        }), ve("perspectiveOrigin", {
          defaultValue: "50% 50%",
          prefix: !0
        }), ve("transformStyle", {
          prefix: !0
        }), ve("backfaceVisibility", {
          prefix: !0
        }), ve("userSelect", {
          prefix: !0
        }), ve("margin", {
          parser: pe("marginTop,marginRight,marginBottom,marginLeft")
        }), ve("padding", {
          parser: pe("paddingTop,paddingRight,paddingBottom,paddingLeft")
        }), ve("clip", {
          defaultValue: "rect(0px,0px,0px,0px)",
          parser: function(t, e, i, s, n, a) {
            var o, h, l;
            return 9 > m ? (h = t.currentStyle, l = 8 > m ? " " : ",", o = "rect(" + h.clipTop + l + h.clipRight + l + h.clipBottom + l + h.clipLeft + ")", e = this.format(e).split(",").join(l)) : (o = this.format(Q(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, o, e, n, a)
          }
        }), ve("textShadow", {
          defaultValue: "0px 0px 0px #999",
          color: !0,
          multi: !0
        }), ve("autoRound,strictUnits", {
          parser: function(t, e, i, s, r) {
            return r
          }
        }), ve("border", {
          defaultValue: "0px solid #000",
          parser: function(t, e, i, s, n, a) {
            return this.parseComplex(t.style, this.format(Q(t, "borderTopWidth", r, !1, "0px") + " " + Q(t, "borderTopStyle", r, !1, "solid") + " " + Q(t, "borderTopColor", r, !1, "#000")), this.format(e), n, a)
          },
          color: !0,
          formatter: function(t) {
            var e = t.split(" ");
            return e[0] + " " + (e[1] || "solid") + " " + (t.match(_e) || ["#000"])[0]
          }
        }), ve("borderWidth", {
          parser: pe("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
        }), ve("float,cssFloat,styleFloat", {
          parser: function(t, e, i, s, r) {
            var n = t.style,
              a = "cssFloat" in n ? "cssFloat" : "styleFloat";
            return new fe(n, a, 0, 0, r, -1, i, !1, 0, n[a], e)
          }
        });
        var Fe = function(t) {
          var e, i = this.t,
            s = i.filter || Q(this.data, "filter") || "",
            r = 0 | this.s + this.c * t;
          100 === r && (-1 === s.indexOf("atrix(") && -1 === s.indexOf("radient(") && -1 === s.indexOf("oader(") ? (i.removeAttribute("filter"), e = !Q(this.data, "filter")) : (i.filter = s.replace(b, ""), e = !0)), e || (this.xn1 && (i.filter = s = s || "alpha(opacity=" + r + ")"), -1 === s.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = s + " alpha(opacity=" + r + ")") : i.filter = s.replace(w, "opacity=" + r))
        };
        ve("opacity,alpha,autoAlpha", {
          defaultValue: "1",
          parser: function(t, e, i, s, n, a) {
            var o = parseFloat(Q(t, "opacity", r, !1, "1")),
              h = t.style,
              l = "autoAlpha" === i;
            return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + o), l && 1 === o && "hidden" === Q(t, "visibility", r) && 0 !== e && (o = 0), B ? n = new fe(h, "opacity", o, e - o, n) : (n = new fe(h, "opacity", 100 * o, 100 * (e - o), n), n.xn1 = l ? 1 : 0, h.zoom = 1, n.type = 2, n.b = "alpha(opacity=" + n.s + ")", n.e = "alpha(opacity=" + (n.s + n.c) + ")", n.data = t, n.plugin = a, n.setRatio = Fe), l && (n = new fe(h, "visibility", 0, 0, n, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), n.xs0 = "inherit", s._overwriteProps.push(n.n), s._overwriteProps.push(i)), n
          }
        });
        var Ne = function(t, e) {
            e && (t.removeProperty ? ("ms" === e.substr(0, 2) && (e = "M" + e.substr(1)), t.removeProperty(e.replace(S, "-$1").toLowerCase())) : t.removeAttribute(e))
          },
          Le = function(t) {
            if (this.t._gsClassPT = this, 1 === t || 0 === t) {
              this.t.setAttribute("class", 0 === t ? this.b : this.e);
              for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Ne(i, e.p), e = e._next;
              1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
            } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
          };
        ve("className", {
          parser: function(t, e, s, n, a, o, h) {
            var l, _, u, p, c, f = t.getAttribute("class") || "",
              m = t.style.cssText;
            if (a = n._classNamePT = new fe(t, s, 0, 0, a, 2), a.setRatio = Le, a.pr = -11, i = !0, a.b = f, _ = K(t, r), u = t._gsClassPT) {
              for (p = {}, c = u.data; c;) p[c.p] = 1, c = c._next;
              u.setRatio(1)
            }
            return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : f.replace(RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), n._tween._duration && (t.setAttribute("class", a.e), l = J(t, _, K(t), h, p), t.setAttribute("class", f), a.data = l.firstMPT, t.style.cssText = m, a = a.xfirst = n.parse(t, l.difs, a, o)), a
          }
        });
        var Xe = function(t) {
          if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
            var e, i, s, r, n = this.t.style,
              a = h.transform.parse;
            if ("all" === this.e) n.cssText = "", r = !0;
            else
              for (e = this.e.split(" ").join("").split(","), s = e.length; --s > -1;) i = e[s], h[i] && (h[i].parse === a ? r = !0 : i = "transformOrigin" === i ? Pe : h[i].p), Ne(n, i);
            r && (Ne(n, xe), this.t._gsTransform && delete this.t._gsTransform)
          }
        };
        for (ve("clearProps", {
            parser: function(t, e, s, r, n) {
              return n = new fe(t, s, 0, 0, n, 2), n.setRatio = Xe, n.e = e, n.pr = -10, n.data = r._tween, i = !0, n
            }
          }), l = "bezier,throwProps,physicsProps,physics2D".split(","), de = l.length; de--;) ye(l[de]);
        l = a.prototype, l._firstPT = l._lastParsedTransform = l._transform = null, l._onInitTween = function(t, e, o) {
          if (!t.nodeType) return !1;
          this._target = t, this._tween = o, this._vars = e, _ = e.autoRound, i = !1, s = e.suffixMap || a.suffixMap, r = Z(t, ""), n = this._overwriteProps;
          var h, l, c, m, d, g, v, y, T, w = t.style;
          if (u && "" === w.zIndex && (h = Q(t, "zIndex", r), ("auto" === h || "" === h) && this._addLazySet(w, "zIndex", 0)), "string" == typeof e && (m = w.cssText, h = K(t, r), w.cssText = m + ";" + e, h = J(t, h, K(t)).difs, !B && x.test(e) && (h.opacity = parseFloat(RegExp.$1)), e = h, w.cssText = m), this._firstPT = l = this.parse(t, e, null), this._transformType) {
            for (T = 3 === this._transformType, xe ? p && (u = !0, "" === w.zIndex && (v = Q(t, "zIndex", r), ("auto" === v || "" === v) && this._addLazySet(w, "zIndex", 0)), f && this._addLazySet(w, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (T ? "visible" : "hidden"))) : w.zoom = 1, c = l; c && c._next;) c = c._next;
            y = new fe(t, "transform", 0, 0, null, 2), this._linkCSSP(y, null, c), y.setRatio = T && Se ? Ie : xe ? Ee : ze, y.data = this._transform || Me(t, r, !0), n.pop()
          }
          if (i) {
            for (; l;) {
              for (g = l._next, c = m; c && c.pr > l.pr;) c = c._next;
              (l._prev = c ? c._prev : d) ? l._prev._next = l: m = l, (l._next = c) ? c._prev = l : d = l, l = g
            }
            this._firstPT = m
          }
          return !0
        }, l.parse = function(t, e, i, n) {
          var a, o, l, u, p, c, f, m, d, g, v = t.style;
          for (a in e) c = e[a], o = h[a], o ? i = o.parse(t, c, a, this, i, n, e) : (p = Q(t, a, r) + "", d = "string" == typeof c, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || d && P.test(c) ? (d || (c = le(c), c = (c.length > 3 ? "rgba(" : "rgb(") + c.join(",") + ")"), i = me(v, a, p, c, !0, "transparent", i, 0, n)) : !d || -1 === c.indexOf(" ") && -1 === c.indexOf(",") ? (l = parseFloat(p), f = l || 0 === l ? p.substr((l + "").length) : "", ("" === p || "auto" === p) && ("width" === a || "height" === a ? (l = ie(t, a, r), f = "px") : "left" === a || "top" === a ? (l = H(t, a, r), f = "px") : (l = "opacity" !== a ? 0 : 1, f = "")), g = d && "=" === c.charAt(1), g ? (u = parseInt(c.charAt(0) + "1", 10), c = c.substr(2), u *= parseFloat(c), m = c.replace(T, "")) : (u = parseFloat(c), m = d ? c.substr((u + "").length) || "" : ""), "" === m && (m = a in s ? s[a] : f), c = u || 0 === u ? (g ? u + l : u) + m : e[a], f !== m && "" !== m && (u || 0 === u) && l && (l = $(t, a, l, f), "%" === m ? (l /= $(t, a, 100, "%") / 100, e.strictUnits !== !0 && (p = l + "%")) : "em" === m ? l /= $(t, a, 1, "em") : "px" !== m && (u = $(t, a, u, m), m = "px"), g && (u || 0 === u) && (c = u + l + m)), g && (u += l), !l && 0 !== l || !u && 0 !== u ? void 0 !== v[a] && (c || "NaN" != c + "" && null != c) ? (i = new fe(v, a, u || l || 0, 0, i, -1, a, !1, 0, p, c), i.xs0 = "none" !== c || "display" !== a && -1 === a.indexOf("Style") ? c : p) : q("invalid " + a + " tween value: " + e[a]) : (i = new fe(v, a, l, u - l, i, 0, a, _ !== !1 && ("px" === m || "zIndex" === a), 0, p, c), i.xs0 = m)) : i = me(v, a, p, c, !0, null, i, 0, n)), n && i && !i.plugin && (i.plugin = n);
          return i
        }, l.setRatio = function(t) {
          var e, i, s, r = this._firstPT,
            n = 1e-6;
          if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
            if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
              for (; r;) {
                if (e = r.c * t + r.s, r.r ? e = Math.round(e) : n > e && e > -n && (e = 0), r.type)
                  if (1 === r.type)
                    if (s = r.l, 2 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2;
                    else if (3 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                else if (4 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                else if (5 === s) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                else {
                  for (i = r.xs0 + e + r.xs1, s = 1; r.l > s; s++) i += r["xn" + s] + r["xs" + (s + 1)];
                  r.t[r.p] = i
                } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t);
                else r.t[r.p] = e + r.xs0;
                r = r._next
              } else
                for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next;
            else
              for (; r;) 2 !== r.type ? r.t[r.p] = r.e : r.setRatio(t), r = r._next
        }, l._enableTransforms = function(t) {
          this._transform = this._transform || Me(this._target, r, !0), this._transformType = this._transform.svg && Te || !t && 3 !== this._transformType ? 2 : 3
        };
        var Ue = function() {
          this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
        };
        l._addLazySet = function(t, e, i) {
          var s = this._firstPT = new fe(t, e, 0, 0, this._firstPT, 2);
          s.e = i, s.setRatio = Ue, s.data = this
        }, l._linkCSSP = function(t, e, i, s) {
          return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, s = !0), i ? i._next = t : s || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
        }, l._kill = function(e) {
          var i, s, r, n = e;
          if (e.autoAlpha || e.alpha) {
            n = {};
            for (s in e) n[s] = e[s];
            n.opacity = 1, n.autoAlpha && (n.visibility = 1)
          }
          return e.className && (i = this._classNamePT) && (r = i.xfirst, r && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), t.prototype._kill.call(this, n)
        };
        var Ye = function(t, e, i) {
          var s, r, n, a;
          if (t.slice)
            for (r = t.length; --r > -1;) Ye(t[r], e, i);
          else
            for (s = t.childNodes, r = s.length; --r > -1;) n = s[r], a = n.type, n.style && (e.push(K(n)), i && i.push(n)), 1 !== a && 9 !== a && 11 !== a || !n.childNodes.length || Ye(n, e, i)
        };
        return a.cascadeTo = function(t, i, s) {
          var r, n, a, o = e.to(t, i, s),
            h = [o],
            l = [],
            _ = [],
            u = [],
            p = e._internals.reservedProps;
          for (t = o._targets || o.target, Ye(t, l, u), o.render(i, !0), Ye(t, _), o.render(0, !0), o._enabled(!0), r = u.length; --r > -1;)
            if (n = J(u[r], l[r], _[r]), n.firstMPT) {
              n = n.difs;
              for (a in s) p[a] && (n[a] = s[a]);
              h.push(e.to(u[r], i, n))
            }
          return h
        }, t.activate([a]), a
      }, !0),
      function() {
        var t = _gsScope._gsDefine.plugin({
            propName: "roundProps",
            priority: -1,
            API: 2,
            init: function(t, e, i) {
              return this._tween = i, !0
            }
          }),
          e = t.prototype;
        e._onInitAllProps = function() {
          for (var t, e, i, s = this._tween, r = s.vars.roundProps instanceof Array ? s.vars.roundProps : s.vars.roundProps.split(","), n = r.length, a = {}, o = s._propLookup.roundProps; --n > -1;) a[r[n]] = 1;
          for (n = r.length; --n > -1;)
            for (t = r[n], e = s._firstPT; e;) i = e._next, e.pg ? e.t._roundProps(a, !0) : e.n === t && (this._add(e.t, t, e.s, e.c), i && (i._prev = e._prev), e._prev ? e._prev._next = i : s._firstPT === e && (s._firstPT = i), e._next = e._prev = null, s._propLookup[t] = o), e = i;
          return !1
        }, e._add = function(t, e, i, s) {
          this._addTween(t, e, i, i + s, e, !0), this._overwriteProps.push(e)
        }
      }(), _gsScope._gsDefine.plugin({
        propName: "attr",
        API: 2,
        version: "0.3.3",
        init: function(t, e) {
          var i, s, r;
          if ("function" != typeof t.setAttribute) return !1;
          this._target = t, this._proxy = {}, this._start = {}, this._end = {};
          for (i in e) this._start[i] = this._proxy[i] = s = t.getAttribute(i), r = this._addTween(this._proxy, i, parseFloat(s), e[i], i), this._end[i] = r ? r.s + r.c : e[i], this._overwriteProps.push(i);
          return !0
        },
        set: function(t) {
          this._super.setRatio.call(this, t);
          for (var e, i = this._overwriteProps, s = i.length, r = 1 === t ? this._end : t ? this._proxy : this._start; --s > -1;) e = i[s], this._target.setAttribute(e, r[e] + "")
        }
      }), _gsScope._gsDefine.plugin({
        propName: "directionalRotation",
        version: "0.2.1",
        API: 2,
        init: function(t, e) {
          "object" != typeof e && (e = {
            rotation: e
          }), this.finals = {};
          var i, s, r, n, a, o, h = e.useRadians === !0 ? 2 * Math.PI : 360,
            l = 1e-6;
          for (i in e) "useRadians" !== i && (o = (e[i] + "").split("_"), s = o[0], r = parseFloat("function" != typeof t[i] ? t[i] : t[i.indexOf("set") || "function" != typeof t["get" + i.substr(3)] ? i : "get" + i.substr(3)]()), n = this.finals[i] = "string" == typeof s && "=" === s.charAt(1) ? r + parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2)) : Number(s) || 0, a = n - r, o.length && (s = o.join("_"), -1 !== s.indexOf("short") && (a %= h, a !== a % (h / 2) && (a = 0 > a ? a + h : a - h)), -1 !== s.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * h) % h - (0 | a / h) * h : -1 !== s.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * h) % h - (0 | a / h) * h)), (a > l || -l > a) && (this._addTween(t, i, r, r + a, i), this._overwriteProps.push(i)));
          return !0
        },
        set: function(t) {
          var e;
          if (1 !== t) this._super.setRatio.call(this, t);
          else
            for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
        }
      })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(t) {
        var e, i, s, r = _gsScope.GreenSockGlobals || _gsScope,
          n = r.com.greensock,
          a = 2 * Math.PI,
          o = Math.PI / 2,
          h = n._class,
          l = function(e, i) {
            var s = h("easing." + e, function() {}, !0),
              r = s.prototype = new t;
            return r.constructor = s, r.getRatio = i, s
          },
          _ = t.register || function() {},
          u = function(t, e, i, s) {
            var r = h("easing." + t, {
              easeOut: new e,
              easeIn: new i,
              easeInOut: new s
            }, !0);
            return _(r, t), r
          },
          p = function(t, e, i) {
            this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
          },
          c = function(e, i) {
            var s = h("easing." + e, function(t) {
                this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
              }, !0),
              r = s.prototype = new t;
            return r.constructor = s, r.getRatio = i, r.config = function(t) {
              return new s(t)
            }, s
          },
          f = u("Back", c("BackOut", function(t) {
            return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
          }), c("BackIn", function(t) {
            return t * t * ((this._p1 + 1) * t - this._p1)
          }), c("BackInOut", function(t) {
            return 1 > (t *= 2) ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
          })),
          m = h("easing.SlowMo", function(t, e, i) {
            e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0
          }, !0),
          d = m.prototype = new t;
        return d.constructor = m, d.getRatio = function(t) {
          var e = t + (.5 - t) * this._p;
          return this._p1 > t ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
        }, m.ease = new m(.7, .7), d.config = m.config = function(t, e, i) {
          return new m(t, e, i)
        }, e = h("easing.SteppedEase", function(t) {
          t = t || 1, this._p1 = 1 / t, this._p2 = t + 1
        }, !0), d = e.prototype = new t, d.constructor = e, d.getRatio = function(t) {
          return 0 > t ? t = 0 : t >= 1 && (t = .999999999), (this._p2 * t >> 0) * this._p1
        }, d.config = e.config = function(t) {
          return new e(t)
        }, i = h("easing.RoughEase", function(e) {
          e = e || {};
          for (var i, s, r, n, a, o, h = e.taper || "none", l = [], _ = 0, u = 0 | (e.points || 20), c = u, f = e.randomize !== !1, m = e.clamp === !0, d = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --c > -1;) i = f ? Math.random() : 1 / u * c, s = d ? d.getRatio(i) : i, "none" === h ? r = g : "out" === h ? (n = 1 - i, r = n * n * g) : "in" === h ? r = i * i * g : .5 > i ? (n = 2 * i, r = .5 * n * n * g) : (n = 2 * (1 - i), r = .5 * n * n * g), f ? s += Math.random() * r - .5 * r : c % 2 ? s += .5 * r : s -= .5 * r, m && (s > 1 ? s = 1 : 0 > s && (s = 0)), l[_++] = {
            x: i,
            y: s
          };
          for (l.sort(function(t, e) {
              return t.x - e.x
            }), o = new p(1, 1, null), c = u; --c > -1;) a = l[c], o = new p(a.x, a.y, o);
          this._prev = new p(0, 0, 0 !== o.t ? o : o.next)
        }, !0), d = i.prototype = new t, d.constructor = i, d.getRatio = function(t) {
          var e = this._prev;
          if (t > e.t) {
            for (; e.next && t >= e.t;) e = e.next;
            e = e.prev
          } else
            for (; e.prev && e.t >= t;) e = e.prev;
          return this._prev = e, e.v + (t - e.t) / e.gap * e.c
        }, d.config = function(t) {
          return new i(t)
        }, i.ease = new i, u("Bounce", l("BounceOut", function(t) {
          return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
        }), l("BounceIn", function(t) {
          return 1 / 2.75 > (t = 1 - t) ? 1 - 7.5625 * t * t : 2 / 2.75 > t ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
        }), l("BounceInOut", function(t) {
          var e = .5 > t;
          return t = e ? 1 - 2 * t : 2 * t - 1, t = 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
        })), u("Circ", l("CircOut", function(t) {
          return Math.sqrt(1 - (t -= 1) * t)
        }), l("CircIn", function(t) {
          return -(Math.sqrt(1 - t * t) - 1)
        }), l("CircInOut", function(t) {
          return 1 > (t *= 2) ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
        })), s = function(e, i, s) {
          var r = h("easing." + e, function(t, e) {
              this._p1 = t || 1, this._p2 = e || s, this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0)
            }, !0),
            n = r.prototype = new t;
          return n.constructor = r, n.getRatio = i, n.config = function(t, e) {
            return new r(t, e)
          }, r
        }, u("Elastic", s("ElasticOut", function(t) {
          return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * a / this._p2) + 1
        }, .3), s("ElasticIn", function(t) {
          return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2))
        }, .3), s("ElasticInOut", function(t) {
          return 1 > (t *= 2) ? -.5 * this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) : .5 * this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) + 1
        }, .45)), u("Expo", l("ExpoOut", function(t) {
          return 1 - Math.pow(2, -10 * t)
        }), l("ExpoIn", function(t) {
          return Math.pow(2, 10 * (t - 1)) - .001
        }), l("ExpoInOut", function(t) {
          return 1 > (t *= 2) ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
        })), u("Sine", l("SineOut", function(t) {
          return Math.sin(t * o)
        }), l("SineIn", function(t) {
          return -Math.cos(t * o) + 1
        }), l("SineInOut", function(t) {
          return -.5 * (Math.cos(Math.PI * t) - 1)
        })), h("easing.EaseLookup", {
          find: function(e) {
            return t.map[e]
          }
        }, !0), _(r.SlowMo, "SlowMo", "ease,"), _(i, "RoughEase", "ease,"), _(e, "SteppedEase", "ease,"), f
      }, !0)
  }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
  function(t, e) {
    "use strict";
    var i = t.GreenSockGlobals = t.GreenSockGlobals || t;
    if (!i.TweenLite) {
      var s, r, n, a, o, h = function(t) {
          var e, s = t.split("."),
            r = i;
          for (e = 0; s.length > e; e++) r[s[e]] = r = r[s[e]] || {};
          return r
        },
        l = h("com.greensock"),
        _ = 1e-10,
        u = function(t) {
          var e, i = [],
            s = t.length;
          for (e = 0; e !== s; i.push(t[e++]));
          return i
        },
        p = function() {},
        c = function() {
          var t = Object.prototype.toString,
            e = t.call([]);
          return function(i) {
            return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
          }
        }(),
        f = {},
        m = function(s, r, n, a) {
          this.sc = f[s] ? f[s].sc : [], f[s] = this, this.gsClass = null, this.func = n;
          var o = [];
          this.check = function(l) {
            for (var _, u, p, c, d = r.length, g = d; --d > -1;)(_ = f[r[d]] || new m(r[d], [])).gsClass ? (o[d] = _.gsClass, g--) : l && _.sc.push(this);
            if (0 === g && n)
              for (u = ("com.greensock." + s).split("."), p = u.pop(), c = h(u.join("."))[p] = this.gsClass = n.apply(n, o), a && (i[p] = c, "function" == typeof define && define.amd ? define((t.GreenSockAMDPath ? t.GreenSockAMDPath + "/" : "") + s.split(".").pop(), [], function() {
                  return c
                }) : s === e && "undefined" != typeof module && module.exports && (module.exports = c)), d = 0; this.sc.length > d; d++) this.sc[d].check()
          }, this.check(!0)
        },
        d = t._gsDefine = function(t, e, i, s) {
          return new m(t, e, i, s)
        },
        g = l._class = function(t, e, i) {
          return e = e || function() {}, d(t, [], function() {
            return e
          }, i), e
        };
      d.globals = i;
      var v = [0, 0, 1, 1],
        y = [],
        T = g("easing.Ease", function(t, e, i, s) {
          this._func = t, this._type = i || 0, this._power = s || 0, this._params = e ? v.concat(e) : v
        }, !0),
        w = T.map = {},
        x = T.register = function(t, e, i, s) {
          for (var r, n, a, o, h = e.split(","), _ = h.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --_ > -1;)
            for (n = h[_], r = s ? g("easing." + n, null, !0) : l.easing[n] || {}, a = u.length; --a > -1;) o = u[a], w[n + "." + o] = w[o + n] = r[o] = t.getRatio ? t : t[o] || new t
        };
      for (n = T.prototype, n._calcEnd = !1, n.getRatio = function(t) {
          if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
          var e = this._type,
            i = this._power,
            s = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t);
          return 1 === i ? s *= s : 2 === i ? s *= s * s : 3 === i ? s *= s * s * s : 4 === i && (s *= s * s * s * s), 1 === e ? 1 - s : 2 === e ? s : .5 > t ? s / 2 : 1 - s / 2
        }, s = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], r = s.length; --r > -1;) n = s[r] + ",Power" + r, x(new T(null, null, 1, r), n, "easeOut", !0), x(new T(null, null, 2, r), n, "easeIn" + (0 === r ? ",easeNone" : "")), x(new T(null, null, 3, r), n, "easeInOut");
      w.linear = l.easing.Linear.easeIn, w.swing = l.easing.Quad.easeInOut;
      var b = g("events.EventDispatcher", function(t) {
        this._listeners = {}, this._eventTarget = t || this
      });
      n = b.prototype, n.addEventListener = function(t, e, i, s, r) {
        r = r || 0;
        var n, h, l = this._listeners[t],
          _ = 0;
        for (null == l && (this._listeners[t] = l = []), h = l.length; --h > -1;) n = l[h], n.c === e && n.s === i ? l.splice(h, 1) : 0 === _ && r > n.pr && (_ = h + 1);
        l.splice(_, 0, {
          c: e,
          s: i,
          up: s,
          pr: r
        }), this !== a || o || a.wake()
      }, n.removeEventListener = function(t, e) {
        var i, s = this._listeners[t];
        if (s)
          for (i = s.length; --i > -1;)
            if (s[i].c === e) return s.splice(i, 1), void 0
      }, n.dispatchEvent = function(t) {
        var e, i, s, r = this._listeners[t];
        if (r)
          for (e = r.length, i = this._eventTarget; --e > -1;) s = r[e], s && (s.up ? s.c.call(s.s || i, {
            type: t,
            target: i
          }) : s.c.call(s.s || i))
      };
      var P = t.requestAnimationFrame,
        S = t.cancelAnimationFrame,
        k = Date.now || function() {
          return (new Date).getTime()
        },
        R = k();
      for (s = ["ms", "moz", "webkit", "o"], r = s.length; --r > -1 && !P;) P = t[s[r] + "RequestAnimationFrame"], S = t[s[r] + "CancelAnimationFrame"] || t[s[r] + "CancelRequestAnimationFrame"];
      g("Ticker", function(t, e) {
        var i, s, r, n, h, l = this,
          u = k(),
          c = e !== !1 && P,
          f = 500,
          m = 33,
          d = "tick",
          g = function(t) {
            var e, a, o = k() - R;
            o > f && (u += o - m), R += o, l.time = (R - u) / 1e3, e = l.time - h, (!i || e > 0 || t === !0) && (l.frame++, h += e + (e >= n ? .004 : n - e), a = !0), t !== !0 && (r = s(g)), a && l.dispatchEvent(d)
          };
        b.call(l), l.time = l.frame = 0, l.tick = function() {
          g(!0)
        }, l.lagSmoothing = function(t, e) {
          f = t || 1 / _, m = Math.min(e, f, 0)
        }, l.sleep = function() {
          null != r && (c && S ? S(r) : clearTimeout(r), s = p, r = null, l === a && (o = !1))
        }, l.wake = function() {
          null !== r ? l.sleep() : l.frame > 10 && (R = k() - f + 5), s = 0 === i ? p : c && P ? P : function(t) {
            return setTimeout(t, 0 | 1e3 * (h - l.time) + 1)
          }, l === a && (o = !0), g(2)
        }, l.fps = function(t) {
          return arguments.length ? (i = t, n = 1 / (i || 60), h = this.time + n, l.wake(), void 0) : i
        }, l.useRAF = function(t) {
          return arguments.length ? (l.sleep(), c = t, l.fps(i), void 0) : c
        }, l.fps(t), setTimeout(function() {
          c && (!r || 5 > l.frame) && l.useRAF(!1)
        }, 1500)
      }), n = l.Ticker.prototype = new l.events.EventDispatcher, n.constructor = l.Ticker;
      var A = g("core.Animation", function(t, e) {
        if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = e.immediateRender === !0, this.data = e.data, this._reversed = e.reversed === !0, j) {
          o || a.wake();
          var i = this.vars.useFrames ? B : j;
          i.add(this, i._time), this.vars.paused && this.paused(!0)
        }
      });
      a = A.ticker = new l.Ticker, n = A.prototype, n._dirty = n._gc = n._initted = n._paused = !1, n._totalTime = n._time = 0, n._rawPrevTime = -1, n._next = n._last = n._onUpdate = n._timeline = n.timeline = null, n._paused = !1;
      var C = function() {
        o && k() - R > 2e3 && a.wake(), setTimeout(C, 2e3)
      };
      C(), n.play = function(t, e) {
        return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
      }, n.pause = function(t, e) {
        return null != t && this.seek(t, e), this.paused(!0)
      }, n.resume = function(t, e) {
        return null != t && this.seek(t, e), this.paused(!1)
      }, n.seek = function(t, e) {
        return this.totalTime(Number(t), e !== !1)
      }, n.restart = function(t, e) {
        return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0)
      }, n.reverse = function(t, e) {
        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
      }, n.render = function() {}, n.invalidate = function() {
        return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this
      }, n.isActive = function() {
        var t, e = this._timeline,
          i = this._startTime;
        return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime()) >= i && i + this.totalDuration() / this._timeScale > t
      }, n._enabled = function(t, e) {
        return o || a.wake(), this._gc = !t, this._active = this.isActive(), e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
      }, n._kill = function() {
        return this._enabled(!1, !1)
      }, n.kill = function(t, e) {
        return this._kill(t, e), this
      }, n._uncache = function(t) {
        for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
        return this
      }, n._swapSelfInParams = function(t) {
        for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
        return i
      }, n.eventCallback = function(t, e, i, s) {
        if ("on" === (t || "").substr(0, 2)) {
          var r = this.vars;
          if (1 === arguments.length) return r[t];
          null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = c(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = s), "onUpdate" === t && (this._onUpdate = e)
        }
        return this
      }, n.delay = function(t) {
        return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
      }, n.duration = function(t) {
        return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
      }, n.totalDuration = function(t) {
        return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
      }, n.time = function(t, e) {
        return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
      }, n.totalTime = function(t, e, i) {
        if (o || a.wake(), !arguments.length) return this._totalTime;
        if (this._timeline) {
          if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
            this._dirty && this.totalDuration();
            var s = this._totalDuration,
              r = this._timeline;
            if (t > s && !i && (t = s), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? s - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
              for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
          }
          this._gc && this._enabled(!0, !1), (this._totalTime !== t || 0 === this._duration) && (this.render(t, e, !1), I.length && q())
        }
        return this
      }, n.progress = n.totalProgress = function(t, e) {
        return arguments.length ? this.totalTime(this.duration() * t, e) : this._time / this.duration()
      }, n.startTime = function(t) {
        return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
      }, n.endTime = function(t) {
        return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
      }, n.timeScale = function(t) {
        if (!arguments.length) return this._timeScale;
        if (t = t || _, this._timeline && this._timeline.smoothChildTiming) {
          var e = this._pauseTime,
            i = e || 0 === e ? e : this._timeline.totalTime();
          this._startTime = i - (i - this._startTime) * this._timeScale / t
        }
        return this._timeScale = t, this._uncache(!1)
      }, n.reversed = function(t) {
        return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
      }, n.paused = function(t) {
        if (!arguments.length) return this._paused;
        if (t != this._paused && this._timeline) {
          o || t || a.wake();
          var e = this._timeline,
            i = e.rawTime(),
            s = i - this._pauseTime;
          !t && e.smoothChildTiming && (this._startTime += s, this._uncache(!1)), this._pauseTime = t ? i : null, this._paused = t, this._active = this.isActive(), !t && 0 !== s && this._initted && this.duration() && this.render(e.smoothChildTiming ? this._totalTime : (i - this._startTime) / this._timeScale, !0, !0)
        }
        return this._gc && !t && this._enabled(!0, !1), this
      };
      var O = g("core.SimpleTimeline", function(t) {
        A.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
      });
      n = O.prototype = new A, n.constructor = O, n.kill()._gc = !1, n._first = n._last = n._recent = null, n._sortChildren = !1, n.add = n.insert = function(t, e) {
        var i, s;
        if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), i = this._last, this._sortChildren)
          for (s = t._startTime; i && i._startTime > s;) i = i._prev;
        return i ? (t._next = i._next, i._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = i, this._recent = t, this._timeline && this._uncache(!0), this
      }, n._remove = function(t, e) {
        return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
      }, n.render = function(t, e, i) {
        var s, r = this._first;
        for (this._totalTime = this._time = this._rawPrevTime = t; r;) s = r._next, (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = s
      }, n.rawTime = function() {
        return o || a.wake(), this._totalTime
      };
      var D = g("TweenLite", function(e, i, s) {
          if (A.call(this, i, s), this.render = D.prototype.render, null == e) throw "Cannot tween a null target.";
          this.target = e = "string" != typeof e ? e : D.selector(e) || e;
          var r, n, a, o = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
            h = this.vars.overwrite;
          if (this._overwrite = h = null == h ? Y[D.defaultOverwrite] : "number" == typeof h ? h >> 0 : Y[h], (o || e instanceof Array || e.push && c(e)) && "number" != typeof e[0])
            for (this._targets = a = u(e), this._propLookup = [], this._siblings = [], r = 0; a.length > r; r++) n = a[r], n ? "string" != typeof n ? n.length && n !== t && n[0] && (n[0] === t || n[0].nodeType && n[0].style && !n.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(u(n))) : (this._siblings[r] = V(n, this, !1), 1 === h && this._siblings[r].length > 1 && W(n, this, null, 1, this._siblings[r])) : (n = a[r--] = D.selector(n), "string" == typeof n && a.splice(r + 1, 1)) : a.splice(r--, 1);
          else this._propLookup = {}, this._siblings = V(e, this, !1), 1 === h && this._siblings.length > 1 && W(e, this, null, 1, this._siblings);
          (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -_, this.render(-this._delay))
        }, !0),
        M = function(e) {
          return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType)
        },
        z = function(t, e) {
          var i, s = {};
          for (i in t) U[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!N[i] || N[i] && N[i]._autoCSS) || (s[i] = t[i], delete t[i]);
          t.css = s
        };
      n = D.prototype = new A, n.constructor = D, n.kill()._gc = !1, n.ratio = 0, n._firstPT = n._targets = n._overwrittenProps = n._startAt = null, n._notifyPluginsOfEnabled = n._lazy = !1, D.version = "1.15.0", D.defaultEase = n._ease = new T(null, null, 1, 1), D.defaultOverwrite = "auto", D.ticker = a, D.autoSleep = !0, D.lagSmoothing = function(t, e) {
        a.lagSmoothing(t, e)
      }, D.selector = t.$ || t.jQuery || function(e) {
        var i = t.$ || t.jQuery;
        return i ? (D.selector = i, i(e)) : "undefined" == typeof document ? e : document.querySelectorAll ? document.querySelectorAll(e) : document.getElementById("#" === e.charAt(0) ? e.substr(1) : e)
      };
      var I = [],
        E = {},
        F = D._internals = {
          isArray: c,
          isSelector: M,
          lazyTweens: I
        },
        N = D._plugins = {},
        L = F.tweenLookup = {},
        X = 0,
        U = F.reservedProps = {
          ease: 1,
          delay: 1,
          overwrite: 1,
          onComplete: 1,
          onCompleteParams: 1,
          onCompleteScope: 1,
          useFrames: 1,
          runBackwards: 1,
          startAt: 1,
          onUpdate: 1,
          onUpdateParams: 1,
          onUpdateScope: 1,
          onStart: 1,
          onStartParams: 1,
          onStartScope: 1,
          onReverseComplete: 1,
          onReverseCompleteParams: 1,
          onReverseCompleteScope: 1,
          onRepeat: 1,
          onRepeatParams: 1,
          onRepeatScope: 1,
          easeParams: 1,
          yoyo: 1,
          immediateRender: 1,
          repeat: 1,
          repeatDelay: 1,
          data: 1,
          paused: 1,
          reversed: 1,
          autoCSS: 1,
          lazy: 1,
          onOverwrite: 1
        },
        Y = {
          none: 0,
          all: 1,
          auto: 2,
          concurrent: 3,
          allOnStart: 4,
          preexisting: 5,
          "true": 1,
          "false": 0
        },
        B = A._rootFramesTimeline = new O,
        j = A._rootTimeline = new O,
        q = F.lazyRender = function() {
          var t, e = I.length;
          for (E = {}; --e > -1;) t = I[e], t && t._lazy !== !1 && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
          I.length = 0
        };
      j._startTime = a.time, B._startTime = a.frame, j._active = B._active = !0, setTimeout(q, 1), A._updateRoot = D.render = function() {
        var t, e, i;
        if (I.length && q(), j.render((a.time - j._startTime) * j._timeScale, !1, !1), B.render((a.frame - B._startTime) * B._timeScale, !1, !1), I.length && q(), !(a.frame % 120)) {
          for (i in L) {
            for (e = L[i].tweens, t = e.length; --t > -1;) e[t]._gc && e.splice(t, 1);
            0 === e.length && delete L[i]
          }
          if (i = j._first, (!i || i._paused) && D.autoSleep && !B._first && 1 === a._listeners.tick.length) {
            for (; i && i._paused;) i = i._next;
            i || a.sleep()
          }
        }
      }, a.addEventListener("tick", A._updateRoot);
      var V = function(t, e, i) {
          var s, r, n = t._gsTweenID;
          if (L[n || (t._gsTweenID = n = "t" + X++)] || (L[n] = {
              target: t,
              tweens: []
            }), e && (s = L[n].tweens, s[r = s.length] = e, i))
            for (; --r > -1;) s[r] === e && s.splice(r, 1);
          return L[n].tweens
        },
        G = function(t, e, i, s) {
          var r, n, a = t.vars.onOverwrite;
          return a && (r = a(t, e, i, s)), a = D.onOverwrite, a && (n = a(t, e, i, s)), r !== !1 && n !== !1
        },
        W = function(t, e, i, s, r) {
          var n, a, o, h;
          if (1 === s || s >= 4) {
            for (h = r.length, n = 0; h > n; n++)
              if ((o = r[n]) !== e) o._gc || G(o, e) && o._enabled(!1, !1) && (a = !0);
              else if (5 === s) break;
            return a
          }
          var l, u = e._startTime + _,
            p = [],
            c = 0,
            f = 0 === e._duration;
          for (n = r.length; --n > -1;)(o = r[n]) === e || o._gc || o._paused || (o._timeline !== e._timeline ? (l = l || Z(e, 0, f), 0 === Z(o, l, f) && (p[c++] = o)) : u >= o._startTime && o._startTime + o.totalDuration() / o._timeScale > u && ((f || !o._initted) && 2e-10 >= u - o._startTime || (p[c++] = o)));
          for (n = c; --n > -1;)
            if (o = p[n], 2 === s && o._kill(i, t, e) && (a = !0), 2 !== s || !o._firstPT && o._initted) {
              if (2 !== s && !G(o, e)) continue;
              o._enabled(!1, !1) && (a = !0)
            }
          return a
        },
        Z = function(t, e, i) {
          for (var s = t._timeline, r = s._timeScale, n = t._startTime; s._timeline;) {
            if (n += s._startTime, r *= s._timeScale, s._paused) return -100;
            s = s._timeline
          }
          return n /= r, n > e ? n - e : i && n === e || !t._initted && 2 * _ > n - e ? _ : (n += t.totalDuration() / t._timeScale / r) > e + _ ? 0 : n - e - _
        };
      n._init = function() {
        var t, e, i, s, r, n = this.vars,
          a = this._overwrittenProps,
          o = this._duration,
          h = !!n.immediateRender,
          l = n.ease;
        if (n.startAt) {
          this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {};
          for (s in n.startAt) r[s] = n.startAt[s];
          if (r.overwrite = !1, r.immediateRender = !0, r.lazy = h && n.lazy !== !1, r.startAt = r.delay = null, this._startAt = D.to(this.target, 0, r), h)
            if (this._time > 0) this._startAt = null;
            else if (0 !== o) return
        } else if (n.runBackwards && 0 !== o)
          if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
          else {
            0 !== this._time && (h = !1), i = {};
            for (s in n) U[s] && "autoCSS" !== s || (i[s] = n[s]);
            if (i.overwrite = 0, i.data = "isFromStart", i.lazy = h && n.lazy !== !1, i.immediateRender = h, this._startAt = D.to(this.target, 0, i), h) {
              if (0 === this._time) return
            } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
          }
        if (this._ease = l = l ? l instanceof T ? l : "function" == typeof l ? new T(l, n.easeParams) : w[l] || D.defaultEase : D.defaultEase, n.easeParams instanceof Array && l.config && (this._ease = l.config.apply(l, n.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
          for (t = this._targets.length; --t > -1;) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null) && (e = !0);
        else e = this._initProps(this.target, this._propLookup, this._siblings, a);
        if (e && D._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), n.runBackwards)
          for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
        this._onUpdate = n.onUpdate, this._initted = !0
      }, n._initProps = function(e, i, s, r) {
        var n, a, o, h, l, _;
        if (null == e) return !1;
        E[e._gsTweenID] && q(), this.vars.css || e.style && e !== t && e.nodeType && N.css && this.vars.autoCSS !== !1 && z(this.vars, e);
        for (n in this.vars) {
          if (_ = this.vars[n], U[n]) _ && (_ instanceof Array || _.push && c(_)) && -1 !== _.join("").indexOf("{self}") && (this.vars[n] = _ = this._swapSelfInParams(_, this));
          else if (N[n] && (h = new N[n])._onInitTween(e, this.vars[n], this)) {
            for (this._firstPT = l = {
                _next: this._firstPT,
                t: h,
                p: "setRatio",
                s: 0,
                c: 1,
                f: !0,
                n: n,
                pg: !0,
                pr: h._priority
              }, a = h._overwriteProps.length; --a > -1;) i[h._overwriteProps[a]] = this._firstPT;
            (h._priority || h._onInitAllProps) && (o = !0), (h._onDisable || h._onEnable) && (this._notifyPluginsOfEnabled = !0)
          } else this._firstPT = i[n] = l = {
            _next: this._firstPT,
            t: e,
            p: n,
            f: "function" == typeof e[n],
            n: n,
            pg: !1,
            pr: 0
          }, l.s = l.f ? e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(e[n]), l.c = "string" == typeof _ && "=" === _.charAt(1) ? parseInt(_.charAt(0) + "1", 10) * Number(_.substr(2)) : Number(_) - l.s || 0;
          l && l._next && (l._next._prev = l)
        }
        return r && this._kill(r, e) ? this._initProps(e, i, s, r) : this._overwrite > 1 && this._firstPT && s.length > 1 && W(e, this, i, this._overwrite, s) ? (this._kill(i, e), this._initProps(e, i, s, r)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (E[e._gsTweenID] = !0), o)
      }, n.render = function(t, e, i) {
        var s, r, n, a, o = this._time,
          h = this._duration,
          l = this._rawPrevTime;
        if (t >= h) this._totalTime = this._time = h, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (s = !0, r = "onComplete"), 0 === h && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (0 === t || 0 > l || l === _ && "isPause" !== this.data) && l !== t && (i = !0, l > _ && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || l === t ? t : _);
        else if (1e-7 > t) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== o || 0 === h && l > 0 && l !== _) && (r = "onReverseComplete", s = this._reversed), 0 > t && (this._active = !1, 0 === h && (this._initted || !this.vars.lazy || i) && (l >= 0 && (l !== _ || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !e || t || l === t ? t : _)), this._initted || (i = !0);
        else if (this._totalTime = this._time = t, this._easeType) {
          var u = t / h,
            p = this._easeType,
            c = this._easePower;
          (1 === p || 3 === p && u >= .5) && (u = 1 - u), 3 === p && (u *= 2), 1 === c ? u *= u : 2 === c ? u *= u * u : 3 === c ? u *= u * u * u : 4 === c && (u *= u * u * u * u), this.ratio = 1 === p ? 1 - u : 2 === p ? u : .5 > t / h ? u / 2 : 1 - u / 2
        } else this.ratio = this._ease.getRatio(t / h);
        if (this._time !== o || i) {
          if (!this._initted) {
            if (this._init(), !this._initted || this._gc) return;
            if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = o, this._rawPrevTime = l, I.push(this), this._lazy = [t, e], void 0;
            this._time && !s ? this.ratio = this._ease.getRatio(this._time / h) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
          }
          for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== o && t >= 0 && (this._active = !0), 0 === o && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === h) && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || y))), n = this._firstPT; n;) n.f ? n.t[n.p](n.c * this.ratio + n.s) : n.t[n.p] = n.c * this.ratio + n.s, n = n._next;
          this._onUpdate && (0 > t && this._startAt && t !== -1e-4 && this._startAt.render(t, e, i), e || (this._time !== o || s) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || y)), r && (!this._gc || i) && (0 > t && this._startAt && !this._onUpdate && t !== -1e-4 && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this.vars[r].apply(this.vars[r + "Scope"] || this, this.vars[r + "Params"] || y), 0 === h && this._rawPrevTime === _ && a !== _ && (this._rawPrevTime = 0))
        }
      }, n._kill = function(t, e, i) {
        if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
        e = "string" != typeof e ? e || this._targets || this.target : D.selector(e) || e;
        var s, r, n, a, o, h, l, _, u;
        if ((c(e) || M(e)) && "number" != typeof e[0])
          for (s = e.length; --s > -1;) this._kill(t, e[s]) && (h = !0);
        else {
          if (this._targets) {
            for (s = this._targets.length; --s > -1;)
              if (e === this._targets[s]) {
                o = this._propLookup[s] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[s] = t ? this._overwrittenProps[s] || {} : "all";
                break
              }
          } else {
            if (e !== this.target) return !1;
            o = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
          }
          if (o) {
            if (l = t || o, _ = t !== r && "all" !== r && t !== o && ("object" != typeof t || !t._tempKill), i && (D.onOverwrite || this.vars.onOverwrite)) {
              for (n in l) o[n] && (u || (u = []), u.push(n));
              if (!G(this, i, e, u)) return !1
            }
            for (n in l)(a = o[n]) && (a.pg && a.t._kill(l) && (h = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete o[n]), _ && (r[n] = 1);
            !this._firstPT && this._initted && this._enabled(!1, !1)
          }
        }
        return h
      }, n.invalidate = function() {
        return this._notifyPluginsOfEnabled && D._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], A.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -_, this.render(-this._delay)), this
      }, n._enabled = function(t, e) {
        if (o || a.wake(), t && this._gc) {
          var i, s = this._targets;
          if (s)
            for (i = s.length; --i > -1;) this._siblings[i] = V(s[i], this, !0);
          else this._siblings = V(this.target, this, !0)
        }
        return A.prototype._enabled.call(this, t, e), this._notifyPluginsOfEnabled && this._firstPT ? D._onPluginEvent(t ? "_onEnable" : "_onDisable", this) : !1
      }, D.to = function(t, e, i) {
        return new D(t, e, i)
      }, D.from = function(t, e, i) {
        return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new D(t, e, i)
      }, D.fromTo = function(t, e, i, s) {
        return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new D(t, e, s)
      }, D.delayedCall = function(t, e, i, s, r) {
        return new D(e, 0, {
          delay: t,
          onComplete: e,
          onCompleteParams: i,
          onCompleteScope: s,
          onReverseComplete: e,
          onReverseCompleteParams: i,
          onReverseCompleteScope: s,
          immediateRender: !1,
          lazy: !1,
          useFrames: r,
          overwrite: 0
        })
      }, D.set = function(t, e) {
        return new D(t, 0, e)
      }, D.getTweensOf = function(t, e) {
        if (null == t) return [];
        t = "string" != typeof t ? t : D.selector(t) || t;
        var i, s, r, n;
        if ((c(t) || M(t)) && "number" != typeof t[0]) {
          for (i = t.length, s = []; --i > -1;) s = s.concat(D.getTweensOf(t[i], e));
          for (i = s.length; --i > -1;)
            for (n = s[i], r = i; --r > -1;) n === s[r] && s.splice(i, 1)
        } else
          for (s = V(t).concat(), i = s.length; --i > -1;)(s[i]._gc || e && !s[i].isActive()) && s.splice(i, 1);
        return s
      }, D.killTweensOf = D.killDelayedCallsTo = function(t, e, i) {
        "object" == typeof e && (i = e, e = !1);
        for (var s = D.getTweensOf(t, e), r = s.length; --r > -1;) s[r]._kill(i, t)
      };
      var Q = g("plugins.TweenPlugin", function(t, e) {
        this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = Q.prototype
      }, !0);
      if (n = Q.prototype, Q.version = "1.10.1", Q.API = 2, n._firstPT = null, n._addTween = function(t, e, i, s, r, n) {
          var a, o;
          return null != s && (a = "number" == typeof s || "=" !== s.charAt(1) ? Number(s) - i : parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2))) ? (this._firstPT = o = {
            _next: this._firstPT,
            t: t,
            p: e,
            s: i,
            c: a,
            f: "function" == typeof t[e],
            n: r || e,
            r: n
          }, o._next && (o._next._prev = o), o) : void 0
        }, n.setRatio = function(t) {
          for (var e, i = this._firstPT, s = 1e-6; i;) e = i.c * t + i.s, i.r ? e = Math.round(e) : s > e && e > -s && (e = 0), i.f ? i.t[i.p](e) : i.t[i.p] = e, i = i._next
        }, n._kill = function(t) {
          var e, i = this._overwriteProps,
            s = this._firstPT;
          if (null != t[this._propName]) this._overwriteProps = [];
          else
            for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
          for (; s;) null != t[s.n] && (s._next && (s._next._prev = s._prev), s._prev ? (s._prev._next = s._next, s._prev = null) : this._firstPT === s && (this._firstPT = s._next)), s = s._next;
          return !1
        }, n._roundProps = function(t, e) {
          for (var i = this._firstPT; i;)(t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && (i.r = e), i = i._next
        }, D._onPluginEvent = function(t, e) {
          var i, s, r, n, a, o = e._firstPT;
          if ("_onInitAllProps" === t) {
            for (; o;) {
              for (a = o._next, s = r; s && s.pr > o.pr;) s = s._next;
              (o._prev = s ? s._prev : n) ? o._prev._next = o: r = o, (o._next = s) ? s._prev = o : n = o, o = a
            }
            o = e._firstPT = r
          }
          for (; o;) o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next;
          return i
        }, Q.activate = function(t) {
          for (var e = t.length; --e > -1;) t[e].API === Q.API && (N[(new t[e])._propName] = t[e]);
          return !0
        }, d.plugin = function(t) {
          if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
          var e, i = t.propName,
            s = t.priority || 0,
            r = t.overwriteProps,
            n = {
              init: "_onInitTween",
              set: "setRatio",
              kill: "_kill",
              round: "_roundProps",
              initAll: "_onInitAllProps"
            },
            a = g("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
              Q.call(this, i, s), this._overwriteProps = r || []
            }, t.global === !0),
            o = a.prototype = new Q(i);
          o.constructor = a, a.API = t.API;
          for (e in n) "function" == typeof t[e] && (o[n[e]] = t[e]);
          return a.version = t.version, Q.activate([a]), a
        }, s = t._gsQueue) {
        for (r = 0; s.length > r; r++) s[r]();
        for (n in f) f[n].func || t.console.log("GSAP encountered missing dependency: com.greensock." + n)
      }
      o = !1
    }
  }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenMax");

//periodicalupdater
! function(o) {
  o.PeriodicalUpdater = function(e, a, t) {
    a || (a = {});
    var i = jQuery.extend(!0, {
        url: e,
        cache: !1,
        method: "GET",
        data: "",
        minTimeout: 1e3,
        maxTimeout: 64e3,
        multiplier: 2,
        maxCalls: 0,
        maxCallsCallback: null,
        autoStop: 0,
        autoStopCallback: null,
        cookie: !1,
        runatonce: !1,
        verbose: 0
      }, a),
      n = function(o, e) {
        if (e = e || 1, i.verbose >= e) try {
          console.log(o)
        } catch (a) {}
      },
      c = null,
      l = null,
      r = null,
      u = i.minTimeout,
      s = i.maxCalls,
      m = i.autoStop,
      d = 0,
      k = 0,
      f = s,
      p = function(e) {
        o(function() {
          null !== c && clearTimeout(c), u = e, n("resetting timer to " + u + ".", 2), i.cookie && o.cookie && o.cookie(i.cookie.name, u, i.cookie), c = setTimeout(g, u)
        })
      },
      y = function() {
        if (i.multiplier > 1) {
          var o = u;
          u *= i.multiplier, u > i.maxTimeout && (u = i.maxTimeout), n("adjusting timer from " + o + " to " + u + ".", 2)
        }
        p(u)
      };
    i.cookie && ("boolean" == typeof i.cookie ? i.cookie = {
      name: e
    } : "object" != typeof i.cookie && (i.cookie = {
      name: i.cookie.toString()
    }), i.cookie.name || (i.cookie.name = e), o.cookie ? o.cookie(i.cookie.name) && p(o.cookie(i.cookie.name)) : o.getScript("//rawgit.com/carhartl/jquery-cookie/master/jquery.cookie.js", function() {
      n("Loaded the cookies handler script", 2), o.cookie(i.cookie.name) ? (n("Not runatonce and have cookie value", 2), p(o.cookie(i.cookie.name))) : (n("Not runatonce, but no cookie value", 2), p(u))
    }).fail(function() {
      n("Could not load the cookies handler script", 1), p(u)
    }));
    var b = jQuery.extend(!0, {}, i);
    i.type && !b.dataType && (b.dataType = i.type), i.sendData && (b.data = i.sendData), b.type = i.method, b.ifModified = !0;
    var g = function(e) {
        var t = jQuery.extend(!0, {}, b);
        "function" == typeof a.data && (t.data = a.data()), t.data && "number" == typeof t.data && (t.data = t.data.toString()), e || 0 === s ? (n("Sending data"), o(function() {
          o.ajax(t)
        })) : s > 0 && s > d ? (n("Sending data because we are at " + d + " of " + s + " calls"), o(function() {
          o.ajax(t)
        }), d++) : -1 == s ? n("NOT sending data: stop has been called", 1) : (n("NOT sending data: maximum number of calls reached - " + s, 1), i.maxCallsCallback && i.maxCallsCallback())
      },
      x = {
        boostTimer: function(o) {
          o > 0 && 1 != o ? (n("Boosting timer by a factor of " + o), u *= o) : n("Cannot boost timer by a factor of " + o), p(u)
        },
        restart: function(o) {
          n("Calling restart"), s = f, d = 0, k = 0, p(o || u)
        },
        send: function() {
          n("Explicit call to send"), g(!0)
        },
        stop: function() {
          n("Calling stop"), s = -1, i.cookie && o.cookie && o.cookie(i.cookie.name, null, i.cookie)
        }
      };
    return b.success = function(o) {
      n("Successful run! (In 'success')", 2), l = o
    }, b.complete = function(e, a) {
      if (n("Status of call: " + a + " (In 'complete')", 2), "success" == a || "notmodified" == a) {
        var c = o.trim(e.responseText);
        if (r == c) {
          if (m > 0 && (k++, k == m)) return x.stop(), void(i.autoStopCallback && i.autoStopCallback(k));
          y()
        } else k = 0, p(i.minTimeout), r = c, i.cookie && o.cookie(i.cookie.name, r, i.cookie), null === l && (l = c), "json" === b.dataType && "string" == typeof l && "success" == a && (l = JSON.parse(l)), i.success && i.success(l, a, e, x), t && t(l, a, e, x)
      }
      i.complete && i.complete(e, a), l = null
    }, b.error = function(e, a) {
      n("Error message: " + a + " (In 'error')", 2), "notmodified" != a && (r = null, i.cookie && o.cookie(i.cookie.name, null, i.cookie), p(i.minTimeout)), i.error && i.error(e, a)
    }, i.runatonce ? (n("Executing a call immediately", 1), g(!0)) : o.cookie && i.cookie && o.cookie(i.cookie.name) || (n("Enqueing a the call for after " + u, 1), p(u)), x
  }, o.fn.PeriodicalUpdater = function(e, a, t) {
    var i = this;
    return o.PeriodicalUpdater(e, a, function() {
      return t.apply(i, arguments)
    })
  }
}(jQuery);

/* == jquery mousewheel plugin == Version: 3.1.12, License: MIT License (MIT) */
! function(a) {
  "function" == typeof define && define.amd ? define(["jquery"], a) : "object" == typeof exports ? module.exports = a : a(jQuery)
}(function(a) {
  function b(b) {
    var g = b || window.event,
      h = i.call(arguments, 1),
      j = 0,
      l = 0,
      m = 0,
      n = 0,
      o = 0,
      p = 0;
    if (b = a.event.fix(g), b.type = "mousewheel", "detail" in g && (m = -1 * g.detail), "wheelDelta" in g && (m = g.wheelDelta), "wheelDeltaY" in g && (m = g.wheelDeltaY), "wheelDeltaX" in g && (l = -1 * g.wheelDeltaX), "axis" in g && g.axis === g.HORIZONTAL_AXIS && (l = -1 * m, m = 0), j = 0 === m ? l : m, "deltaY" in g && (m = -1 * g.deltaY, j = m), "deltaX" in g && (l = g.deltaX, 0 === m && (j = -1 * l)), 0 !== m || 0 !== l) {
      if (1 === g.deltaMode) {
        var q = a.data(this, "mousewheel-line-height");
        j *= q, m *= q, l *= q
      } else if (2 === g.deltaMode) {
        var r = a.data(this, "mousewheel-page-height");
        j *= r, m *= r, l *= r
      }
      if (n = Math.max(Math.abs(m), Math.abs(l)), (!f || f > n) && (f = n, d(g, n) && (f /= 40)), d(g, n) && (j /= 40, l /= 40, m /= 40), j = Math[j >= 1 ? "floor" : "ceil"](j / f), l = Math[l >= 1 ? "floor" : "ceil"](l / f), m = Math[m >= 1 ? "floor" : "ceil"](m / f), k.settings.normalizeOffset && this.getBoundingClientRect) {
        var s = this.getBoundingClientRect();
        o = b.clientX - s.left, p = b.clientY - s.top
      }
      return b.deltaX = l, b.deltaY = m, b.deltaFactor = f, b.offsetX = o, b.offsetY = p, b.deltaMode = 0, h.unshift(b, j, l, m), e && clearTimeout(e), e = setTimeout(c, 200), (a.event.dispatch || a.event.handle).apply(this, h)
    }
  }

  function c() {
    f = null
  }

  function d(a, b) {
    return k.settings.adjustOldDeltas && "mousewheel" === a.type && b % 120 === 0
  }
  var e, f, g = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
    h = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
    i = Array.prototype.slice;
  if (a.event.fixHooks)
    for (var j = g.length; j;) a.event.fixHooks[g[--j]] = a.event.mouseHooks;
  var k = a.event.special.mousewheel = {
    version: "3.1.12",
    setup: function() {
      if (this.addEventListener)
        for (var c = h.length; c;) this.addEventListener(h[--c], b, !1);
      else this.onmousewheel = b;
      a.data(this, "mousewheel-line-height", k.getLineHeight(this)), a.data(this, "mousewheel-page-height", k.getPageHeight(this))
    },
    teardown: function() {
      if (this.removeEventListener)
        for (var c = h.length; c;) this.removeEventListener(h[--c], b, !1);
      else this.onmousewheel = null;
      a.removeData(this, "mousewheel-line-height"), a.removeData(this, "mousewheel-page-height")
    },
    getLineHeight: function(b) {
      var c = a(b),
        d = c["offsetParent" in a.fn ? "offsetParent" : "parent"]();
      return d.length || (d = a("body")), parseInt(d.css("fontSize"), 10) || parseInt(c.css("fontSize"), 10) || 16
    },
    getPageHeight: function(b) {
      return a(b).height()
    },
    settings: {
      adjustOldDeltas: !0,
      normalizeOffset: !0
    }
  };
  a.fn.extend({
    mousewheel: function(a) {
      return a ? this.bind("mousewheel", a) : this.trigger("mousewheel")
    },
    unmousewheel: function(a) {
      return this.unbind("mousewheel", a)
    }
  })
});
/* == malihu jquery custom scrollbar plugin == Version: 3.0.8, License: MIT License (MIT) */
! function(e) {
  "undefined" != typeof module && module.exports ? module.exports = e : e(jQuery, window, document)
}(function(e) {
  ! function(t) {
    var o = "function" == typeof define && define.amd,
      a = "undefined" != typeof module && module.exports,
      n = "https:" == document.location.protocol ? "https:" : "http:",
      i = "cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.12/jquery.mousewheel.min.js";
    o || (a ? require("jquery-mousewheel")(e) : e.event.special.mousewheel || e("head").append(decodeURI("%3Cscript src=" + n + "//" + i + "%3E%3C/script%3E"))), t()
  }(function() {
    var t, o = "mCustomScrollbar",
      a = "mCS",
      n = ".mCustomScrollbar",
      i = {
        setTop: 0,
        setLeft: 0,
        axis: "y",
        scrollbarPosition: "inside",
        scrollInertia: 950,
        autoDraggerLength: !0,
        alwaysShowScrollbar: 0,
        snapOffset: 0,
        mouseWheel: {
          enable: !0,
          scrollAmount: "auto",
          axis: "y",
          deltaFactor: "auto",
          disableOver: ["select", "option", "keygen", "datalist", "textarea"]
        },
        scrollButtons: {
          scrollType: "stepless",
          scrollAmount: "auto"
        },
        keyboard: {
          enable: !0,
          scrollType: "stepless",
          scrollAmount: "auto"
        },
        contentTouchScroll: 25,
        advanced: {
          autoScrollOnFocus: "input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
          updateOnContentResize: !0,
          updateOnImageLoad: !0
        },
        theme: "light",
        callbacks: {
          onTotalScrollOffset: 0,
          onTotalScrollBackOffset: 0,
          alwaysTriggerOffsets: !0
        }
      },
      r = 0,
      l = {},
      s = window.attachEvent && !window.addEventListener ? 1 : 0,
      c = !1,
      d = ["mCSB_dragger_onDrag", "mCSB_scrollTools_onDrag", "mCS_img_loaded", "mCS_disabled", "mCS_destroyed", "mCS_no_scrollbar", "mCS-autoHide", "mCS-dir-rtl", "mCS_no_scrollbar_y", "mCS_no_scrollbar_x", "mCS_y_hidden", "mCS_x_hidden", "mCSB_draggerContainer", "mCSB_buttonUp", "mCSB_buttonDown", "mCSB_buttonLeft", "mCSB_buttonRight"],
      u = {
        init: function(t) {
          var t = e.extend(!0, {}, i, t),
            o = f.call(this);
          if (t.live) {
            var s = t.liveSelector || this.selector || n,
              c = e(s);
            if ("off" === t.live) return void m(s);
            l[s] = setTimeout(function() {
              c.mCustomScrollbar(t), "once" === t.live && c.length && m(s)
            }, 500)
          } else m(s);
          return t.setWidth = t.set_width ? t.set_width : t.setWidth, t.setHeight = t.set_height ? t.set_height : t.setHeight, t.axis = t.horizontalScroll ? "x" : p(t.axis), t.scrollInertia = t.scrollInertia > 0 && t.scrollInertia < 17 ? 17 : t.scrollInertia, "object" != typeof t.mouseWheel && 1 == t.mouseWheel && (t.mouseWheel = {
            enable: !0,
            scrollAmount: "auto",
            axis: "y",
            preventDefault: !1,
            deltaFactor: "auto",
            normalizeDelta: !1,
            invert: !1
          }), t.mouseWheel.scrollAmount = t.mouseWheelPixels ? t.mouseWheelPixels : t.mouseWheel.scrollAmount, t.mouseWheel.normalizeDelta = t.advanced.normalizeMouseWheelDelta ? t.advanced.normalizeMouseWheelDelta : t.mouseWheel.normalizeDelta, t.scrollButtons.scrollType = g(t.scrollButtons.scrollType), h(t), e(o).each(function() {
            var o = e(this);
            if (!o.data(a)) {
              o.data(a, {
                idx: ++r,
                opt: t,
                scrollRatio: {
                  y: null,
                  x: null
                },
                overflowed: null,
                contentReset: {
                  y: null,
                  x: null
                },
                bindEvents: !1,
                tweenRunning: !1,
                sequential: {},
                langDir: o.css("direction"),
                cbOffsets: null,
                trigger: null
              });
              var n = o.data(a),
                i = n.opt,
                l = o.data("mcs-axis"),
                s = o.data("mcs-scrollbar-position"),
                c = o.data("mcs-theme");
              l && (i.axis = l), s && (i.scrollbarPosition = s), c && (i.theme = c, h(i)), v.call(this), e("#mCSB_" + n.idx + "_container img:not(." + d[2] + ")").addClass(d[2]), u.update.call(null, o)
            }
          })
        },
        update: function(t, o) {
          var n = t || f.call(this);
          return e(n).each(function() {
            var t = e(this);
            if (t.data(a)) {
              var n = t.data(a),
                i = n.opt,
                r = e("#mCSB_" + n.idx + "_container"),
                l = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")];
              if (!r.length) return;
              n.tweenRunning && V(t), t.hasClass(d[3]) && t.removeClass(d[3]), t.hasClass(d[4]) && t.removeClass(d[4]), S.call(this), _.call(this), "y" === i.axis || i.advanced.autoExpandHorizontalScroll || r.css("width", x(r.children())), n.overflowed = B.call(this), O.call(this), i.autoDraggerLength && b.call(this), C.call(this), k.call(this);
              var s = [Math.abs(r[0].offsetTop), Math.abs(r[0].offsetLeft)];
              "x" !== i.axis && (n.overflowed[0] ? l[0].height() > l[0].parent().height() ? T.call(this) : (Q(t, s[0].toString(), {
                dir: "y",
                dur: 0,
                overwrite: "none"
              }), n.contentReset.y = null) : (T.call(this), "y" === i.axis ? M.call(this) : "yx" === i.axis && n.overflowed[1] && Q(t, s[1].toString(), {
                dir: "x",
                dur: 0,
                overwrite: "none"
              }))), "y" !== i.axis && (n.overflowed[1] ? l[1].width() > l[1].parent().width() ? T.call(this) : (Q(t, s[1].toString(), {
                dir: "x",
                dur: 0,
                overwrite: "none"
              }), n.contentReset.x = null) : (T.call(this), "x" === i.axis ? M.call(this) : "yx" === i.axis && n.overflowed[0] && Q(t, s[0].toString(), {
                dir: "y",
                dur: 0,
                overwrite: "none"
              }))), o && n && (2 === o && i.callbacks.onImageLoad && "function" == typeof i.callbacks.onImageLoad ? i.callbacks.onImageLoad.call(this) : 3 === o && i.callbacks.onSelectorChange && "function" == typeof i.callbacks.onSelectorChange ? i.callbacks.onSelectorChange.call(this) : i.callbacks.onUpdate && "function" == typeof i.callbacks.onUpdate && i.callbacks.onUpdate.call(this)), X.call(this)
            }
          })
        },
        scrollTo: function(t, o) {
          if ("undefined" != typeof t && null != t) {
            var n = f.call(this);
            return e(n).each(function() {
              var n = e(this);
              if (n.data(a)) {
                var i = n.data(a),
                  r = i.opt,
                  l = {
                    trigger: "external",
                    scrollInertia: r.scrollInertia,
                    scrollEasing: "mcsEaseInOut",
                    moveDragger: !1,
                    timeout: 60,
                    callbacks: !0,
                    onStart: !0,
                    onUpdate: !0,
                    onComplete: !0
                  },
                  s = e.extend(!0, {}, l, o),
                  c = Y.call(this, t),
                  d = s.scrollInertia > 0 && s.scrollInertia < 17 ? 17 : s.scrollInertia;
                c[0] = j.call(this, c[0], "y"), c[1] = j.call(this, c[1], "x"), s.moveDragger && (c[0] *= i.scrollRatio.y, c[1] *= i.scrollRatio.x), s.dur = d, setTimeout(function() {
                  null !== c[0] && "undefined" != typeof c[0] && "x" !== r.axis && i.overflowed[0] && (s.dir = "y", s.overwrite = "all", Q(n, c[0].toString(), s)), null !== c[1] && "undefined" != typeof c[1] && "y" !== r.axis && i.overflowed[1] && (s.dir = "x", s.overwrite = "none", Q(n, c[1].toString(), s))
                }, s.timeout)
              }
            })
          }
        },
        stop: function() {
          var t = f.call(this);
          return e(t).each(function() {
            var t = e(this);
            t.data(a) && V(t)
          })
        },
        disable: function(t) {
          var o = f.call(this);
          return e(o).each(function() {
            var o = e(this);
            if (o.data(a)) {
              {
                o.data(a)
              }
              X.call(this, "remove"), M.call(this), t && T.call(this), O.call(this, !0), o.addClass(d[3])
            }
          })
        },
        destroy: function() {
          var t = f.call(this);
          return e(t).each(function() {
            var n = e(this);
            if (n.data(a)) {
              var i = n.data(a),
                r = i.opt,
                l = e("#mCSB_" + i.idx),
                s = e("#mCSB_" + i.idx + "_container"),
                c = e(".mCSB_" + i.idx + "_scrollbar");
              r.live && m(r.liveSelector || e(t).selector), X.call(this, "remove"), M.call(this), T.call(this), n.removeData(a), Z(this, "mcs"), c.remove(), s.find("img." + d[2]).removeClass(d[2]), l.replaceWith(s.contents()), n.removeClass(o + " _" + a + "_" + i.idx + " " + d[6] + " " + d[7] + " " + d[5] + " " + d[3]).addClass(d[4])
            }
          })
        }
      },
      f = function() {
        return "object" != typeof e(this) || e(this).length < 1 ? n : this
      },
      h = function(t) {
        var o = ["rounded", "rounded-dark", "rounded-dots", "rounded-dots-dark"],
          a = ["rounded-dots", "rounded-dots-dark", "3d", "3d-dark", "3d-thick", "3d-thick-dark", "inset", "inset-dark", "inset-2", "inset-2-dark", "inset-3", "inset-3-dark"],
          n = ["minimal", "minimal-dark"],
          i = ["minimal", "minimal-dark"],
          r = ["minimal", "minimal-dark"];
        t.autoDraggerLength = e.inArray(t.theme, o) > -1 ? !1 : t.autoDraggerLength, t.autoExpandScrollbar = e.inArray(t.theme, a) > -1 ? !1 : t.autoExpandScrollbar, t.scrollButtons.enable = e.inArray(t.theme, n) > -1 ? !1 : t.scrollButtons.enable, t.autoHideScrollbar = e.inArray(t.theme, i) > -1 ? !0 : t.autoHideScrollbar, t.scrollbarPosition = e.inArray(t.theme, r) > -1 ? "outside" : t.scrollbarPosition
      },
      m = function(e) {
        l[e] && (clearTimeout(l[e]), Z(l, e))
      },
      p = function(e) {
        return "yx" === e || "xy" === e || "auto" === e ? "yx" : "x" === e || "horizontal" === e ? "x" : "y"
      },
      g = function(e) {
        return "stepped" === e || "pixels" === e || "step" === e || "click" === e ? "stepped" : "stepless"
      },
      v = function() {
        var t = e(this),
          n = t.data(a),
          i = n.opt,
          r = i.autoExpandScrollbar ? " " + d[1] + "_expand" : "",
          l = ["<div id='mCSB_" + n.idx + "_scrollbar_vertical' class='mCSB_scrollTools mCSB_" + n.idx + "_scrollbar mCS-" + i.theme + " mCSB_scrollTools_vertical" + r + "'><div class='" + d[12] + "'><div id='mCSB_" + n.idx + "_dragger_vertical' class='mCSB_dragger' style='position:absolute;' oncontextmenu='return false;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>", "<div id='mCSB_" + n.idx + "_scrollbar_horizontal' class='mCSB_scrollTools mCSB_" + n.idx + "_scrollbar mCS-" + i.theme + " mCSB_scrollTools_horizontal" + r + "'><div class='" + d[12] + "'><div id='mCSB_" + n.idx + "_dragger_horizontal' class='mCSB_dragger' style='position:absolute;' oncontextmenu='return false;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>"],
          s = "yx" === i.axis ? "mCSB_vertical_horizontal" : "x" === i.axis ? "mCSB_horizontal" : "mCSB_vertical",
          c = "yx" === i.axis ? l[0] + l[1] : "x" === i.axis ? l[1] : l[0],
          u = "yx" === i.axis ? "<div id='mCSB_" + n.idx + "_container_wrapper' class='mCSB_container_wrapper' />" : "",
          f = i.autoHideScrollbar ? " " + d[6] : "",
          h = "x" !== i.axis && "rtl" === n.langDir ? " " + d[7] : "";
        i.setWidth && t.css("width", i.setWidth), i.setHeight && t.css("height", i.setHeight), i.setLeft = "y" !== i.axis && "rtl" === n.langDir ? "989999px" : i.setLeft, t.addClass(o + " _" + a + "_" + n.idx + f + h).wrapInner("<div id='mCSB_" + n.idx + "' class='mCustomScrollBox mCS-" + i.theme + " " + s + "'><div id='mCSB_" + n.idx + "_container' class='mCSB_container' style='position:relative; top:" + i.setTop + "; left:" + i.setLeft + ";' dir=" + n.langDir + " /></div>");
        var m = e("#mCSB_" + n.idx),
          p = e("#mCSB_" + n.idx + "_container");
        "y" === i.axis || i.advanced.autoExpandHorizontalScroll || p.css("width", x(p.children())), "outside" === i.scrollbarPosition ? ("static" === t.css("position") && t.css("position", "relative"), t.css("overflow", "visible"), m.addClass("mCSB_outside").after(c)) : (m.addClass("mCSB_inside").append(c), p.wrap(u)), w.call(this);
        var g = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")];
        g[0].css("min-height", g[0].height()), g[1].css("min-width", g[1].width())
      },
      x = function(t) {
        return Math.max.apply(Math, t.map(function() {
          return e(this).outerWidth(!0)
        }).get())
      },
      _ = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = e("#mCSB_" + o.idx + "_container");
        n.advanced.autoExpandHorizontalScroll && "y" !== n.axis && i.css({
          position: "absolute",
          width: "auto"
        }).wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />").css({
          width: Math.ceil(i[0].getBoundingClientRect().right + .4) - Math.floor(i[0].getBoundingClientRect().left),
          position: "relative"
        }).unwrap()
      },
      w = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = e(".mCSB_" + o.idx + "_scrollbar:first"),
          r = tt(n.scrollButtons.tabindex) ? "tabindex='" + n.scrollButtons.tabindex + "'" : "",
          l = ["<a href='#' class='" + d[13] + "' oncontextmenu='return false;' " + r + " />", "<a href='#' class='" + d[14] + "' oncontextmenu='return false;' " + r + " />", "<a href='#' class='" + d[15] + "' oncontextmenu='return false;' " + r + " />", "<a href='#' class='" + d[16] + "' oncontextmenu='return false;' " + r + " />"],
          s = ["x" === n.axis ? l[2] : l[0], "x" === n.axis ? l[3] : l[1], l[2], l[3]];
        n.scrollButtons.enable && i.prepend(s[0]).append(s[1]).next(".mCSB_scrollTools").prepend(s[2]).append(s[3])
      },
      S = function() {
        var t = e(this),
          o = t.data(a),
          n = e("#mCSB_" + o.idx),
          i = t.css("max-height") || "none",
          r = -1 !== i.indexOf("%"),
          l = t.css("box-sizing");
        if ("none" !== i) {
          var s = r ? t.parent().height() * parseInt(i) / 100 : parseInt(i);
          "border-box" === l && (s -= t.innerHeight() - t.height() + (t.outerHeight() - t.innerHeight())), n.css("max-height", Math.round(s))
        }
      },
      b = function() {
        var t = e(this),
          o = t.data(a),
          n = e("#mCSB_" + o.idx),
          i = e("#mCSB_" + o.idx + "_container"),
          r = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")],
          l = [n.height() / i.outerHeight(!1), n.width() / i.outerWidth(!1)],
          c = [parseInt(r[0].css("min-height")), Math.round(l[0] * r[0].parent().height()), parseInt(r[1].css("min-width")), Math.round(l[1] * r[1].parent().width())],
          d = s && c[1] < c[0] ? c[0] : c[1],
          u = s && c[3] < c[2] ? c[2] : c[3];
        r[0].css({
          height: d,
          "max-height": r[0].parent().height() - 10
        }).find(".mCSB_dragger_bar").css({
          "line-height": c[0] + "px"
        }), r[1].css({
          width: u,
          "max-width": r[1].parent().width() - 10
        })
      },
      C = function() {
        var t = e(this),
          o = t.data(a),
          n = e("#mCSB_" + o.idx),
          i = e("#mCSB_" + o.idx + "_container"),
          r = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")],
          l = [i.outerHeight(!1) - n.height(), i.outerWidth(!1) - n.width()],
          s = [l[0] / (r[0].parent().height() - r[0].height()), l[1] / (r[1].parent().width() - r[1].width())];
        o.scrollRatio = {
          y: s[0],
          x: s[1]
        }
      },
      y = function(e, t, o) {
        var a = o ? d[0] + "_expanded" : "",
          n = e.closest(".mCSB_scrollTools");
        "active" === t ? (e.toggleClass(d[0] + " " + a), n.toggleClass(d[1]), e[0]._draggable = e[0]._draggable ? 0 : 1) : e[0]._draggable || ("hide" === t ? (e.removeClass(d[0]), n.removeClass(d[1])) : (e.addClass(d[0]), n.addClass(d[1])))
      },
      B = function() {
        var t = e(this),
          o = t.data(a),
          n = e("#mCSB_" + o.idx),
          i = e("#mCSB_" + o.idx + "_container"),
          r = null == o.overflowed ? i.height() : i.outerHeight(!1),
          l = null == o.overflowed ? i.width() : i.outerWidth(!1);
        return [r > n.height(), l > n.width()]
      },
      T = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = e("#mCSB_" + o.idx),
          r = e("#mCSB_" + o.idx + "_container"),
          l = [e("#mCSB_" + o.idx + "_dragger_vertical"), e("#mCSB_" + o.idx + "_dragger_horizontal")];
        if (V(t), ("x" !== n.axis && !o.overflowed[0] || "y" === n.axis && o.overflowed[0]) && (l[0].add(r).css("top", 0), Q(t, "_resetY")), "y" !== n.axis && !o.overflowed[1] || "x" === n.axis && o.overflowed[1]) {
          var s = dx = 0;
          "rtl" === o.langDir && (s = i.width() - r.outerWidth(!1), dx = Math.abs(s / o.scrollRatio.x)), r.css("left", s), l[1].css("left", dx), Q(t, "_resetX")
        }
      },
      k = function() {
        function t() {
          r = setTimeout(function() {
            e.event.special.mousewheel ? (clearTimeout(r), W.call(o[0])) : t()
          }, 100)
        }
        var o = e(this),
          n = o.data(a),
          i = n.opt;
        if (!n.bindEvents) {
          if (R.call(this), i.contentTouchScroll && E.call(this), D.call(this), i.mouseWheel.enable) {
            var r;
            t()
          }
          P.call(this), H.call(this), i.advanced.autoScrollOnFocus && z.call(this), i.scrollButtons.enable && U.call(this), i.keyboard.enable && q.call(this), n.bindEvents = !0
        }
      },
      M = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = a + "_" + o.idx,
          r = ".mCSB_" + o.idx + "_scrollbar",
          l = e("#mCSB_" + o.idx + ",#mCSB_" + o.idx + "_container,#mCSB_" + o.idx + "_container_wrapper," + r + " ." + d[12] + ",#mCSB_" + o.idx + "_dragger_vertical,#mCSB_" + o.idx + "_dragger_horizontal," + r + ">a"),
          s = e("#mCSB_" + o.idx + "_container");
        n.advanced.releaseDraggableSelectors && l.add(e(n.advanced.releaseDraggableSelectors)), o.bindEvents && (e(document).unbind("." + i), l.each(function() {
          e(this).unbind("." + i)
        }), clearTimeout(t[0]._focusTimeout), Z(t[0], "_focusTimeout"), clearTimeout(o.sequential.step), Z(o.sequential, "step"), clearTimeout(s[0].onCompleteTimeout), Z(s[0], "onCompleteTimeout"), o.bindEvents = !1)
      },
      O = function(t) {
        var o = e(this),
          n = o.data(a),
          i = n.opt,
          r = e("#mCSB_" + n.idx + "_container_wrapper"),
          l = r.length ? r : e("#mCSB_" + n.idx + "_container"),
          s = [e("#mCSB_" + n.idx + "_scrollbar_vertical"), e("#mCSB_" + n.idx + "_scrollbar_horizontal")],
          c = [s[0].find(".mCSB_dragger"), s[1].find(".mCSB_dragger")];
        "x" !== i.axis && (n.overflowed[0] && !t ? (s[0].add(c[0]).add(s[0].children("a")).css("display", "block"), l.removeClass(d[8] + " " + d[10])) : (i.alwaysShowScrollbar ? (2 !== i.alwaysShowScrollbar && c[0].css("display", "none"), l.removeClass(d[10])) : (s[0].css("display", "none"), l.addClass(d[10])), l.addClass(d[8]))), "y" !== i.axis && (n.overflowed[1] && !t ? (s[1].add(c[1]).add(s[1].children("a")).css("display", "block"), l.removeClass(d[9] + " " + d[11])) : (i.alwaysShowScrollbar ? (2 !== i.alwaysShowScrollbar && c[1].css("display", "none"), l.removeClass(d[11])) : (s[1].css("display", "none"), l.addClass(d[11])), l.addClass(d[9]))), n.overflowed[0] || n.overflowed[1] ? o.removeClass(d[5]) : o.addClass(d[5])
      },
      I = function(e) {
        var t = e.type;
        switch (t) {
          case "pointerdown":
          case "MSPointerDown":
          case "pointermove":
          case "MSPointerMove":
          case "pointerup":
          case "MSPointerUp":
            return e.target.ownerDocument !== document ? [e.originalEvent.screenY, e.originalEvent.screenX, !1] : [e.originalEvent.pageY, e.originalEvent.pageX, !1];
          case "touchstart":
          case "touchmove":
          case "touchend":
            var o = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0],
              a = e.originalEvent.touches.length || e.originalEvent.changedTouches.length;
            return e.target.ownerDocument !== document ? [o.screenY, o.screenX, a > 1] : [o.pageY, o.pageX, a > 1];
          default:
            return [e.pageY, e.pageX, !1]
        }
      },
      R = function() {
        function t(e) {
          var t = m.find("iframe");
          if (t.length) {
            var o = e ? "auto" : "none";
            t.css("pointer-events", o)
          }
        }

        function o(e, t, o, a) {
          if (m[0].idleTimer = u.scrollInertia < 233 ? 250 : 0, n.attr("id") === h[1]) var i = "x",
            r = (n[0].offsetLeft - t + a) * d.scrollRatio.x;
          else var i = "y",
            r = (n[0].offsetTop - e + o) * d.scrollRatio.y;
          Q(l, r.toString(), {
            dir: i,
            drag: !0
          })
        }
        var n, i, r, l = e(this),
          d = l.data(a),
          u = d.opt,
          f = a + "_" + d.idx,
          h = ["mCSB_" + d.idx + "_dragger_vertical", "mCSB_" + d.idx + "_dragger_horizontal"],
          m = e("#mCSB_" + d.idx + "_container"),
          p = e("#" + h[0] + ",#" + h[1]),
          g = u.advanced.releaseDraggableSelectors ? p.add(e(u.advanced.releaseDraggableSelectors)) : p;
        p.bind("mousedown." + f + " touchstart." + f + " pointerdown." + f + " MSPointerDown." + f, function(o) {
          if (o.stopImmediatePropagation(), o.preventDefault(), $(o)) {
            c = !0, s && (document.onselectstart = function() {
              return !1
            }), t(!1), V(l), n = e(this);
            var a = n.offset(),
              d = I(o)[0] - a.top,
              f = I(o)[1] - a.left,
              h = n.height() + a.top,
              m = n.width() + a.left;
            h > d && d > 0 && m > f && f > 0 && (i = d, r = f), y(n, "active", u.autoExpandScrollbar)
          }
        }).bind("touchmove." + f, function(e) {
          e.stopImmediatePropagation(), e.preventDefault();
          var t = n.offset(),
            a = I(e)[0] - t.top,
            l = I(e)[1] - t.left;
          o(i, r, a, l)
        }), e(document).bind("mousemove." + f + " pointermove." + f + " MSPointerMove." + f, function(e) {
          if (n) {
            var t = n.offset(),
              a = I(e)[0] - t.top,
              l = I(e)[1] - t.left;
            if (i === a) return;
            o(i, r, a, l)
          }
        }).add(g).bind("mouseup." + f + " touchend." + f + " pointerup." + f + " MSPointerUp." + f, function() {
          n && (y(n, "active", u.autoExpandScrollbar), n = null), c = !1, s && (document.onselectstart = null), t(!0)
        })
      },
      E = function() {
        function o(e) {
          if (!et(e) || c || I(e)[2]) return void(t = 0);
          t = 1, S = 0, b = 0;
          var o = M.offset();
          d = I(e)[0] - o.top, u = I(e)[1] - o.left, A = [I(e)[0], I(e)[1]]
        }

        function n(e) {
          if (et(e) && !c && !I(e)[2] && (e.stopImmediatePropagation(), !b || S)) {
            p = J();
            var t = k.offset(),
              o = I(e)[0] - t.top,
              a = I(e)[1] - t.left,
              n = "mcsLinearOut";
            if (R.push(o), E.push(a), A[2] = Math.abs(I(e)[0] - A[0]), A[3] = Math.abs(I(e)[1] - A[1]), y.overflowed[0]) var i = O[0].parent().height() - O[0].height(),
              r = d - o > 0 && o - d > -(i * y.scrollRatio.y) && (2 * A[3] < A[2] || "yx" === B.axis);
            if (y.overflowed[1]) var l = O[1].parent().width() - O[1].width(),
              f = u - a > 0 && a - u > -(l * y.scrollRatio.x) && (2 * A[2] < A[3] || "yx" === B.axis);
            r || f ? (e.preventDefault(), S = 1) : b = 1, _ = "yx" === B.axis ? [d - o, u - a] : "x" === B.axis ? [null, u - a] : [d - o, null], M[0].idleTimer = 250, y.overflowed[0] && s(_[0], D, n, "y", "all", !0), y.overflowed[1] && s(_[1], D, n, "x", W, !0)
          }
        }

        function i(e) {
          if (!et(e) || c || I(e)[2]) return void(t = 0);
          t = 1, e.stopImmediatePropagation(), V(C), m = J();
          var o = k.offset();
          f = I(e)[0] - o.top, h = I(e)[1] - o.left, R = [], E = []
        }

        function r(e) {
          if (et(e) && !c && !I(e)[2]) {
            e.stopImmediatePropagation(), S = 0, b = 0, g = J();
            var t = k.offset(),
              o = I(e)[0] - t.top,
              a = I(e)[1] - t.left;
            if (!(g - p > 30)) {
              x = 1e3 / (g - m);
              var n = "mcsEaseOut",
                i = 2.5 > x,
                r = i ? [R[R.length - 2], E[E.length - 2]] : [0, 0];
              v = i ? [o - r[0], a - r[1]] : [o - f, a - h];
              var d = [Math.abs(v[0]), Math.abs(v[1])];
              x = i ? [Math.abs(v[0] / 4), Math.abs(v[1] / 4)] : [x, x];
              var u = [Math.abs(M[0].offsetTop) - v[0] * l(d[0] / x[0], x[0]), Math.abs(M[0].offsetLeft) - v[1] * l(d[1] / x[1], x[1])];
              _ = "yx" === B.axis ? [u[0], u[1]] : "x" === B.axis ? [null, u[1]] : [u[0], null], w = [4 * d[0] + B.scrollInertia, 4 * d[1] + B.scrollInertia];
              var C = parseInt(B.contentTouchScroll) || 0;
              _[0] = d[0] > C ? _[0] : 0, _[1] = d[1] > C ? _[1] : 0, y.overflowed[0] && s(_[0], w[0], n, "y", W, !1), y.overflowed[1] && s(_[1], w[1], n, "x", W, !1)
            }
          }
        }

        function l(e, t) {
          var o = [1.5 * t, 2 * t, t / 1.5, t / 2];
          return e > 90 ? t > 4 ? o[0] : o[3] : e > 60 ? t > 3 ? o[3] : o[2] : e > 30 ? t > 8 ? o[1] : t > 6 ? o[0] : t > 4 ? t : o[2] : t > 8 ? t : o[3]
        }

        function s(e, t, o, a, n, i) {
          e && Q(C, e.toString(), {
            dur: t,
            scrollEasing: o,
            dir: a,
            overwrite: n,
            drag: i
          })
        }
        var d, u, f, h, m, p, g, v, x, _, w, S, b, C = e(this),
          y = C.data(a),
          B = y.opt,
          T = a + "_" + y.idx,
          k = e("#mCSB_" + y.idx),
          M = e("#mCSB_" + y.idx + "_container"),
          O = [e("#mCSB_" + y.idx + "_dragger_vertical"), e("#mCSB_" + y.idx + "_dragger_horizontal")],
          R = [],
          E = [],
          D = 0,
          W = "yx" === B.axis ? "none" : "all",
          A = [],
          P = M.find("iframe"),
          z = ["touchstart." + T + " pointerdown." + T + " MSPointerDown." + T, "touchmove." + T + " pointermove." + T + " MSPointerMove." + T, "touchend." + T + " pointerup." + T + " MSPointerUp." + T];
        M.bind(z[0], function(e) {
          o(e)
        }).bind(z[1], function(e) {
          n(e)
        }), k.bind(z[0], function(e) {
          i(e)
        }).bind(z[2], function(e) {
          r(e)
        }), P.length && P.each(function() {
          e(this).load(function() {
            L(this) && e(this.contentDocument || this.contentWindow.document).bind(z[0], function(e) {
              o(e), i(e)
            }).bind(z[1], function(e) {
              n(e)
            }).bind(z[2], function(e) {
              r(e)
            })
          })
        })
      },
      D = function() {
        function o() {
          return window.getSelection ? window.getSelection().toString() : document.selection && "Control" != document.selection.type ? document.selection.createRange().text : 0
        }

        function n(e, t, o) {
          d.type = o && i ? "stepped" : "stepless", d.scrollAmount = 10, F(r, e, t, "mcsLinearOut", o ? 60 : null)
        }
        var i, r = e(this),
          l = r.data(a),
          s = l.opt,
          d = l.sequential,
          u = a + "_" + l.idx,
          f = e("#mCSB_" + l.idx + "_container"),
          h = f.parent();
        f.bind("mousedown." + u, function() {
          t || i || (i = 1, c = !0)
        }).add(document).bind("mousemove." + u, function(e) {
          if (!t && i && o()) {
            var a = f.offset(),
              r = I(e)[0] - a.top + f[0].offsetTop,
              c = I(e)[1] - a.left + f[0].offsetLeft;
            r > 0 && r < h.height() && c > 0 && c < h.width() ? d.step && n("off", null, "stepped") : ("x" !== s.axis && l.overflowed[0] && (0 > r ? n("on", 38) : r > h.height() && n("on", 40)), "y" !== s.axis && l.overflowed[1] && (0 > c ? n("on", 37) : c > h.width() && n("on", 39)))
          }
        }).bind("mouseup." + u, function() {
          t || (i && (i = 0, n("off", null)), c = !1)
        })
      },
      W = function() {
        function t(t, a) {
          if (V(o), !A(o, t.target)) {
            var r = "auto" !== i.mouseWheel.deltaFactor ? parseInt(i.mouseWheel.deltaFactor) : s && t.deltaFactor < 100 ? 100 : t.deltaFactor || 100;
            if ("x" === i.axis || "x" === i.mouseWheel.axis) var d = "x",
              u = [Math.round(r * n.scrollRatio.x), parseInt(i.mouseWheel.scrollAmount)],
              f = "auto" !== i.mouseWheel.scrollAmount ? u[1] : u[0] >= l.width() ? .9 * l.width() : u[0],
              h = Math.abs(e("#mCSB_" + n.idx + "_container")[0].offsetLeft),
              m = c[1][0].offsetLeft,
              p = c[1].parent().width() - c[1].width(),
              g = t.deltaX || t.deltaY || a;
            else var d = "y",
              u = [Math.round(r * n.scrollRatio.y), parseInt(i.mouseWheel.scrollAmount)],
              f = "auto" !== i.mouseWheel.scrollAmount ? u[1] : u[0] >= l.height() ? .9 * l.height() : u[0],
              h = Math.abs(e("#mCSB_" + n.idx + "_container")[0].offsetTop),
              m = c[0][0].offsetTop,
              p = c[0].parent().height() - c[0].height(),
              g = t.deltaY || a;
            "y" === d && !n.overflowed[0] || "x" === d && !n.overflowed[1] || (i.mouseWheel.invert && (g = -g), i.mouseWheel.normalizeDelta && (g = 0 > g ? -1 : 1), (g > 0 && 0 !== m || 0 > g && m !== p || i.mouseWheel.preventDefault) && (t.stopImmediatePropagation(), t.preventDefault()), Q(o, (h - g * f).toString(), {
              dir: d
            }))
          }
        }
        var o = e(this),
          n = o.data(a),
          i = n.opt,
          r = a + "_" + n.idx,
          l = e("#mCSB_" + n.idx),
          c = [e("#mCSB_" + n.idx + "_dragger_vertical"), e("#mCSB_" + n.idx + "_dragger_horizontal")],
          d = e("#mCSB_" + n.idx + "_container").find("iframe");
        n && (d.length && d.each(function() {
          e(this).load(function() {
            L(this) && e(this.contentDocument || this.contentWindow.document).bind("mousewheel." + r, function(e, o) {
              t(e, o)
            })
          })
        }), l.bind("mousewheel." + r, function(e, o) {
          t(e, o)
        }))
      },
      L = function(e) {
        var t = null;
        try {
          var o = e.contentDocument || e.contentWindow.document;
          t = o.body.innerHTML
        } catch (a) {}
        return null !== t
      },
      A = function(t, o) {
        var n = o.nodeName.toLowerCase(),
          i = t.data(a).opt.mouseWheel.disableOver,
          r = ["select", "textarea"];
        return e.inArray(n, i) > -1 && !(e.inArray(n, r) > -1 && !e(o).is(":focus"))
      },
      P = function() {
        var t = e(this),
          o = t.data(a),
          n = a + "_" + o.idx,
          i = e("#mCSB_" + o.idx + "_container"),
          r = i.parent(),
          l = e(".mCSB_" + o.idx + "_scrollbar ." + d[12]);
        l.bind("touchstart." + n + " pointerdown." + n + " MSPointerDown." + n, function() {
          c = !0
        }).bind("touchend." + n + " pointerup." + n + " MSPointerUp." + n, function() {
          c = !1
        }).bind("click." + n, function(a) {
          if (e(a.target).hasClass(d[12]) || e(a.target).hasClass("mCSB_draggerRail")) {
            V(t);
            var n = e(this),
              l = n.find(".mCSB_dragger");
            if (n.parent(".mCSB_scrollTools_horizontal").length > 0) {
              if (!o.overflowed[1]) return;
              var s = "x",
                c = a.pageX > l.offset().left ? -1 : 1,
                u = Math.abs(i[0].offsetLeft) - .9 * c * r.width()
            } else {
              if (!o.overflowed[0]) return;
              var s = "y",
                c = a.pageY > l.offset().top ? -1 : 1,
                u = Math.abs(i[0].offsetTop) - .9 * c * r.height()
            }
            Q(t, u.toString(), {
              dir: s,
              scrollEasing: "mcsEaseInOut"
            })
          }
        })
      },
      z = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = a + "_" + o.idx,
          r = e("#mCSB_" + o.idx + "_container"),
          l = r.parent();
        r.bind("focusin." + i, function() {
          var o = e(document.activeElement),
            a = r.find(".mCustomScrollBox").length,
            i = 0;
          o.is(n.advanced.autoScrollOnFocus) && (V(t), clearTimeout(t[0]._focusTimeout), t[0]._focusTimer = a ? (i + 17) * a : 0, t[0]._focusTimeout = setTimeout(function() {
            var e = [ot(o)[0], ot(o)[1]],
              a = [r[0].offsetTop, r[0].offsetLeft],
              s = [a[0] + e[0] >= 0 && a[0] + e[0] < l.height() - o.outerHeight(!1), a[1] + e[1] >= 0 && a[0] + e[1] < l.width() - o.outerWidth(!1)],
              c = "yx" !== n.axis || s[0] || s[1] ? "all" : "none";
            "x" === n.axis || s[0] || Q(t, e[0].toString(), {
              dir: "y",
              scrollEasing: "mcsEaseInOut",
              overwrite: c,
              dur: i
            }), "y" === n.axis || s[1] || Q(t, e[1].toString(), {
              dir: "x",
              scrollEasing: "mcsEaseInOut",
              overwrite: c,
              dur: i
            })
          }, t[0]._focusTimer))
        })
      },
      H = function() {
        var t = e(this),
          o = t.data(a),
          n = a + "_" + o.idx,
          i = e("#mCSB_" + o.idx + "_container").parent();
        i.bind("scroll." + n, function() {
          (0 !== i.scrollTop() || 0 !== i.scrollLeft()) && e(".mCSB_" + o.idx + "_scrollbar").css("visibility", "hidden")
        })
      },
      U = function() {
        var t = e(this),
          o = t.data(a),
          n = o.opt,
          i = o.sequential,
          r = a + "_" + o.idx,
          l = ".mCSB_" + o.idx + "_scrollbar",
          s = e(l + ">a");
        s.bind("mousedown." + r + " touchstart." + r + " pointerdown." + r + " MSPointerDown." + r + " mouseup." + r + " touchend." + r + " pointerup." + r + " MSPointerUp." + r + " mouseout." + r + " pointerout." + r + " MSPointerOut." + r + " click." + r, function(a) {
          function r(e, o) {
            i.scrollAmount = n.snapAmount || n.scrollButtons.scrollAmount, F(t, e, o)
          }
          if (a.preventDefault(), $(a)) {
            var l = e(this).attr("class");
            switch (i.type = n.scrollButtons.scrollType, a.type) {
              case "mousedown":
              case "touchstart":
              case "pointerdown":
              case "MSPointerDown":
                if ("stepped" === i.type) return;
                c = !0, o.tweenRunning = !1, r("on", l);
                break;
              case "mouseup":
              case "touchend":
              case "pointerup":
              case "MSPointerUp":
              case "mouseout":
              case "pointerout":
              case "MSPointerOut":
                if ("stepped" === i.type) return;
                c = !1, i.dir && r("off", l);
                break;
              case "click":
                if ("stepped" !== i.type || o.tweenRunning) return;
                r("on", l)
            }
          }
        })
      },
      q = function() {
        function t(t) {
          function a(e, t) {
            r.type = i.keyboard.scrollType, r.scrollAmount = i.snapAmount || i.keyboard.scrollAmount, "stepped" === r.type && n.tweenRunning || F(o, e, t)
          }
          switch (t.type) {
            case "blur":
              n.tweenRunning && r.dir && a("off", null);
              break;
            case "keydown":
            case "keyup":
              var l = t.keyCode ? t.keyCode : t.which,
                s = "on";
              if ("x" !== i.axis && (38 === l || 40 === l) || "y" !== i.axis && (37 === l || 39 === l)) {
                if ((38 === l || 40 === l) && !n.overflowed[0] || (37 === l || 39 === l) && !n.overflowed[1]) return;
                "keyup" === t.type && (s = "off"), e(document.activeElement).is(u) || (t.preventDefault(), t.stopImmediatePropagation(), a(s, l))
              } else if (33 === l || 34 === l) {
                if ((n.overflowed[0] || n.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()), "keyup" === t.type) {
                  V(o);
                  var f = 34 === l ? -1 : 1;
                  if ("x" === i.axis || "yx" === i.axis && n.overflowed[1] && !n.overflowed[0]) var h = "x",
                    m = Math.abs(c[0].offsetLeft) - .9 * f * d.width();
                  else var h = "y",
                    m = Math.abs(c[0].offsetTop) - .9 * f * d.height();
                  Q(o, m.toString(), {
                    dir: h,
                    scrollEasing: "mcsEaseInOut"
                  })
                }
              } else if ((35 === l || 36 === l) && !e(document.activeElement).is(u) && ((n.overflowed[0] || n.overflowed[1]) && (t.preventDefault(), t.stopImmediatePropagation()), "keyup" === t.type)) {
                if ("x" === i.axis || "yx" === i.axis && n.overflowed[1] && !n.overflowed[0]) var h = "x",
                  m = 35 === l ? Math.abs(d.width() - c.outerWidth(!1)) : 0;
                else var h = "y",
                  m = 35 === l ? Math.abs(d.height() - c.outerHeight(!1)) : 0;
                Q(o, m.toString(), {
                  dir: h,
                  scrollEasing: "mcsEaseInOut"
                })
              }
          }
        }
        var o = e(this),
          n = o.data(a),
          i = n.opt,
          r = n.sequential,
          l = a + "_" + n.idx,
          s = e("#mCSB_" + n.idx),
          c = e("#mCSB_" + n.idx + "_container"),
          d = c.parent(),
          u = "input,textarea,select,datalist,keygen,[contenteditable='true']",
          f = c.find("iframe"),
          h = ["blur." + l + " keydown." + l + " keyup." + l];
        f.length && f.each(function() {
          e(this).load(function() {
            L(this) && e(this.contentDocument || this.contentWindow.document).bind(h[0], function(e) {
              t(e)
            })
          })
        }), s.attr("tabindex", "0").bind(h[0], function(e) {
          t(e)
        })
      },
      F = function(t, o, n, i, r) {
        function l(e) {
          var o = "stepped" !== f.type,
            a = r ? r : e ? o ? p / 1.5 : g : 1e3 / 60,
            n = e ? o ? 7.5 : 40 : 2.5,
            s = [Math.abs(h[0].offsetTop), Math.abs(h[0].offsetLeft)],
            d = [c.scrollRatio.y > 10 ? 10 : c.scrollRatio.y, c.scrollRatio.x > 10 ? 10 : c.scrollRatio.x],
            u = "x" === f.dir[0] ? s[1] + f.dir[1] * d[1] * n : s[0] + f.dir[1] * d[0] * n,
            m = "x" === f.dir[0] ? s[1] + f.dir[1] * parseInt(f.scrollAmount) : s[0] + f.dir[1] * parseInt(f.scrollAmount),
            v = "auto" !== f.scrollAmount ? m : u,
            x = i ? i : e ? o ? "mcsLinearOut" : "mcsEaseInOut" : "mcsLinear",
            _ = e ? !0 : !1;
          return e && 17 > a && (v = "x" === f.dir[0] ? s[1] : s[0]), Q(t, v.toString(), {
            dir: f.dir[0],
            scrollEasing: x,
            dur: a,
            onComplete: _
          }), e ? void(f.dir = !1) : (clearTimeout(f.step), void(f.step = setTimeout(function() {
            l()
          }, a)))
        }

        function s() {
          clearTimeout(f.step), Z(f, "step"), V(t)
        }
        var c = t.data(a),
          u = c.opt,
          f = c.sequential,
          h = e("#mCSB_" + c.idx + "_container"),
          m = "stepped" === f.type ? !0 : !1,
          p = u.scrollInertia < 26 ? 26 : u.scrollInertia,
          g = u.scrollInertia < 1 ? 17 : u.scrollInertia;
        switch (o) {
          case "on":
            if (f.dir = [n === d[16] || n === d[15] || 39 === n || 37 === n ? "x" : "y", n === d[13] || n === d[15] || 38 === n || 37 === n ? -1 : 1], V(t), tt(n) && "stepped" === f.type) return;
            l(m);
            break;
          case "off":
            s(), (m || c.tweenRunning && f.dir) && l(!0)
        }
      },
      Y = function(t) {
        var o = e(this).data(a).opt,
          n = [];
        return "function" == typeof t && (t = t()), t instanceof Array ? n = t.length > 1 ? [t[0], t[1]] : "x" === o.axis ? [null, t[0]] : [t[0], null] : (n[0] = t.y ? t.y : t.x || "x" === o.axis ? null : t, n[1] = t.x ? t.x : t.y || "y" === o.axis ? null : t), "function" == typeof n[0] && (n[0] = n[0]()), "function" == typeof n[1] && (n[1] = n[1]()), n
      },
      j = function(t, o) {
        if (null != t && "undefined" != typeof t) {
          var n = e(this),
            i = n.data(a),
            r = i.opt,
            l = e("#mCSB_" + i.idx + "_container"),
            s = l.parent(),
            c = typeof t;
          o || (o = "x" === r.axis ? "x" : "y");
          var d = "x" === o ? l.outerWidth(!1) : l.outerHeight(!1),
            f = "x" === o ? l[0].offsetLeft : l[0].offsetTop,
            h = "x" === o ? "left" : "top";
          switch (c) {
            case "function":
              return t();
            case "object":
              var m = t.jquery ? t : e(t);
              if (!m.length) return;
              return "x" === o ? ot(m)[1] : ot(m)[0];
            case "string":
            case "number":
              if (tt(t)) return Math.abs(t);
              if (-1 !== t.indexOf("%")) return Math.abs(d * parseInt(t) / 100);
              if (-1 !== t.indexOf("-=")) return Math.abs(f - parseInt(t.split("-=")[1]));
              if (-1 !== t.indexOf("+=")) {
                var p = f + parseInt(t.split("+=")[1]);
                return p >= 0 ? 0 : Math.abs(p)
              }
              if (-1 !== t.indexOf("px") && tt(t.split("px")[0])) return Math.abs(t.split("px")[0]);
              if ("top" === t || "left" === t) return 0;
              if ("bottom" === t) return Math.abs(s.height() - l.outerHeight(!1));
              if ("right" === t) return Math.abs(s.width() - l.outerWidth(!1));
              if ("first" === t || "last" === t) {
                var m = l.find(":" + t);
                return "x" === o ? ot(m)[1] : ot(m)[0]
              }
              return e(t).length ? "x" === o ? ot(e(t))[1] : ot(e(t))[0] : (l.css(h, t), void u.update.call(null, n[0]))
          }
        }
      },
      X = function(t) {
        function o() {
          clearTimeout(h[0].autoUpdate), h[0].autoUpdate = setTimeout(function() {
            return f.advanced.updateOnSelectorChange && (m = r(), m !== w) ? (l(3), void(w = m)) : (f.advanced.updateOnContentResize && (p = [h.outerHeight(!1), h.outerWidth(!1), v.height(), v.width(), _()[0], _()[1]], (p[0] !== S[0] || p[1] !== S[1] || p[2] !== S[2] || p[3] !== S[3] || p[4] !== S[4] || p[5] !== S[5]) && (l(p[0] !== S[0] || p[1] !== S[1]), S = p)), f.advanced.updateOnImageLoad && (g = n(), g !== b && (h.find("img").each(function() {
              i(this)
            }), b = g)), void((f.advanced.updateOnSelectorChange || f.advanced.updateOnContentResize || f.advanced.updateOnImageLoad) && o()))
          }, 60)
        }

        function n() {
          var e = 0;
          return f.advanced.updateOnImageLoad && (e = h.find("img").length), e
        }

        function i(t) {
          function o(e, t) {
            return function() {
              return t.apply(e, arguments)
            }
          }

          function a() {
            this.onload = null, e(t).addClass(d[2]), l(2)
          }
          if (e(t).hasClass(d[2])) return void l();
          var n = new Image;
          n.onload = o(n, a), n.src = t.src
        }

        function r() {
          f.advanced.updateOnSelectorChange === !0 && (f.advanced.updateOnSelectorChange = "*");
          var t = 0,
            o = h.find(f.advanced.updateOnSelectorChange);
          return f.advanced.updateOnSelectorChange && o.length > 0 && o.each(function() {
            t += e(this).height() + e(this).width()
          }), t
        }

        function l(e) {
          clearTimeout(h[0].autoUpdate), u.update.call(null, s[0], e)
        }
        var s = e(this),
          c = s.data(a),
          f = c.opt,
          h = e("#mCSB_" + c.idx + "_container");
        if (t) return clearTimeout(h[0].autoUpdate), void Z(h[0], "autoUpdate");
        var m, p, g, v = h.parent(),
          x = [e("#mCSB_" + c.idx + "_scrollbar_vertical"), e("#mCSB_" + c.idx + "_scrollbar_horizontal")],
          _ = function() {
            return [x[0].is(":visible") ? x[0].outerHeight(!0) : 0, x[1].is(":visible") ? x[1].outerWidth(!0) : 0]
          },
          w = r(),
          S = [h.outerHeight(!1), h.outerWidth(!1), v.height(), v.width(), _()[0], _()[1]],
          b = n();
        o()
      },
      N = function(e, t, o) {
        return Math.round(e / t) * t - o
      },
      V = function(t) {
        var o = t.data(a),
          n = e("#mCSB_" + o.idx + "_container,#mCSB_" + o.idx + "_container_wrapper,#mCSB_" + o.idx + "_dragger_vertical,#mCSB_" + o.idx + "_dragger_horizontal");
        n.each(function() {
          K.call(this)
        })
      },
      Q = function(t, o, n) {
        function i(e) {
          return s && c.callbacks[e] && "function" == typeof c.callbacks[e]
        }

        function r() {
          return [c.callbacks.alwaysTriggerOffsets || _ >= w[0] + b, c.callbacks.alwaysTriggerOffsets || -C >= _]
        }

        function l() {
          var e = [h[0].offsetTop, h[0].offsetLeft],
            o = [v[0].offsetTop, v[0].offsetLeft],
            a = [h.outerHeight(!1), h.outerWidth(!1)],
            i = [f.height(), f.width()];
          t[0].mcs = {
            content: h,
            top: e[0],
            left: e[1],
            draggerTop: o[0],
            draggerLeft: o[1],
            topPct: Math.round(100 * Math.abs(e[0]) / (Math.abs(a[0]) - i[0])),
            leftPct: Math.round(100 * Math.abs(e[1]) / (Math.abs(a[1]) - i[1])),
            direction: n.dir
          }
        }
        var s = t.data(a),
          c = s.opt,
          d = {
            trigger: "internal",
            dir: "y",
            scrollEasing: "mcsEaseOut",
            drag: !1,
            dur: c.scrollInertia,
            overwrite: "all",
            callbacks: !0,
            onStart: !0,
            onUpdate: !0,
            onComplete: !0
          },
          n = e.extend(d, n),
          u = [n.dur, n.drag ? 0 : n.dur],
          f = e("#mCSB_" + s.idx),
          h = e("#mCSB_" + s.idx + "_container"),
          m = h.parent(),
          p = c.callbacks.onTotalScrollOffset ? Y.call(t, c.callbacks.onTotalScrollOffset) : [0, 0],
          g = c.callbacks.onTotalScrollBackOffset ? Y.call(t, c.callbacks.onTotalScrollBackOffset) : [0, 0];
        if (s.trigger = n.trigger, (0 !== m.scrollTop() || 0 !== m.scrollLeft()) && (e(".mCSB_" + s.idx + "_scrollbar").css("visibility", "visible"), m.scrollTop(0).scrollLeft(0)), "_resetY" !== o || s.contentReset.y || (i("onOverflowYNone") && c.callbacks.onOverflowYNone.call(t[0]), s.contentReset.y = 1), "_resetX" !== o || s.contentReset.x || (i("onOverflowXNone") && c.callbacks.onOverflowXNone.call(t[0]), s.contentReset.x = 1), "_resetY" !== o && "_resetX" !== o) {
          switch (!s.contentReset.y && t[0].mcs || !s.overflowed[0] || (i("onOverflowY") && c.callbacks.onOverflowY.call(t[0]), s.contentReset.x = null), !s.contentReset.x && t[0].mcs || !s.overflowed[1] || (i("onOverflowX") && c.callbacks.onOverflowX.call(t[0]), s.contentReset.x = null), c.snapAmount && (o = N(o, c.snapAmount, c.snapOffset)), n.dir) {
            case "x":
              var v = e("#mCSB_" + s.idx + "_dragger_horizontal"),
                x = "left",
                _ = h[0].offsetLeft,
                w = [f.width() - h.outerWidth(!1), v.parent().width() - v.width()],
                S = [o, 0 === o ? 0 : o / s.scrollRatio.x],
                b = p[1],
                C = g[1],
                B = b > 0 ? b / s.scrollRatio.x : 0,
                T = C > 0 ? C / s.scrollRatio.x : 0;
              break;
            case "y":
              var v = e("#mCSB_" + s.idx + "_dragger_vertical"),
                x = "top",
                _ = h[0].offsetTop,
                w = [f.height() - h.outerHeight(!1), v.parent().height() - v.height()],
                S = [o, 0 === o ? 0 : o / s.scrollRatio.y],
                b = p[0],
                C = g[0],
                B = b > 0 ? b / s.scrollRatio.y : 0,
                T = C > 0 ? C / s.scrollRatio.y : 0
          }
          S[1] < 0 || 0 === S[0] && 0 === S[1] ? S = [0, 0] : S[1] >= w[1] ? S = [w[0], w[1]] : S[0] = -S[0], t[0].mcs || (l(), i("onInit") && c.callbacks.onInit.call(t[0])), clearTimeout(h[0].onCompleteTimeout), (s.tweenRunning || !(0 === _ && S[0] >= 0 || _ === w[0] && S[0] <= w[0])) && (G(v[0], x, Math.round(S[1]), u[1], n.scrollEasing), G(h[0], x, Math.round(S[0]), u[0], n.scrollEasing, n.overwrite, {
            onStart: function() {
              n.callbacks && n.onStart && !s.tweenRunning && (i("onScrollStart") && (l(), c.callbacks.onScrollStart.call(t[0])), s.tweenRunning = !0, y(v), s.cbOffsets = r())
            },
            onUpdate: function() {
              n.callbacks && n.onUpdate && i("whileScrolling") && (l(), c.callbacks.whileScrolling.call(t[0]))
            },
            onComplete: function() {
              if (n.callbacks && n.onComplete) {
                "yx" === c.axis && clearTimeout(h[0].onCompleteTimeout);
                var e = h[0].idleTimer || 0;
                h[0].onCompleteTimeout = setTimeout(function() {
                  i("onScroll") && (l(), c.callbacks.onScroll.call(t[0])), i("onTotalScroll") && S[1] >= w[1] - B && s.cbOffsets[0] && (l(), c.callbacks.onTotalScroll.call(t[0])), i("onTotalScrollBack") && S[1] <= T && s.cbOffsets[1] && (l(), c.callbacks.onTotalScrollBack.call(t[0])), s.tweenRunning = !1, h[0].idleTimer = 0, y(v, "hide")
                }, e)
              }
            }
          }))
        }
      },
      G = function(e, t, o, a, n, i, r) {
        function l() {
          S.stop || (x || m.call(), x = J() - v, s(), x >= S.time && (S.time = x > S.time ? x + f - (x - S.time) : x + f - 1, S.time < x + 1 && (S.time = x + 1)), S.time < a ? S.id = h(l) : g.call())
        }

        function s() {
          a > 0 ? (S.currVal = u(S.time, _, b, a, n), w[t] = Math.round(S.currVal) + "px") : w[t] = o + "px", p.call()
        }

        function c() {
          f = 1e3 / 60, S.time = x + f, h = window.requestAnimationFrame ? window.requestAnimationFrame : function(e) {
            return s(), setTimeout(e, .01)
          }, S.id = h(l)
        }

        function d() {
          null != S.id && (window.requestAnimationFrame ? window.cancelAnimationFrame(S.id) : clearTimeout(S.id), S.id = null)
        }

        function u(e, t, o, a, n) {
          switch (n) {
            case "linear":
            case "mcsLinear":
              return o * e / a + t;
            case "mcsLinearOut":
              return e /= a, e--, o * Math.sqrt(1 - e * e) + t;
            case "easeInOutSmooth":
              return e /= a / 2, 1 > e ? o / 2 * e * e + t : (e--, -o / 2 * (e * (e - 2) - 1) + t);
            case "easeInOutStrong":
              return e /= a / 2, 1 > e ? o / 2 * Math.pow(2, 10 * (e - 1)) + t : (e--, o / 2 * (-Math.pow(2, -10 * e) + 2) + t);
            case "easeInOut":
            case "mcsEaseInOut":
              return e /= a / 2, 1 > e ? o / 2 * e * e * e + t : (e -= 2, o / 2 * (e * e * e + 2) + t);
            case "easeOutSmooth":
              return e /= a, e--, -o * (e * e * e * e - 1) + t;
            case "easeOutStrong":
              return o * (-Math.pow(2, -10 * e / a) + 1) + t;
            case "easeOut":
            case "mcsEaseOut":
            default:
              var i = (e /= a) * e,
                r = i * e;
              return t + o * (.499999999999997 * r * i + -2.5 * i * i + 5.5 * r + -6.5 * i + 4 * e)
          }
        }
        e._mTween || (e._mTween = {
          top: {},
          left: {}
        });
        var f, h, r = r || {},
          m = r.onStart || function() {},
          p = r.onUpdate || function() {},
          g = r.onComplete || function() {},
          v = J(),
          x = 0,
          _ = e.offsetTop,
          w = e.style,
          S = e._mTween[t];
        "left" === t && (_ = e.offsetLeft);
        var b = o - _;
        S.stop = 0, "none" !== i && d(), c()
      },
      J = function() {
        return window.performance && window.performance.now ? window.performance.now() : window.performance && window.performance.webkitNow ? window.performance.webkitNow() : Date.now ? Date.now() : (new Date).getTime()
      },
      K = function() {
        var e = this;
        e._mTween || (e._mTween = {
          top: {},
          left: {}
        });
        for (var t = ["top", "left"], o = 0; o < t.length; o++) {
          var a = t[o];
          e._mTween[a].id && (window.requestAnimationFrame ? window.cancelAnimationFrame(e._mTween[a].id) : clearTimeout(e._mTween[a].id), e._mTween[a].id = null, e._mTween[a].stop = 1)
        }
      },
      Z = function(e, t) {
        try {
          delete e[t]
        } catch (o) {
          e[t] = null
        }
      },
      $ = function(e) {
        return !(e.which && 1 !== e.which)
      },
      et = function(e) {
        var t = e.originalEvent.pointerType;
        return !(t && "touch" !== t && 2 !== t)
      },
      tt = function(e) {
        return !isNaN(parseFloat(e)) && isFinite(e)
      },
      ot = function(e) {
        var t = e.parents(".mCSB_container");
        return [e.offset().top - t.offset().top, e.offset().left - t.offset().left]
      };
    e.fn[o] = function(t) {
      return u[t] ? u[t].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof t && t ? void e.error("Method " + t + " does not exist") : u.init.apply(this, arguments)
    }, e[o] = function(t) {
      return u[t] ? u[t].apply(this, Array.prototype.slice.call(arguments, 1)) : "object" != typeof t && t ? void e.error("Method " + t + " does not exist") : u.init.apply(this, arguments)
    }, e[o].defaults = i, window[o] = !0, e(window).load(function() {
      e(n)[o](), e.extend(e.expr[":"], {
        mcsInView: e.expr[":"].mcsInView || function(t) {
          var o, a, n = e(t),
            i = n.parents(".mCSB_container");
          if (i.length) return o = i.parent(), a = [i[0].offsetTop, i[0].offsetLeft], a[0] + ot(n)[0] >= 0 && a[0] + ot(n)[0] < o.height() - n.outerHeight(!1) && a[1] + ot(n)[1] >= 0 && a[1] + ot(n)[1] < o.width() - n.outerWidth(!1)
        },
        mcsOverflow: e.expr[":"].mcsOverflow || function(t) {
          var o = e(t).data(a);
          if (o) return o.overflowed[0] || o.overflowed[1]
        }
      })
    })
  })
});


/*! jquery-preload v0.8.1 | (c) 2014, falsandtru | MIT Licence */
!new function(window, document, undefined, $) {
  "use strict";
  var MODULE;
  ! function(a) {
    a.NAME = "preload", a.NAMESPACE = jQuery,
      function(a) {
        a[a.wait = -1] = "wait", a[a.ready = 0] = "ready", a[a.lock = 1] = "lock", a[a.seal = 2] = "seal"
      }(a.State || (a.State = {}));
    a.State;
    a.GEN_UUID = function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(a) {
        var b = 16 * Math.random() | 0,
          c = "x" == a ? b : 3 & b | 8;
        return c.toString(16).toUpperCase()
      })
    }
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b, c, d = function() {
        function a(a, d) {
          b = d, c = a
        }
        return a.prototype.enable = function() {
          return b.state_ = 0, this
        }, a.prototype.disable = function() {
          return b.state_ = 1, this
        }, a
      }();
      a.ControllerFunction = d
    }(b = a.CONTROLLER || (a.CONTROLLER = {}))
  }(MODULE || (MODULE = {}));
  var __extends = this.__extends || function(a, b) {
      function c() {
        this.constructor = a
      }
      for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
      c.prototype = b.prototype, a.prototype = new c
    },
    MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b = function(a) {
        function b() {
          a.apply(this, arguments)
        }
        return __extends(b, a), b
      }(a.ControllerFunction);
      a.ControllerMethod = b
    }(b = a.CONTROLLER || (a.CONTROLLER = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c, d, e = function() {
        function e(e) {
          this.state_ = -1, this.HANDLERS = {}, c = e, d = this, this.UUID = a.GEN_UUID(), a.NAMESPACE[a.NAME] = a.NAMESPACE && a.NAMESPACE == a.NAMESPACE.window ? this.EXEC : a.NAMESPACE.prototype[a.NAME] = this.EXEC;
          var f = new b.ControllerFunction(d, c);
          this.REGISTER_FUNCTIONS(a.NAMESPACE[a.NAME], f), this.UPDATE_PROPERTIES(a.NAMESPACE[a.NAME], f), this.OBSERVE(), this.state_ = 0
        }
        return e.prototype.EXTEND = function(e) {
          if (e === a.NAMESPACE || a.NAMESPACE && a.NAMESPACE == a.NAMESPACE.window) {
            var f = new b.ControllerFunction(d, c);
            e = a.NAMESPACE[a.NAME]
          } else var f = new b.ControllerMethod(d, c);
          return e instanceof a.NAMESPACE && (e instanceof jQuery && (e = e.add()), this.REGISTER_FUNCTIONS(e, f)), this.UPDATE_PROPERTIES(e, f), e
        }, e.prototype.EXEC = function() {
          for (var a = [], b = 0; b < arguments.length; b++) a[b - 0] = arguments[b];
          var e = d.EXTEND(this);
          return a = [e].concat(a), a = d.exec_.apply(d, a), a = a instanceof Array ? a : [a], c.MAIN.apply(c, a)
        }, e.prototype.exec_ = function(a) {
          for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
          return [a].concat(b)
        }, e.prototype.REGISTER_FUNCTIONS = function(a, c) {
          {
            var d;
            b.Template.PROPERTIES
          }
          for (d in c) a[d] = c[d];
          return a
        }, e.prototype.UPDATE_PROPERTIES = function(a, c) {
          var d, e, f, g = b.Template.PROPERTIES;
          for (d = 0, e = g.length; e > d; d++) f = g[d], c[f] && (a[f] = c[f].call(a));
          return a
        }, e.prototype.OBSERVE = function() {}, e.prototype.RELEASE = function() {}, e.EVENTS = {}, e.FUNCTIONS = {}, e.METHODS = {}, e.PROPERTIES = [], e.TRIGGERS = {}, e
      }();
      b.Template = e
    }(b = a.CONTROLLER || (a.CONTROLLER = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b = function(a) {
        function b(b) {
          a.call(this, b), this.model_ = b, this.HANDLERS = {}
        }
        return __extends(b, a), b.prototype.PRELOAD = function(a) {
          this.model_.PRELOAD(a)
        }, b.prototype.CLICK = function(a) {
          this.model_.CLICK(a)
        }, b.prototype.MOUSEMOVE = function(a) {
          this.model_.MOUSEMOVE(a)
        }, b.prototype.MOUSEOVER = function(a) {
          this.model_.MOUSEOVER(a)
        }, b.prototype.MOUSEOUT = function(a) {
          this.model_.MOUSEOUT(a)
        }, b.prototype.OBSERVE = function() {}, b.EVENTS = {}, b.PROPERTIES = [], b.TRIGGERS = {}, b
      }(a.Template);
      a.Main = b
    }(b = a.CONTROLLER || (a.CONTROLLER = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c = function() {
        function b() {
          this.NAME = a.NAME, this.NAMESPACE = a.NAMESPACE, this.state_ = -1, this.stock = function c(d, e, f) {
            if (this instanceof c || this.constructor.toString() === c.toString()) switch (typeof d) {
              case "object":
              case "function":
                return this.uuid = a.GEN_UUID(), c[this.uuid] = this, jQuery.extend.apply(jQuery, [!0, this].concat([].slice.call(arguments)).concat({
                  uuid: this.uuid
                }));
              case "string":
                return delete c[d]
            } else if ("object" == typeof d) {
              var g, h = d;
              for (g in h) b.store(g, h[g])
            } else switch (arguments.length) {
              case 0:
                return new this.stock;
              case 1:
                return c[d] || b.store(d);
              case 2:
                return b.store(d, e);
              case 3:
                return b.store(d, e, f)
            }
          }, this.UUID = a.GEN_UUID()
        }
        return b.prototype.MAIN = function(a) {
          for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
          return this.main_.apply(this, [a].concat(b))
        }, b.prototype.main_ = function(a) {
          for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
          return this.state_ = 0, a
        }, b.store = function(a, c) {
          switch (arguments.length) {
            case 0:
              break;
            case 1:
              return b.store[a];
            case 2:
              return b.store[a] = c;
            case 3:
              return b.store[a] = jQuery.extend(!0, b.store[a], c)
          }
        }, b
      }();
      b.Template = c
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b = function() {
        function a() {}
        return a.trim = function(a) {
          if (a = "string" == typeof a ? a : String(0 === a && a.toString() || ""), a.trim) a = a.trim();
          else if (a = a.replace(/^[\s\uFEFF\xA0]+/, "")) {
            var b = /[\s\uFEFF\xA0]/,
              c = a.length,
              d = c % 8;
            a: {
              for (; d--;)
                if (!b.test(a.charAt(--c))) break a;
              for (; c;) {
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a
              }
            }
            a = a.substring(0, c + 1)
          }
          return a
        }, a.repeat = function(a, b) {
          switch (a instanceof Array && "array" || typeof a) {
            case "string":
              var c = a;
              return Array(b + 1).join(c);
            case "array":
              var d = a.length;
              if (300 > b) {
                var e = Array(b);
                this.duff(-b, function(b) {
                  return e[b] = a[b % d]
                })
              } else {
                for (var e = a.slice(); 2 * e.length <= b;) e = e.concat(e);
                e = e.concat(e.slice(0, b - e.length))
              }
              return e
          }
        }, a.fire = function(a, b, c, d) {
          return void 0 === b && (b = window), void 0 === c && (c = []), "function" == typeof a ? d ? setTimeout(function() {
            a.apply(b || window, c)
          }, 0) : a.apply(b || window, c) : a
        }, a.duff = function(a, b) {
          if (0 > a) {
            for (var c = -a, d = c % 8; d--;) b(--c);
            for (; c;) b(--c), b(--c), b(--c), b(--c), b(--c), b(--c), b(--c), b(--c)
          } else {
            for (var e = a, c = 0, d = e % 8, f = e / 8 ^ 0; d--;) b(c++);
            for (; f--;) b(c++), b(c++), b(c++), b(c++), b(c++), b(c++), b(c++), b(c++)
          }
        }, a.duffEx = function(a, b) {
          if (0 > a) {
            var c = -a,
              d = c % 8;
            a: {
              for (; d--;)
                if (!1 === b(--c)) break a;
              for (; c;) {
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a
              }
            }
          } else {
            var e = a,
              c = 0,
              d = e % 8,
              f = e / 8 ^ 0;
            a: {
              for (; d--;)
                if (!1 === b(c++)) break a;
              for (; f--;) {
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a
              }
            }
          }
        }, a.normalizeUrl = function(a, b) {
          void 0 === b && (b = !0);
          var c;
          return c = this.trim(a), c = /^([^:/?#]+):\/\/[^/?#.]+\.[^/?#]+/i.test(c) ? c : function(a, b) {
            return b.href = a, b.href
          }(c, document.createElement("a")), c = encodeURI(decodeURI(c)), c = c.replace(/["`^|\\<>{}\[\]\s].*/, ""), c = b ? this.justifyPercentEncodingUrlCase_(a, c) : c
        }, a.canonicalizeUrl = function(a) {
          function b(a) {
            return a.toUpperCase()
          }
          var c = this.normalizeUrl(a, !1);
          return c = c.replace(/(?:%\w{2})+/g, b)
        }, a.compareUrl = function(a, b, c) {
          return c && (a = this.canonicalizeUrl(a), b = this.canonicalizeUrl(b)), a === this.justifyPercentEncodingUrlCase_(a, b)
        }, a.justifyPercentEncodingUrlCase_ = function(a, b) {
          function c(b) {
            var c = ~a.indexOf(b.toUpperCase()) || ~a.indexOf(b.toLowerCase());
            return c ? a.substr(~c, b.length) : b
          }
          return a === b ? b : b.replace(/(?:%\w{2})+/g, c)
        }, a
      }();
      a.Utility = b
    }(b = a.LIBRARY || (a.LIBRARY = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c, d = function() {
        function b(b, d, e) {
          for (var f = [], g = 3; g < arguments.length; g++) f[g - 3] = arguments[g];
          this.model_ = b, this.controller_ = d, this.state_ = -1, this.queue_ = [], this.HANDLERS = {}, c = d, this.UUID = a.GEN_UUID(), this.CONTEXT = e, this.OBSERVE.apply(this, f || []), this.state_ = 0
        }
        return b.prototype.OBSERVE = function() {
          for (var a = [], b = 0; b < arguments.length; b++) a[b - 0] = arguments[b]
        }, b.prototype.RELEASE = function() {
          for (var a = [], b = 0; b < arguments.length; b++) a[b - 0] = arguments[b]
        }, b.prototype.BIND = function() {
          for (var a = [], b = 0; b < arguments.length; b++) a[b - 0] = arguments[b];
          return this.UNBIND(), this
        }, b.prototype.UNBIND = function() {
          for (var a = [], b = 0; b < arguments.length; b++) a[b - 0] = arguments[b];
          return this
        }, b.EVENTS = {}, b.TRIGGERS = {}, b
      }();
      b.Template = d
    }(b = a.VIEW || (a.VIEW = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c, d = function(b) {
        function d(a, d, e, f) {
          b.call(this, a, d, e, f), this.model_ = a, this.controller_ = d, c = d
        }
        return __extends(d, b), d.prototype.OBSERVE = function(a) {
          var b = this.model_.stock(a);
          return this.CONTEXT.bind(b.nss.event, a, this.PRELOAD), this
        }, d.prototype.RELEASE = function(a) {
          var b = this.model_.stock(a);
          return this.CONTEXT.unbind(b.nss.event), this
        }, d.prototype.BIND = function(a, b) {
          var c = this.model_.stock(a);
          return this.UNBIND(a, b), b && this.CONTEXT.find(b.currentTarget).add(this.CONTEXT.filter(b.currentTarget)).find(c.link).filter(c.filter).bind(c.nss.click, a, this.CLICK).bind(c.nss.mouseover, a, this.MOUSEOVER).bind(c.nss.mousemove, a, this.MOUSEMOVE).bind(c.nss.mouseout, a, this.MOUSEOUT), this
        }, d.prototype.UNBIND = function(a, b) {
          var c = this.model_.stock(a);
          return b && this.CONTEXT.find(b.currentTarget).add(this.CONTEXT.filter(b.currentTarget)).find(c.link).filter(c.filter).unbind(c.nss.click).unbind(c.nss.mouseover).unbind(c.nss.mousemove).unbind(c.nss.mouseout), this
        }, d.prototype.RESET = function(a) {
          return this.CONTEXT.trigger(a.nss.event), this
        }, d.prototype.PRELOAD = function(a) {
          c.PRELOAD(a)
        }, d.prototype.CLICK = function(a) {
          c.CLICK(a)
        }, d.prototype.MOUSEMOVE = function(a) {
          c.MOUSEMOVE(a)
        }, d.prototype.MOUSEOVER = function(a) {
          c.MOUSEOVER(a)
        }, d.prototype.MOUSEOUT = function(a) {
          c.MOUSEOUT(a)
        }, d.EVENTS = {
          BIND: a.NAME
        }, d.TRIGGERS = {}, d
      }(b.Template);
      b.Main = d
    }(b = a.VIEW || (a.VIEW = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(MODULE) {
    var MODEL;
    ! function(MODEL) {
      var Util = MODULE.LIBRARY.Utility,
        Main = function(_super) {
          function Main() {
            _super.apply(this, arguments), this.controller_ = new MODULE.CONTROLLER.Main(this), this.loaded_ = {}
          }
          return __extends(Main, _super), Main.prototype.main_ = function(a, b) {
            var c, d = this;
            switch (c = a instanceof MODULE.NAMESPACE ? "m:" : "f:", c += b ? {}.toString.call(b).split(" ").pop().slice(0, -1).toLowerCase() : b, c.toLowerCase()) {
              case "f:number":
              case "f:0":
              case "f:string":
                b = {
                  link: b
                };
              case "f:":
              case "m:object":
              case "m:null":
              case "m:function":
              case "m:undefined":
            }
            a = a instanceof jQuery ? a : jQuery(document);
            var e = new this.stock(this.configure(b));
            this.stock({
              setting: e,
              queue: []
            });
            var f = e.encode ? Util.normalizeUrl(window.location.href) : window.location.href;
            return f = f.replace(/#.*/, ""), this.loaded_[f] = !0, a.uuid = e.uuid, jQuery(function() {
              e.view.push(new MODULE.VIEW.Main(d, d.controller_, a, e.uuid)), e.view[0].CONTEXT.trigger(e.nss.event), d.state_ = ~d.state_ ? d.state_ : 0
            }), this.cooldown(e), a
          }, Main.prototype.configure = function(a) {
            var b = jQuery.extend(!0, {}, a),
              c = {
                gns: MODULE.NAME,
                ns: null,
                link: "a:not([target])",
                filter: function() {
                  return /^https?:/.test(this.href) && /(\/[^.]*|\.html?|\.php)$/.test("/" + this.pathname)
                },
                lock: 1e3,
                forward: null,
                check: null,
                balance: {
                  host: null,
                  ajax: {
                    crossDomain: !0,
                    beforeSend: null
                  }
                },
                interval: 1e3,
                limit: 2,
                cooldown: 1e4,
                skip: 50,
                query: "",
                encode: !1,
                ajax: {
                  dataType: "text",
                  async: !0,
                  timeout: 1500
                }
              },
              d = {
                view: [],
                target: null,
                volume: 0,
                points: [],
                touch: !1,
                xhr: null,
                timeStamp: 0,
                option: a
              },
              e = function() {
                var a = [b.gns || MODULE.NAME].concat(b.ns && String(b.ns).split(".") || []);
                return {
                  nss: {
                    name: b.ns || "",
                    array: a,
                    event: a.join("."),
                    data: a.join("-"),
                    class4html: a.join("-"),
                    click: ["click"].concat(a.join(":")).join("."),
                    mousemove: ["mousemove"].concat(a.join(":")).join("."),
                    mouseover: ["mouseover"].concat(a.join(":")).join("."),
                    mouseout: ["mouseout"].concat(a.join(":")).join("."),
                    touchstart: ["touchstart"].concat(a.join(":")).join("."),
                    touchmove: ["touchmove"].concat(a.join(":")).join("."),
                    touchend: ["touchend"].concat(a.join(":")).join(".")
                  },
                  ajax: jQuery.extend(!0, {}, jQuery.ajaxSettings, b.ajax)
                }
              };
            return b = jQuery.extend(!0, {}, c, b, d), b = jQuery.extend(!0, {}, b, e())
          }, Main.prototype.cooldown = function(a) {
            ! function(a, b) {
              setTimeout(function c() {
                b.volume -= Number(!!b.volume), setTimeout(c, a)
              }, a, b)
            }(a.cooldown, a)
          }, Main.prototype.PRELOAD = function(a) {
            var b = this.stock(a.data);
            b.volume = 0, b.timeStamp = 0, b.view[0].BIND(a.data, a)
          }, Main.prototype.CLICK = function(a) {
            var b = this.stock(a.data),
              c = a.currentTarget;
            if (0 === this.state_) switch (a.timeStamp = (new Date).getTime(), b.encode && ("href" in c ? c.href = this.getURL_(b, c) : c.src = this.getURL_(b, c)), !a.isDefaultPrevented() && jQuery.data(a.currentTarget, b.nss.data)) {
              case "preload":
              case "lock":
                if (b.forward) {
                  var d = (this.getURL_(b, a.currentTarget), b.xhr.host);
                  delete b.xhr.host, !1 === Util.fire(b.forward, null, [a, b.xhr, d, b.timeStamp]) ? "lock" === jQuery.data(a.currentTarget, b.nss.data) ? a.preventDefault() : (this.click_(b, a), jQuery.removeData(a.currentTarget, b.nss.data)) : (b.xhr = null, a.preventDefault(), jQuery.removeData(a.currentTarget, b.nss.data))
                } else "lock" === jQuery.data(a.currentTarget, b.nss.data) ? a.preventDefault() : (this.click_(b, a), jQuery.removeData(a.currentTarget, b.nss.data));
                break;
              default:
                b.xhr && b.xhr.readyState < 4 && b.xhr.abort()
            }
          }, Main.prototype.MOUSEMOVE = function(a) {
            var b = this.stock(a.data);
            0 === this.state_ && (a.timeStamp = (new Date).getTime(), (!b.points.length || 30 < a.timeStamp - b.points[0].timeStamp) && (b.points.unshift(a), b.points = b.points.slice(0, 3), b.points.length >= 3 && this.check_(a, b)))
          }, Main.prototype.MOUSEOVER = function(a) {
            var b = this.stock(a.data);
            b.target = a.currentTarget
          }, Main.prototype.MOUSEOUT = function(a) {
            var b = this.stock(a.data);
            b.target = null
          }, Main.prototype.speed = function(a) {
            if (a.length < 3) return !1;
            var b, c, d, e;
            c = a[0].timeStamp - a[1].timeStamp, b = parseInt(String(Math.pow(a[0].pageX - a[1].pageX, 2) + Math.pow(a[0].pageY - a[1].pageY, 2) / (c || 1)), 10), e = a[1].timeStamp - a[2].timeStamp, d = parseInt(String(Math.pow(a[1].pageX - a[2].pageX, 2) + Math.pow(a[1].pageY - a[2].pageY, 2) / (e || 1)), 10);
            var f = 1e3 > c && 1e3 > e ? [b - d, b] : [];
            switch (!0) {
              case !f.length:
                break;
              case -50 > f[0] && 200 > f[1]:
              case -50 < f[0] && 50 > f[0] && -50 < f[1] && 50 > f[1]:
                return !0
            }
            return !1
          }, Main.prototype.check_ = function(a, b) {
            var c = this;
            switch (!0) {
              case b.volume >= b.limit:
              case b.points.length < 3:
              case b.points[2].pageX === a.pageX:
              case b.interval ? (new Date).getTime() - b.timeStamp < b.interval:
                !1: return;
              default:
                var d = function() {
                  var d = c.getURL_(b, a.currentTarget);
                  switch (d = d.replace(/#.*/, ""), !0) {
                    case b.target !== a.currentTarget:
                    case b.check ? !!Util.fire(b.check, a.currentTarget, [d]):
                      c.loaded_[d]:
                        case !b.ajax.crossDomain && (b.target.protocol !== window.location.protocol || b.target.host !== window.location.host):
                      return
                  }
                  c.drive_(a, b)
                };
                this.speed(b.points) && d()
            }
          }, Main.prototype.drive_ = function(a, b) {
            var c = this;
            b.xhr && b.xhr.readyState < 4 && b.xhr.abort(), this.loaded_[this.getURL_(b, a.currentTarget).replace(/#.*/, "")] = !0, ++b.volume, b.timeStamp = a.timeStamp, jQuery.data(a.currentTarget, b.nss.data, "preload"), b.lock && (jQuery.data(a.currentTarget, b.nss.data, "lock"), jQuery(a.currentTarget).one(b.nss.click, function(a) {
              if (jQuery.data(a.currentTarget, b.nss.data)) {
                var d = Math.max(b.lock - (new Date).getTime() + a.data, 0);
                jQuery.data(a.currentTarget, b.nss.data, "click"), d && (setTimeout(function() {
                  "click" === jQuery.data(a.currentTarget, b.nss.data) && c.click_(b, a), jQuery.removeData(a.currentTarget, b.nss.data)
                }, d), a.preventDefault())
              }
            })), this.preload_(a)
          }, Main.prototype.preload_ = function(event) {
            var setting = this.stock(event.data),
              host = setting.balance.host && setting.balance.host(),
              that = this,
              ajax = jQuery.extend(!0, {}, setting.ajax, {
                beforeSend: function(a, b) {
                  a.setRequestHeader("X-Preload", "true"), Util.fire(setting.ajax.beforeSend, this, [a, b])
                },
                success: function() {
                  time = (new Date).getTime() - time, Util.fire(setting.ajax.success, this, arguments), that.loaded_[url] = !0, (304 === arguments[2].status || time <= setting.skip) && (setting.volume -= Number(!!setting.volume), setting.timeStamp = 0), "click" === jQuery.data(event.currentTarget, setting.nss.data) && that.click_(setting, event), jQuery.removeData(event.currentTarget, setting.nss.data)
                },
                error: function() {
                  Util.fire(setting.ajax.error, this, arguments), setting.volume -= Number(!!setting.volume), setting.timeStamp = 0, jQuery.removeData(event.currentTarget, setting.nss.data)
                },
                complete: function() {
                  Util.fire(setting.ajax.complete, this, arguments)
                }
              }, host && setting.balance.ajax),
              query = setting.query;
            switch (query && typeof query) {
              case "string":
                query = eval("({" + query.match(/[^?=&]+=[^&]*/g).join("&").replace(/"/g, '\\"').replace(/([^?=&]+)=([^&]*)/g, '"$1": "$2"').replace(/&/g, ",") + "})");
              case "object":
                query = jQuery.param(query);
                break;
              default:
                query = ""
            }
            var url = this.getURL_(setting, event.currentTarget);
            url = host ? url.replace("//[^/]+", "//" + host) : url, url = query ? url.replace(/([^\?#]+)\??([^#]*)?(#.+)?/, "$1$2&" + query + "$3").replace(/\?&/, "?") : url, ajax.url = url;
            var time = (new Date).getTime();
            setting.xhr = jQuery.ajax(ajax), setting.xhr.host = host
          }, Main.prototype.click_ = function(a, b) {
            var c = this,
              d = b.currentTarget;
            a.xhr && a.xhr.readyState < 4 && a.xhr.abort(), jQuery(b.currentTarget).removeData(a.nss.data), jQuery(document).find(b.currentTarget).length && (jQuery(document).unbind(a.nss.click).one(a.nss.click, function(b) {
              b.isDefaultPrevented() || (window.location.href = a.encode ? Util.normalizeUrl(d.href) : d.href, a.encode && (window.location.href = c.getURL_(a, b.currentTarget)))
            }), jQuery(b.currentTarget).click()), b.preventDefault()
          }, Main.prototype.getURL_ = function(a, b) {
            var c;
            switch (b.tagName.toLowerCase()) {
              case "a":
              case "link":
                c = b.href;
                break;
              case "script":
              case "img":
              case "iframe":
                c = b.src
            }
            return a.encode ? Util.normalizeUrl(c) : c
          }, Main
        }(MODEL.Template);
      MODEL.Main = Main
    }(MODEL = MODULE.MODEL || (MODULE.MODEL = {}))
  }(MODULE || (MODULE = {})), new MODULE.MODEL.Main
}(window, window.document, void 0, jQuery);


/*! jquery-pjax v2.38.0 | (c) 2012, falsandtru | MIT Licence */
!new function(window, document, undefined, $) {
  "use strict";
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      a.NAME = "pjax", a.NAMESPACE = jQuery
    }(b = a.DEF || (a.DEF = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    ! function(a) {
      a[a.blank = 0] = "blank", a[a.initiate = 1] = "initiate", a[a.open = 2] = "open", a[a.pause = 3] = "pause", a[a.lock = 4] = "lock", a[a.seal = 5] = "seal", a[a.error = 6] = "error", a[a.crash = 7] = "crash", a[a.terminate = 8] = "terminate", a[a.close = 9] = "close"
    }(a.State || (a.State = {}));
    a.State;
    a.EVENT = {
      PJAX: a.DEF.NAME.toLowerCase(),
      CLICK: "click",
      SUBMIT: "submit",
      POPSTATE: "popstate",
      SCROLL: "scroll"
    }
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function() {}(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function() {}(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b;
        ! function() {}(b = a.DATA || (a.DATA = {}))
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    function b(a, b) {
      var c = a.prototype;
      b = b.reverse();
      for (var d = b.length; d--;) {
        var e = b[d].prototype;
        for (var f in e) "constructor" !== f && c[f] && e.hasOwnProperty(f) && (c[f] = e[f])
      }
    }

    function c() {
      function a(a) {
        var b = 16 * Math.random() | 0,
          c = "x" == a ? b : 3 & b | 8;
        return c.toString(16).toUpperCase()
      }
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, a)
    }

    function d(a, b) {
      if (!Object.freeze || a === a.window || "ownerDocument" in a) return a;
      if (!Object.isFrozen(a) && Object.freeze(a), !b) return a;
      for (var c in a) {
        var e = a[c];
        ~"object,function".indexOf(typeof e) && e && d(e, b)
      }
      return a
    }

    function e(a, b) {
      if (!Object.seal || a === a.window || "ownerDocument" in a) return a;
      if (!Object.isSealed(a) && Object.seal(a), !b) return a;
      for (var c in a) {
        var d = a[c];
        ~"object,function".indexOf(typeof d) && d && e(d, b)
      }
      return a
    }
    a.MIXIN = b, a.UUID = c, a.FREEZE = d, a.SEAL = e
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function() {}(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c = function() {
        function b(b) {
          this.NAME = a.DEF.NAME, this.NAMESPACE = a.DEF.NAMESPACE, this.UUID = a.UUID(), this.state_ = 0, this.state_ = b
        }
        return b.prototype.MAIN = function(a) {
          for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
          return this.main_.apply(this, [a].concat(b))
        }, b.prototype.main_ = function(a) {
          for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
          return a
        }, b
      }();
      b.Template = c
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c = function() {
        function b(b) {
          this.UUID = a.UUID(), this.state_ = 0, this.state_ = b
        }
        return b
      }();
      b.Template = c
    }(b = a.VIEW || (a.VIEW = {}))
  }(MODULE || (MODULE = {}));
  var __extends = this.__extends || function(a, b) {
      function c() {
        this.constructor = a
      }
      for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
      c.prototype = b.prototype, a.prototype = new c
    },
    MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c = function(b) {
        function c(c, d, e, f) {
          var g = this;
          b.call(this, 1), this.model_ = c, this.controller_ = d, this.context_ = e, this.handlers = {
            click: function() {
              g.controller_.click(arguments)
            },
            submit: function() {
              g.controller_.submit(arguments)
            },
            popstate: function() {
              g.controller_.popstate(arguments)
            },
            scroll: function() {
              g.controller_.scroll(arguments)
            }
          }, a.FREEZE(this), this.observe_(f)
        }
        return __extends(c, b), c.prototype.observe_ = function(a) {
          return this.release_(a), a.link && this.context_.delegate(a.link, a.nss.event.click, this.handlers.click), a.form && this.context_.delegate(a.form, a.nss.event.submit, this.handlers.submit), jQuery(window).bind(a.nss.event.popstate, this.handlers.popstate), a.database.active && a.fix.scroll && jQuery(window).bind(a.nss.event.scroll, this.handlers.scroll), this
        }, c.prototype.release_ = function(a) {
          return a.link && this.context_.undelegate(a.link, a.nss.event.click), a.form && this.context_.undelegate(a.form, a.nss.event.submit), jQuery(window).unbind(a.nss.event.popstate), a.database.active && a.fix.scroll && jQuery(window).unbind(a.nss.event.scroll), this
        }, c
      }(b.Template);
      b.Main = c
    }(b = a.VIEW || (a.VIEW = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    a.View = a.VIEW.Main
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c = function() {
        function b() {
          a.FREEZE(this)
        }
        return b.prototype.enable = function() {
          return a.Model.singleton().enable(), this
        }, b.prototype.disable = function() {
          return a.Model.singleton().disable(), this
        }, b.prototype.click = function(b, c) {
          var d;
          switch (typeof b) {
            case "undefined":
              d = jQuery(this).filter("a").first().clone();
              break;
            case "object":
              d = jQuery(b).clone();
              break;
            case "string":
              c = jQuery.extend(!0, {}, c, {
                href: b
              }), d = jQuery("<a/>", c);
              break;
            default:
              return this
          }
          var e = a.Model.singleton().configure(d[0]);
          return e && d.first().one(e.nss.event.click, function() {
            return a.Controller.singleton().click(arguments)
          }).click(), this
        }, b.prototype.submit = function(b, c, d) {
          var e, f, g, h = document.createDocumentFragment();
          switch (typeof b) {
            case "undefined":
              e = jQuery(this).filter("form").first().clone();
              break;
            case "object":
              e = jQuery(b).clone();
              break;
            case "string":
              c = jQuery.extend(!0, {}, c, {
                action: b
              }), f = d instanceof Array && Array || d instanceof Object && Object || undefined;
              for (var i in d) {
                switch (f) {
                  case Object:
                    if (!Object.prototype.hasOwnProperty.call(d, i)) continue;
                    g = jQuery("<textarea/>", {
                      name: i
                    }).val(d[i]);
                    break;
                  case Array:
                    d[i].attrs = d[i].attrs || {}, d[i].attrs.name = d[i].name || d[i].attrs.name, d[i].attrs.type = d[i].type || d[i].attrs.type, g = jQuery("<" + d[i].tag + "/>", d[i].attrs).val(d[i].value);
                    break;
                  default:
                    continue
                }
                h.appendChild(g[0])
              }
              e = jQuery("<form/>", c).append(h);
              break;
            default:
              return this
          }
          var j = a.Model.singleton().configure(e[0]);
          return j && e.first().one(j.nss.event.submit, function() {
            return a.Controller.singleton().submit(arguments)
          }).submit(), this
        }, b.prototype.getCache = function(b) {
          void 0 === b && (b = window.location.href);
          var c = a.Model.singleton().getCache(b);
          return c && (c = {
            data: c.data,
            textStatus: c.textStatus,
            jqXHR: c.jqXHR,
            expires: c.expires
          }), c
        }, b.prototype.setCache = function(b, c, d, e) {
          switch (void 0 === b && (b = window.location.href), arguments.length) {
            case 0:
              return this.setCache(b, document.documentElement.outerHTML);
            case 1:
              return this.setCache(b, null);
            case 2:
            case 3:
            case 4:
            default:
              a.Model.singleton().setCache(b, c, d, e)
          }
          return this
        }, b.prototype.removeCache = function(b) {
          return void 0 === b && (b = window.location.href), a.Model.singleton().removeCache(b), this
        }, b.prototype.clearCache = function() {
          return a.Model.singleton().clearCache(), this
        }, b.prototype.follow = function(b, c, d, e) {
          if (!a.Model.singleton().isDeferrable) return !1;
          var f = b.currentTarget;
          return c.follow = !0, c.host = d || "", isFinite(b.timeStamp) && (c.timeStamp = e || b.timeStamp), a.Model.singleton().setXHR(c), jQuery.when(c).done(function() {
            !a.Model.singleton().getCache(f.href) && a.Model.singleton().isOperatable(b) && a.Model.singleton().setCache(f.href, undefined, undefined, c)
          }), jQuery[a.DEF.NAME].click(f.href), !0
        }, b.prototype.bypass = function() {
          return a.Model.singleton().bypass()
        }, b.prototype.host = function() {
          return a.Model.singleton().host()
        }, b
      }();
      b.Functions = c
    }(b = a.CONTROLLER || (a.CONTROLLER = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c = function() {
        function b() {
          a.FREEZE(this)
        }
        return b
      }();
      b.Methods = c
    }(b = a.CONTROLLER || (a.CONTROLLER = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c = function() {
        function b(b, c) {
          this.UUID = a.UUID(), this.state_ = 0, this.PROPERTIES = [], this.state_ = c
        }
        return b.prototype.EXTEND = function(b) {
          return b instanceof a.DEF.NAMESPACE ? (b instanceof jQuery && (b = b.add()), this.REGISTER_FUNCTION(b), this.REGISTER_METHOD(b)) : (b !== this.EXTENSION && (b = this.EXTENSION), this.REGISTER_FUNCTION(b)), this.UPDATE_PROPERTIES(b), b
        }, b.prototype.REGISTER = function(b) {
          var c = this;
          this.EXTENSION = this.EXTENSION || function() {
            for (var a = [], d = 0; d < arguments.length; d++) a[d - 0] = arguments[d];
            var e = c.EXTEND(this);
            return a = [e].concat(a), a = c.EXEC.apply(c, a), a instanceof Array ? b.MAIN.apply(b, a) : a
          }, this.EXTEND(this.EXTENSION), window[a.DEF.NAMESPACE] = window[a.DEF.NAMESPACE] || {}, a.DEF.NAMESPACE[a.DEF.NAME] = a.DEF.NAMESPACE.prototype ? a.DEF.NAMESPACE.prototype[a.DEF.NAME] = this.EXTENSION : this.EXTENSION
        }, b.prototype.EXEC = function() {
          return this.exec_.apply(this, arguments)
        }, b.prototype.exec_ = function(a) {
          for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];
          return [a].concat(b)
        }, b.prototype.REGISTER_FUNCTION = function(a) {
          var b = this.FUNCTIONS;
          for (var c in b) "constructor" !== c && (a[c] = b[c]);
          return a
        }, b.prototype.REGISTER_METHOD = function(a) {
          var b = this.METHODS;
          for (var c in b) "constructor" !== c && (a[c] = b[c]);
          return a
        }, b.prototype.UPDATE_PROPERTIES = function(a) {
          var b, c, d, e = this.PROPERTIES;
          for (b = 0, c = e.length; c > b; b++) "constructor" !== b && (d = e[b], a[d] && (a[d] = a[d]()));
          return a
        }, b
      }();
      b.Template = c
    }(b = a.CONTROLLER || (a.CONTROLLER = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c = function(c) {
        function d(d) {
          c.call(this, d, 1), this.model_ = d, this.FUNCTIONS = new b.Functions, this.METHODS = new b.Methods, this.REGISTER(d), a.FREEZE(this)
        }
        return __extends(d, c), d.prototype.exec_ = function(a) {
          var b = [].slice.call(arguments, 1, 2),
            c = b[0];
          switch (typeof c) {
            case "undefined":
            case "object":
              break;
            default:
              return a
          }
          return [a].concat(b)
        }, d.prototype.view = function(b, c) {
          return new a.View(this.model_, this, b, c)
        }, d.prototype.click = function(a) {
          this.model_.click.apply(this.model_, a)
        }, d.prototype.submit = function(a) {
          this.model_.submit.apply(this.model_, a)
        }, d.prototype.popstate = function(a) {
          this.model_.popstate.apply(this.model_, a)
        }, d.prototype.scroll = function(a) {
          this.model_.scroll.apply(this.model_, a)
        }, d
      }(b.Template);
      b.Main = c;
      var d = function() {
        function b(d) {
          void 0 === d && (d = a.Model.singleton()), b.instance_ = b.instance_ || new c(d)
        }
        return b.singleton = function() {
          return b.instance_
        }, b.prototype.singleton = function() {
          return b.singleton()
        }, b
      }();
      b.Singleton = d
    }(b = a.CONTROLLER || (a.CONTROLLER = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    a.Controller = a.CONTROLLER.Singleton
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b = function() {
        function a(a, b) {
          void 0 === a && (a = 1), void 0 === b && (b = 0), this.list_ = [], this.config_ = {
            mode: 1,
            size: 0
          }, this.table_ = {}, this.option_ = {}, this.config_.mode = a || this.config_.mode, this.config_.size = b || this.config_.size
        }
        return a.prototype.define = function(a, b, c) {
          void 0 === b && (b = this.config_.mode), void 0 === c && (c = this.config_.size), this.option_[a] = {
            mode: b,
            size: c
          }, this.table_[a] = []
        }, a.prototype.reserve = function(a, b) {
          switch (typeof a) {
            case "string":
              !this.option_[a] && this.define(a);
              var c = this.option_[a],
                d = this.table_[a],
                e = [].slice.call(arguments, 2);
              break;
            case "function":
              b = a, a = undefined;
              var c = this.config_,
                d = this.list_,
                e = [].slice.call(arguments, 1);
              break;
            default:
              return
          }
          if ("function" == typeof b) {
            var f;
            f = c.mode > 0 ? "push" : "unshift", d[f]([b, e.shift(), e])
          }
        }, a.prototype.digest = function(a, b) {
          switch (typeof a) {
            case "string":
              !this.option_[a] && this.define(a), b = b || 0;
              var c = this.option_[a],
                d = this.table_[a];
              if (!d) return;
              break;
            case "number":
            case "undefined":
              b = a || 0, a = undefined;
              var c = this.config_,
                d = this.list_;
              break;
            default:
              return
          }
          d.length > c.size && c.size && (c.mode > 0 ? d.splice(0, d.length - c.size) : d.splice(d.length - c.size, d.length));
          var e;
          for (b = b || -1; e = b-- && d.pop();) e.shift().apply(e.shift() || window, e.shift() || []);
          if (undefined === a) {
            var f = this.table_;
            for (var g in f) this.digest(g, b)
          }
        }, a.prototype.clear = function(a) {
          switch (typeof a) {
            case "string":
              !this.option_[a] && this.define(a), this.table_[a].splice(0, this.table_[a].length);
              break;
            default:
              var b = this.table_;
              for (var c in b) this.clear(c)
          }
        }, a
      }();
      a.Task = b
    }(b = a.LIBRARY || (a.LIBRARY = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b;
        ! function(a) {
          var b;
          ! function(a) {
            var b;
            ! function(a) {
              var b = function() {
                function a(a) {
                  this.task_ = a, this.labels_ = {
                    done: "done",
                    fail: "fail",
                    always: "always"
                  }
                }
                return a.prototype.done = function(a) {
                  return this.task_.reserve(this.labels_.done, a), this
                }, a.prototype.fail = function(a) {
                  return this.task_.reserve(this.labels_.fail, a), this
                }, a.prototype.always = function(a) {
                  return this.task_.reserve(this.labels_.always, a), this
                }, a.prototype.resolve = function() {
                  return this.task_.clear(this.labels_.fail), this.task_.digest(this.labels_.done), this.task_.digest(this.labels_.always), this
                }, a.prototype.reject = function() {
                  return this.task_.clear(this.labels_.done), this.task_.digest(this.labels_.fail), this.task_.digest(this.labels_.always), this
                }, a
              }();
              a.Task = b;
              var c = function(a) {
                function b() {
                  a.apply(this, arguments)
                }
                return __extends(b, a), b
              }(b);
              a.TaskUp = c;
              var d = function(a) {
                function b() {
                  a.apply(this, arguments)
                }
                return __extends(b, a), b.prototype.done = function() {
                  return this
                }, b.prototype.fail = function() {
                  return this
                }, b.prototype.always = function() {
                  return this
                }, b.prototype.resolve = function() {
                  return this
                }, b
              }(b);
              a.TaskDown = d
            }(b = a.STATEFUL || (a.STATEFUL = {}))
          }(b = a.DB || (a.DB = {}))
        }(b = a.DATA || (a.DATA = {}))
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c;
      ! function(b) {
        var c;
        ! function(b) {
          var c;
          ! function(b) {
            var c = function() {
              function c(b, c, d) {
                var e = this;
                this.origin_ = b, this.connect_ = c, this.extend_ = d, this.state_ = function() {
                  return e.origin_.state()
                }, this.task_ = new a.LIBRARY.Task, this.cache_ = {
                  stateful: {}
                }
              }
              return c.prototype.stateful_ = function() {
                var a = this,
                  c = function(b, c) {
                    return a.cache_.stateful[a.state_()] = a.cache_.stateful[a.state_()] || new b(a.origin_, a.connect_, a.extend_, a.task_, c)
                  };
                switch (this.state_()) {
                  case 0:
                    return c(b.STATE.Blank, !0);
                  case 1:
                    return c(b.STATE.Initiate, !0);
                  case 2:
                    return c(b.STATE.Open, !0);
                  case 9:
                    return c(b.STATE.Close, !0);
                  case 8:
                    return c(b.STATE.Terminate, !0);
                  case 6:
                    return c(b.STATE.Error, !1);
                  default:
                    return c(b.STATE.Except, !1)
                }
              }, c.prototype.open = function() {
                return this.stateful_().open()
              }, c.prototype.resolve = function() {
                return this.stateful_().resolve()
              }, c.prototype.reject = function() {
                return this.stateful_().reject()
              }, c
            }();
            b.Stateful = c
          }(c = b.DB || (b.DB = {}))
        }(c = b.DATA || (b.DATA = {}))
      }(c = b.APP || (b.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b;
        ! function(a) {
          var b;
          ! function(a) {
            var b;
            ! function(b) {
              var c = function() {
                function b(b, c, d, e, f) {
                  this.origin = b, this.connect = c, this.extend = d, this.task = f ? new a.STATEFUL.TaskUp(e) : new a.STATEFUL.TaskDown(e)
                }
                return b.prototype.open = function() {
                  return this.task
                }, b.prototype.resolve = function() {}, b.prototype.reject = function() {
                  this.task.reject()
                }, b
              }();
              b.Default = c;
              var d = function(a) {
                function b() {
                  a.apply(this, arguments)
                }
                return __extends(b, a), b.prototype.open = function() {
                  return this.connect(), this.task
                }, b.prototype.resolve = function() {
                  this.open()
                }, b.prototype.reject = function() {
                  this.task.reject()
                }, b
              }(c);
              b.Blank = d;
              var e = function(a) {
                function b() {
                  a.apply(this, arguments)
                }
                return __extends(b, a), b.prototype.open = function() {
                  return this.task
                }, b.prototype.resolve = function() {}, b.prototype.reject = function() {
                  this.task.reject()
                }, b
              }(c);
              b.Initiate = e;
              var f = function(a) {
                function b() {
                  a.apply(this, arguments)
                }
                return __extends(b, a), b.prototype.open = function() {
                  var a = this;
                  return this.extend(), setTimeout(function() {
                    return a.origin.resolve()
                  }, 1), this.task
                }, b.prototype.resolve = function() {
                  this.task.resolve()
                }, b.prototype.reject = function() {
                  this.task.reject()
                }, b
              }(c);
              b.Open = f;
              var g = function(a) {
                function b() {
                  a.apply(this, arguments)
                }
                return __extends(b, a), b.prototype.open = function() {
                  return this.connect(), this.task
                }, b.prototype.resolve = function() {
                  this.open()
                }, b.prototype.reject = function() {
                  this.task.reject()
                }, b
              }(c);
              b.Close = g;
              var h = function(a) {
                function b() {
                  a.apply(this, arguments)
                }
                return __extends(b, a), b
              }(c);
              b.Terminate = h;
              var i = function(a) {
                function b() {
                  a.apply(this, arguments)
                }
                return __extends(b, a), b
              }(c);
              b.Error = i;
              var j = function(a) {
                function b() {
                  a.apply(this, arguments)
                }
                return __extends(b, a), b
              }(c);
              b.Except = j
            }(b = a.STATE || (a.STATE = {}))
          }(b = a.DB || (a.DB = {}))
        }(b = a.DATA || (a.DATA = {}))
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b;
        ! function(a) {
          var b = function() {
            function a(a) {
              this.DB = a, this.autoIncrement = !1, this.indexes = [], this.size = 100, this.buffer = {}, this.diff = {}
            }
            return a.prototype.accessStore = function(a, b) {
              var c = this;
              void 0 === b && (b = "readwrite");
              try {
                var d = this.DB.database(),
                  e = d && d.transaction(this.name, b).objectStore(this.name)
              } catch (f) {}
              e ? a(e) : this.DB.open().done(function() {
                return c.accessStore(a)
              })
            }, a.prototype.accessCount = function() {
              var a = "string" == typeof arguments[0] && arguments[0],
                b = arguments[a ? 1 : 0];
              this.accessStore(function(c) {
                var d = a ? c.index(a).count() : c.count();
                d.onsuccess = function() {
                  b.apply(this, [].slice.call(arguments, 1).concat(this.result))
                }
              })
            }, a.prototype.accessRecord = function(a, b, c) {
              this.accessStore(function(c) {
                c.get(a).onsuccess = b
              }, c)
            }, a.prototype.accessCursor = function(a, b, c, d) {
              this.accessStore(function(e) {
                var f;
                f = c && b ? e.index(a).openCursor(b, c) : b ? e.index(a).openCursor(b) : e.openCursor(), f.onsuccess = d
              })
            }, a.prototype.accessAll = function(a, b, c, d) {
              "function" == typeof a && (d = a, a = null, b = null, c = null), this.accessCursor(a, b, c, d)
            }, a.prototype.get = function(a, b) {
              var c = this;
              this.accessRecord(a, function(a) {
                c.setBuffer(a.target.result), b(a)
              })
            }, a.prototype.set = function(a, b) {
              var c = this;
              a = jQuery.extend(!0, {}, a), this.setBuffer(a, b), this.accessRecord(a[this.keyPath], function(d) {
                d.target.source.put(b ? jQuery.extend(!0, {}, d.target.result, a) : a), c.autoIncrement || delete c.diff[a[c.keyPath]]
              })
            }, a.prototype.remove = function(a) {
              this.removeBuffer(a), this.accessStore(function(b) {
                b["delete"](a)
              })
            }, a.prototype.clear = function() {
              this.clearBuffer(), this.accessStore(function(a) {
                a.clear()
              })
            }, a.prototype.clean = function() {
              var a = this;
              if (this.size && this.indexes.length) {
                var b = this.indexes[0].name,
                  c = this.size;
                this.accessCount(b, function(d) {
                  c >= d || (c = d - c, a.accessCursor(b, a.DB.IDBKeyRange.upperBound(1 / 0), "next", function(b) {
                    if (b.target.result && c--) {
                      var d = b.target.result;
                      delete a.diff[d.primaryKey], d["delete"](), d["continue"]()
                    }
                  }))
                })
              }
            }, a.prototype.loadBuffer = function(a) {
              function b() {
                if (!this.result) return a && a();
                var b = this.result;
                c[b.primaryKey] = b.value, b["continue"]()
              }
              if (!this.autoIncrement) {
                var c = this.buffer;
                this.indexes.length ? this.DB.IDBKeyRange && this.accessAll(this.indexes[0].name, this.DB.IDBKeyRange.upperBound(1 / 0), "prev", b) : this.accessAll(b)
              }
            }, a.prototype.saveBuffer = function(a) {
              var b = this;
              this.autoIncrement || this.accessStore(function(c) {
                for (var d in b.diff) c.put(b.diff[d]);
                a && a()
              })
            }, a.prototype.getBuffers = function() {
              return this.buffer
            }, a.prototype.setBuffers = function(a, b) {
              for (var c in a) this.setBuffer(a[c], b);
              return this.buffer
            }, a.prototype.getBuffer = function(a) {
              return this.autoIncrement ? void 0 : this.buffer[a]
            }, a.prototype.setBuffer = function(a, b) {
              if (!this.autoIncrement) {
                if (!a) return a;
                var c = a[this.keyPath];
                return this.buffer[c] = b ? jQuery.extend(!0, {}, this.buffer[c], a) : a, this.diff[c] = this.buffer[c], this.buffer[c]
              }
            }, a.prototype.removeBuffer = function(a) {
              if (!this.autoIncrement) {
                var b = this.buffer[a];
                return delete this.buffer[a], delete this.diff[a], b
              }
            }, a.prototype.clearBuffer = function() {
              if (!this.autoIncrement) {
                for (var a in this.buffer) delete this.buffer[a];
                for (var a in this.diff) delete this.diff[a]
              }
            }, a
          }();
          a.Store = b
        }(b = a.DATA || (a.DATA = {}))
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b;
        ! function(a) {
          var b;
          ! function(b) {
            var c = function(a) {
              function b() {
                a.apply(this, arguments), this.name = "meta", this.keyPath = "key", this.autoIncrement = !1, this.size = 0
              }
              return __extends(b, a), b
            }(a.Store);
            b.Meta = c
          }(b = a.STORE || (a.STORE = {}))
        }(b = a.DATA || (a.DATA = {}))
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b;
        ! function(a) {
          var b;
          ! function(b) {
            var c = function(a) {
              function b() {
                a.apply(this, arguments), this.name = "history", this.keyPath = "url", this.autoIncrement = !1, this.indexes = [{
                  name: "date",
                  keyPath: "date",
                  option: {
                    unique: !1
                  }
                }], this.size = 300
              }
              return __extends(b, a), b
            }(a.Store);
            b.History = c
          }(b = a.STORE || (a.STORE = {}))
        }(b = a.DATA || (a.DATA = {}))
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b;
        ! function(a) {
          var b;
          ! function(b) {
            var c = function(a) {
              function b() {
                a.apply(this, arguments), this.name = "server", this.keyPath = "host", this.autoIncrement = !1, this.indexes = [{
                  name: "score",
                  keyPath: "score",
                  option: {
                    unique: !1
                  }
                }], this.size = 100
              }
              return __extends(b, a), b
            }(a.Store);
            b.Server = c
          }(b = a.STORE || (a.STORE = {}))
        }(b = a.DATA || (a.DATA = {}))
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c;
      ! function(b) {
        var c;
        ! function(b) {
          var c = function() {
            function c() {
              var c = this;
              this.IDBFactory = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB, this.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.mozIDBKeyRange || window.msIDBKeyRange, this.name = a.DEF.NAME, this.version = 10, this.refresh = 10, this.upgrade = 0, this.revision = 0, this.state_ = 0, this.stateful = new b.DB.Stateful(this, function() {
                return c.connect()
              }, function() {
                return c.extend()
              }), this.age = 1e4, this.expires = 0, this.timer = 0, this.stores = {
                meta: new b.STORE.Meta(this),
                history: new b.STORE.History(this),
                server: new b.STORE.Server(this)
              }, this.meta = {
                version: {
                  key: "version",
                  value: undefined
                },
                update: {
                  key: "update",
                  value: undefined
                },
                revision: {
                  key: "revision",
                  value: undefined
                }
              }
            }
            return c.prototype.state = function() {
              return this.state_
            }, c.prototype.extend = function() {
              var a = this;
              this.expires = (new Date).getTime() + this.age, clearTimeout(this.timer), this.timer = setTimeout(function() {
                return a.check()
              }, this.age)
            }, c.prototype.check = function() {
              !this.age || (new Date).getTime() <= this.expires || 2 === this.state() && this.close()
            }, c.prototype.database = function() {
              return this.extend(), this.database_
            }, c.prototype.configure = function(a, b) {
              this.revision = a, this.refresh = b
            }, c.prototype.up = function() {
              this.state_ = 0, this.open()
            }, c.prototype.down = function() {
              this.reject(), this.close(), this.state_ = 6
            }, c.prototype.open = function() {
              return !this.IDBFactory && this.down(), this.stateful.open()
            }, c.prototype.close = function() {
              this.database_ && this.database_.close && this.database_.close(), this.state_ = 9
            }, c.prototype.resolve = function() {
              this.stateful.resolve()
            }, c.prototype.reject = function() {
              this.stateful.reject()
            }, c.prototype.connect = function() {
              this.create()
            }, c.prototype.create = function() {
              var a = this;
              try {
                this.close(), this.state_ = 1;
                var b = this.IDBFactory.open(this.name, this.upgrade ? this.version : 1),
                  c = function() {
                    a.verify(function() {
                      a.state_ = 2, a.resolve(), a.extend()
                    })
                  };
                if ("done" === b.readyState) this.database_ = b.result, this.database() ? c() : this.format();
                else {
                  var d = setTimeout(function() {
                    return a.down()
                  }, 3e3);
                  b.onblocked = function() {
                    clearTimeout(d), a.database_ = b.result, a.close(), setTimeout(function() {
                      return a.open()
                    }, 1e3)
                  }, b.onupgradeneeded = function() {
                    clearTimeout(d), a.database_ = b.result, a.createStores()
                  }, b.onsuccess = function() {
                    clearTimeout(d), a.database_ = b.result, c()
                  }, b.onerror = function() {
                    clearTimeout(d), a.database_ = b.result, a.down()
                  }
                }
              } catch (e) {
                this.down()
              }
            }, c.prototype.destroy = function(a, b) {
              var c = this;
              try {
                this.close(), this.state_ = 8;
                var d = this.IDBFactory.deleteDatabase(this.name);
                d && (d.onsuccess = a, d.onerror = b), setTimeout(function() {
                  return 8 === c.state() && c.down()
                }, 3e3)
              } catch (e) {
                this.down()
              }
            }, c.prototype.format = function() {
              var a = this;
              this.destroy(function() {
                return a.up()
              }, function() {
                return a.down()
              })
            }, c.prototype.verify = function(a) {
              var b = this,
                c = this.database(),
                d = this.version,
                e = this.revision,
                f = this.meta,
                g = this.stores.meta,
                h = function() {
                  return b.format()
                };
              if (c.objectStoreNames.length !== Object.keys(this.stores).length) return void h();
              for (var i in this.stores) {
                var j = c.transaction(this.stores[i].name, "readonly").objectStore(this.stores[i].name);
                switch (!1) {
                  case j.keyPath === this.stores[i].keyPath:
                  case j.indexNames.length === this.stores[i].indexes.length:
                    return void h()
                }
              }
              var k = !1;
              g.get(f.version.key, function(a) {
                if (!k) {
                  var c = a.target.result;
                  !c || b.upgrade ? g.set(g.setBuffer({
                    key: f.version.key,
                    value: d
                  })) : c.value > d ? (k = !0, b.down()) : c.value < d && (k = !0, h())
                }
              }), g.get(f.revision.key, function(a) {
                if (!k) {
                  var c = a.target.result;
                  c ? c.value > e ? (k = !0, b.down()) : c.value < e && (k = !0, h()) : g.set(g.setBuffer({
                    key: f.revision.key,
                    value: e
                  }))
                }
              }), g.get(f.update.key, function(c) {
                if (!k) {
                  var d = c.target.result,
                    e = Math.floor((new Date).getTime() / 864e5);
                  d && b.refresh ? d.value > e ? a() : d.value <= e && h() : (g.set(g.setBuffer({
                    key: f.update.key,
                    value: e + b.refresh
                  })), a())
                }
              })
            }, c.prototype.createStores = function() {
              this.destroyStores();
              var a = this.database();
              for (var b in this.stores)
                for (var c, d = this.stores[b], e = a.createObjectStore(d.name, {
                    keyPath: d.keyPath,
                    autoIncrement: d.autoIncrement
                  }), f = 0, g = d.indexes; c = g[f]; f++) e.createIndex(c.name, c.keyPath, c.option)
            }, c.prototype.destroyStores = function() {
              for (var a = this.database(), b = a.objectStoreNames ? a.objectStoreNames.length : 0; b--;) a.deleteObjectStore(a.objectStoreNames[b])
            }, c
          }();
          b.Database = c
        }(c = b.DATA || (b.DATA = {}))
      }(c = b.APP || (b.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b;
        ! function(a) {
          var b = function() {
            function a(a) {
              this.age_ = a
            }
            return a.prototype.getCookie = function(a) {
              if (a && window.navigator.cookieEnabled) {
                var b = new RegExp("(?:^|; )(" + encodeURIComponent(a) + "=[^;]*)"),
                  c = (document.cookie.match(b) || []).pop();
                return c && decodeURIComponent(c.split("=").pop())
              }
            }, a.prototype.setCookie = function(a, b, c) {
              return void 0 === c && (c = {}), a && window.navigator.cookieEnabled ? (c.age = c.age || this.age_, document.cookie = [encodeURIComponent(a) + "=" + encodeURIComponent(b), c.age ? "; expires=" + new Date((new Date).getTime() + 1e3 * c.age).toUTCString() : "", c.path ? "; path=" + c.path : "; path=/", c.secure ? "; secure" : ""].join(""), this.getCookie(a)) : void 0
            }, a
          }();
          a.Cookie = b
        }(b = a.DATA || (a.DATA = {}))
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b;
        ! function(a) {
          var b = function() {
            function b() {
              this.DB = new a.Database, this.Cookie = new a.Cookie(864e3)
            }
            return b
          }();
          a.Main = b
        }(b = a.DATA || (a.DATA = {}))
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b = function() {
        function a() {}
        return a.trim = function(a) {
          if (a = "string" == typeof a ? a : String(0 === a && a.toString() || ""), a.trim) a = a.trim();
          else if (a = a.replace(/^[\s\uFEFF\xA0]+/, "")) {
            var b = /[\s\uFEFF\xA0]/,
              c = a.length,
              d = c % 8;
            a: {
              for (; d--;)
                if (!b.test(a.charAt(--c))) break a;
              for (; c;) {
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a;
                if (!b.test(a.charAt(--c))) break a
              }
            }
            a = a.substring(0, c + 1)
          }
          return a
        }, a.repeat = function(a, b) {
          switch (a instanceof Array && "array" || typeof a) {
            case "string":
              var c = a;
              return Array(b + 1).join(c);
            case "array":
              var d = a.length;
              if (300 > b) {
                var e = Array(b);
                this.duff(-b, function(b) {
                  return e[b] = a[b % d]
                })
              } else {
                for (var e = a.slice(); 2 * e.length <= b;) e = e.concat(e);
                e = e.concat(e.slice(0, b - e.length))
              }
              return e
          }
        }, a.fire = function(a, b, c, d) {
          return void 0 === b && (b = window), void 0 === c && (c = []), "function" == typeof a ? d ? setTimeout(function() {
            a.apply(b || window, c)
          }, 0) : a.apply(b || window, c) : a
        }, a.duff = function(a, b) {
          if (0 > a) {
            for (var c = -a, d = c % 8; d--;) b(--c);
            for (; c;) b(--c), b(--c), b(--c), b(--c), b(--c), b(--c), b(--c), b(--c)
          } else {
            for (var e = a, c = 0, d = e % 8, f = e / 8 ^ 0; d--;) b(c++);
            for (; f--;) b(c++), b(c++), b(c++), b(c++), b(c++), b(c++), b(c++), b(c++)
          }
        }, a.duffEx = function(a, b) {
          if (0 > a) {
            var c = -a,
              d = c % 8;
            a: {
              for (; d--;)
                if (!1 === b(--c)) break a;
              for (; c;) {
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a;
                if (!1 === b(--c)) break a
              }
            }
          } else {
            var e = a,
              c = 0,
              d = e % 8,
              f = e / 8 ^ 0;
            a: {
              for (; d--;)
                if (!1 === b(c++)) break a;
              for (; f--;) {
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a;
                if (!1 === b(c++)) break a
              }
            }
          }
        }, a.normalizeUrl = function(a, b) {
          void 0 === b && (b = !0);
          var c;
          return c = this.trim(a), c = /^([^:/?#]+):\/\/[^/?#.]+\.[^/?#]+/i.test(c) ? c : function(a, b) {
            return b.href = a, b.href
          }(c, document.createElement("a")), c = encodeURI(decodeURI(c)), c = c.replace(/["`^|\\<>{}\[\]\s].*/, ""), c = b ? this.justifyPercentEncodingUrlCase_(a, c) : c
        }, a.canonicalizeUrl = function(a) {
          function b(a) {
            return a.toUpperCase()
          }
          var c = this.normalizeUrl(a, !1);
          return c = c.replace(/(?:%\w{2})+/g, b)
        }, a.compareUrl = function(a, b) {
          return a = this.canonicalizeUrl(a), b = this.canonicalizeUrl(b), a === b
        }, a.justifyPercentEncodingUrlCase_ = function(a, b) {
          function c(b) {
            var c = ~a.indexOf(b.toUpperCase()) || ~a.indexOf(b.toLowerCase());
            return c ? a.substr(~c, b.length) : b
          }
          return a === b ? b : b.replace(/(?:%\w{2})+/g, c)
        }, a
      }();
      a.Utility = b
    }(b = a.LIBRARY || (a.LIBRARY = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c;
      ! function(b) {
        var c = function() {
          function c(c) {
            this.model_ = c, this.data_ = new b.DATA.Main, this.stores_ = this.data_.DB.stores, this.util_ = a.LIBRARY.Utility
          }
          return c.prototype.getCookie = function(a) {
            return this.data_.Cookie.getCookie(a)
          }, c.prototype.setCookie = function(a, b, c) {
            return this.data_.Cookie.setCookie(a, b, c)
          }, c.prototype.connect = function(a) {
            a.database.active ? (this.data_.DB.configure(a.database.revision, a.database.refresh), this.data_.DB.up(), this.saveTitle(), this.saveScrollPosition()) : this.data_.DB.down()
          }, c.prototype.loadBuffers = function() {
            for (var a in this.stores_) this.stores_[a].loadBuffer()
          }, c.prototype.saveBuffers = function() {
            for (var a in this.stores_) this.stores_[a].saveBuffer()
          }, c.prototype.getHistoryBuffer = function(a) {
            return this.stores_.history.getBuffer(this.model_.convertUrlToKey(a, !0))
          }, c.prototype.loadTitle = function() {
            var a = this,
              b = this.model_.convertUrlToKey(window.location.href, !0),
              c = this.stores_.history.getBuffer(b);
            c && "string" == typeof c.title ? document.title = c.title : this.stores_.history.get(b, function(d) {
              c = d.target.result, c && c.title && a.model_.compareKeyByUrl(b, a.util_.canonicalizeUrl(window.location.href)) && (document.title = c.title)
            })
          }, c.prototype.saveTitle = function(a, b) {
            void 0 === a && (a = window.location.href), void 0 === b && (b = document.title);
            var c = this.model_.convertUrlToKey(a, !0),
              d = {
                url: c,
                title: b,
                date: (new Date).getTime(),
                scrollX: undefined,
                scrollY: undefined,
                host: undefined,
                expires: undefined
              };
            this.stores_.history.set(d, !0), this.stores_.history.clean()
          }, c.prototype.loadScrollPosition = function() {
            function a(a, b) {
              "number" == typeof a && "number" == typeof b && window.scrollTo(parseInt(Number(a) + "", 10), parseInt(Number(b) + "", 10))
            }
            var b = this,
              c = this.model_.convertUrlToKey(window.location.href, !0),
              d = this.stores_.history.getBuffer(c);
            d && "number" == typeof d.scrollX ? a(d.scrollX, d.scrollY) : this.stores_.history.get(c, function(e) {
              d = e.target.result, d && "number" == typeof d.scrollX && b.model_.compareKeyByUrl(c, b.util_.canonicalizeUrl(window.location.href)) && a(d.scrollX, d.scrollY)
            })
          }, c.prototype.saveScrollPosition = function(a, b, c) {
            void 0 === a && (a = window.location.href), void 0 === b && (b = jQuery(window).scrollLeft()), void 0 === c && (c = jQuery(window).scrollTop());
            var d = this.model_.convertUrlToKey(a, !0),
              e = {
                url: d,
                scrollX: b,
                scrollY: c,
                date: (new Date).getTime(),
                title: undefined,
                host: undefined,
                expires: undefined
              };
            this.stores_.history.set(e, !0)
          }, c.prototype.loadExpires = function() {}, c.prototype.saveExpires = function(a, b, c) {
            var d = this.model_.convertUrlToKey(a, !0),
              e = {
                url: d,
                host: b || "",
                expires: c,
                title: undefined,
                scrollX: undefined,
                scrollY: undefined,
                date: undefined
              };
            this.stores_.history.set(e, !0)
          }, c.prototype.getServerBuffers = function() {
            return this.stores_.server.getBuffers()
          }, c.prototype.getServerBuffer = function(a) {
            var b = this.model_.convertUrlToKey(a, !0).split("//").pop().split("/").shift();
            return b = this.model_.compareKeyByUrl("http://" + b, "http://" + window.location.host) ? "" : b, this.stores_.server.getBuffer(b)
          }, c.prototype.loadServer = function() {}, c.prototype.saveServer = function(a, b, c, d, e) {
            a = a.split("//").pop().split("/").shift(), a = this.model_.compareKeyByUrl("http://" + a, "http://" + window.location.host) ? "" : a;
            var f = {
              host: a,
              time: Math.max(c, 1),
              score: d,
              state: e,
              expires: b
            };
            this.stores_.server.set(f, !0), this.stores_.server.clean()
          }, c.prototype.removeServer = function(a) {
            this.stores_.server.remove(a), this.stores_.server.clean()
          }, c
        }();
        b.Data = c
      }(c = b.APP || (b.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c;
      ! function(b) {
        var c = function() {
          function b(b) {
            this.data_ = b, this.util_ = a.LIBRARY.Utility, this.force_ = !1, this._host = "", this.parallel_ = 4
          }
          return b.prototype.host_ = function(a, b) {
            return b && (this._host = this.sanitize(a, b)), this._host
          }, b.prototype.host = function() {
            return this.host_()
          }, b.prototype.sanitize = function(a, b) {
            if (!b) return "";
            var c;
            switch (a && typeof a) {
              case "string":
                c = a;
                break;
              case "object":
                var d = a;
                c = 4 === d.readyState && d.getResponseHeader(b.balance.server.header) || d.host
            }
            return c = c || "", !/[/?#"`^|\\<>{}\[\]\s]/.test(c) && jQuery.grep(b.balance.bounds, function(a) {
              return "" === c || "*" === a || c === a || "." === a.charAt(0) && a === c.slice(-a.length)
            }).length && c || ""
          }, b.prototype.enable = function(a) {
            return a.balance.active && a.balance.client.support.browser.test(window.navigator.userAgent) ? (this.data_.setCookie(a.balance.client.cookie.balance, "1"), void(a.balance.client.support.redirect.test(window.navigator.userAgent) && this.data_.setCookie(a.balance.client.cookie.redirect, "1"))) : void this.disable(a)
          }, b.prototype.disable = function(a) {
            this.data_.getCookie(a.balance.client.cookie.balance) && this.data_.setCookie(a.balance.client.cookie.balance, "0"), this.data_.getCookie(a.balance.client.cookie.redirect) && this.data_.setCookie(a.balance.client.cookie.redirect, "0"), this.changeServer("", a)
          }, b.prototype.score = function(a, b) {
            return Math.max(Math.round(b / a * 1e3), 0)
          }, b.prototype.changeServer = function(a, b) {
            return b.balance.active ? (this.host_(a, b), this.data_.setCookie(b.balance.client.cookie.host, a)) : this.host_("", b), this.host()
          }, b.prototype.chooseServers_ = function(a) {
            function b(a, b) {
              return +b - +a
            }
            var c = this,
              d = a.balance.server.respite,
              e = a.balance.weight,
              f = a.ajax.timeout,
              g = a.balance.client.hosts.slice();
            g = this.force_ ? jQuery.grep(g, function(a) {
                return !!a
              }) : g,
              function() {
                var b = c.data_.getCookie(a.balance.client.cookie.host);
                (!c.force_ || b) && (b === c.sanitize(b, a) ? !~jQuery.inArray(b, g) && g.unshift(b) : c.data_.setCookie(a.balance.client.cookie.host, ""))
              }();
            var h = this.data_.getServerBuffers(),
              i = {};
            jQuery.each(Object.keys(h), function(b, d) {
              var e = h[d];
              ~jQuery.inArray(e.host, g) && g.splice(jQuery.inArray(e.host, g), 1), (!c.force_ || e.host) && (e.host === c.sanitize(e.host, a) && e.expires > (new Date).getTime() ? i[e.score] = e : c.data_.removeServer(e.host))
            });
            var j, k = Object.keys(i).sort(b),
              l = [];
            for (jQuery.each(k, function(b) {
                var h = i[k[b]],
                  m = h.host,
                  n = h.time,
                  o = h.score,
                  p = h.state;
                if (~jQuery.inArray(m, g) && g.splice(jQuery.inArray(m, g), 1), !(p + d >= (new Date).getTime())) {
                  switch (p && c.data_.removeServer(h.host), !0) {
                    case l.length >= a.balance.random && 0 < l.length:
                      return !1;
                    case e && !m && !!Math.floor(Math.random() * e):
                    case f && n >= f:
                    case l.length >= Math.min(Math.floor(k.length / 2), 3) && j && n >= j.time + 500 && f && n >= 2 * f / 3:
                    case l.length >= Math.min(Math.floor(k.length / 2), 3) && j && o <= j.score / 2:
                      return
                  }
                  j = j || h, l.push(m)
                }
              }); g.length;) l.push(g.splice(Math.floor(Math.random() * g.length), 1).shift());
            return l
          }, b.prototype.chooseServerFromCache_ = function(a) {
            var b = this,
              c = [],
              d = this.data_.getHistoryBuffer(a.destLocation.href);
            switch (!0) {
              case !d:
                break;
              case d.host !== this.sanitize(d.host, a):
                this.data_.saveExpires(d.url, "", 0);
              case !d.expires:
              case d.expires < (new Date).getTime():
              case this.force_ && !d.host:
                break;
              default:
                c = jQuery.map(this.data_.getServerBuffers(), function(a) {
                  return a.host === d.host ? a.state >= (new Date).getTime() ? void b.data_.saveExpires(d.url, d.host, 0) : a.host : void 0
                })
            }
            return c.length ? c.pop() || " " : ""
          }, b.prototype.chooseServerFromScore_ = function(a) {
            var b = this.chooseServers_(a);
            return b.slice(Math.floor(Math.random() * Math.min(b.length, 6))).shift() || " "
          }, b.prototype.chooseServer = function(a) {
            return a.balance.active ? this.util_.trim(this.chooseServerFromCache_(a) || this.chooseServerFromScore_(a)) : ""
          }, b.prototype.bypass = function(a) {
            var b = this;
            this.force_ = !0;
            var c = jQuery.Deferred();
            if (!a || !a.balance.active) return c.reject();
            var d = this.parallel_,
              e = this.chooseServers_(a),
              f = jQuery.extend({}, a.ajax, a.balance.option.ajax);
            e = jQuery.grep(e, function(a) {
              return !!a
            });
            for (var g = 0, h = e.length, i = function(d) {
                var j = b,
                  k = (new Date).getTime();
                "pending" === c.state() && jQuery.ajax(jQuery.extend({}, f, {
                  url: j.util_.normalizeUrl(window.location.protocol + "//" + d + window.location.pathname.replace(/^\/?/, "/") + window.location.search),
                  xhr: a.balance.option.callbacks.ajax.xhr ? function() {
                    var b;
                    return b = j.util_.fire(a.balance.option.callbacks.ajax.xhr, this, [event, a]), b = "object" == typeof b ? b : jQuery.ajaxSettings.xhr()
                  } : undefined,
                  beforeSend: a.balance.option.callbacks.ajax.beforeSend || a.server.header ? function(b, c) {
                    a.server.header && b.setRequestHeader(a.nss.requestHeader, "true"), "object" == typeof a.server.header && (b.setRequestHeader(a.nss.requestHeader, "true"), a.server.header.area && b.setRequestHeader(a.nss.requestHeader + "-Area", this.app_.chooseArea(a.area, document, document)), a.server.header.head && b.setRequestHeader(a.nss.requestHeader + "-Head", a.load.head), a.server.header.css && b.setRequestHeader(a.nss.requestHeader + "-CSS", a.load.css.toString()), a.server.header.script && b.setRequestHeader(a.nss.requestHeader + "-Script", a.load.script.toString())), j.util_.fire(a.balance.option.callbacks.ajax.beforeSend, this, [event, a, b, c])
                  } : undefined,
                  dataFilter: a.balance.option.callbacks.ajax.dataFilter ? function(b, c) {
                    return j.util_.fire(a.balance.option.callbacks.ajax.dataFilter, this, [event, a, b, c]) || b
                  } : undefined,
                  success: function(b, c, e) {
                    k = (new Date).getTime() - k;
                    var f = j.data_.getServerBuffer(this.url),
                      g = j.score(k, e.responseText.length);
                    k = f && !f.state && f.time ? Math.round((f.time + k) / 2) : k, g = f && !f.state && f.score ? Math.round((f.score + g) / 2) : g, j.data_.saveServer(d, (new Date).getTime() + a.balance.server.expires, k, g, 0), d = j.sanitize(e, a) || d, j.util_.fire(a.balance.option.ajax.success, this, arguments)
                  },
                  error: function() {
                    j.data_.saveServer(d, (new Date).getTime() + a.balance.server.expires, 0, 0, (new Date).getTime()), d = null, j.util_.fire(a.balance.option.ajax.error, this, arguments)
                  },
                  complete: function() {
                    j.util_.fire(a.balance.option.ajax.complete, this, arguments), ++g, c.notify(g, h, d), d ? (j.host_(d, a), e.splice(0, e.length), c.resolve(d)) : !j.host() && e.length ? i(e.shift()) : c.reject()
                  }
                }))
              }; d-- && e.length;) i(e.shift());
            return c
          }, b
        }();
        b.Balancer = c
      }(c = b.APP || (b.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b = function() {
          function a(a, b, d, e, f) {
            this.data_ = a ? {
              url: a,
              data: b,
              textStatus: d,
              jqXHR: e,
              host: f
            } : {
              url: undefined,
              data: undefined,
              textStatus: undefined,
              jqXHR: undefined,
              host: undefined
            }, this.data = new c(this.data_)
          }
          return a.prototype.state = function(a) {
            var b = a ? a.cache.expires.min : undefined,
              c = a ? a.cache.expires.max : undefined;
            switch (!1) {
              case this.data.jqXHR() && 200 === +this.data.jqXHR().status:
              case this.data.expires(b, c) >= (new Date).getTime():
                return !1;
              default:
                return !0
            }
          }, a
        }();
        a.PageRecord = b;
        var c = function() {
          function a(a) {
            this.data_ = a
          }
          return a.prototype.url = function() {
            return this.data_.url
          }, a.prototype.data = function() {
            return this.data_.data
          }, a.prototype.textStatus = function() {
            return this.data_.textStatus
          }, a.prototype.jqXHR = function() {
            return this.data_.jqXHR
          }, a.prototype.host = function() {
            return this.data_.host
          }, a.prototype.expires = function(a, b) {
            if (!this.jqXHR() && !this.data()) return 0;
            var c, d = this.jqXHR();
            switch (d && (d.timeStamp = d.timeStamp || new Date(d.getResponseHeader("Date")).getTime() || (new Date).getTime()), !0) {
              case !d:
                c = 0;
                break;
              case /no-store|no-cache/.test(d.getResponseHeader("Cache-Control")):
                c = 0;
                break;
              case !!d.getResponseHeader("Cache-Control") && !!~d.getResponseHeader("Cache-Control").indexOf("max-age="):
                c = new Date(d.getResponseHeader("Date") || new Date(d.timeStamp).toString()).getTime() + 1e3 * +d.getResponseHeader("Cache-Control").match(/max-age=(\d*)/).pop();
                break;
              case !!d.getResponseHeader("Expires"):
                c = new Date(d.getResponseHeader("Expires")).getTime();
                break;
              default:
                c = 0
            }
            return (undefined !== a || undefined !== b) && (c = "number" == typeof a ? Math.max(a + (new Date).getTime(), c) : c, c = "number" == typeof b ? Math.min(b + (new Date).getTime(), c) : c), c = Math.max(c, 0) || 0
          }, a
        }();
        a.PageRecordData = c
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b = function() {
          function a() {}
          return a.prototype.chooseArea = function(a, b, c) {
            var d, e = "string" == typeof a ? [a] : a,
              f = -1;
            a: for (; d = e[++f];) {
              for (var g = d.match(/(?:[^,\(\[]+|\(.*?\)|\[.*?\])+/g), h = -1; g[++h];)
                if (!jQuery(g[h], b).length || !jQuery(g[h], c).length) continue a;
              return d
            }
          }, a.prototype.dispatchEvent = function(a, b, c, d) {
            var e = document.createEvent("HTMLEvents");
            e.initEvent(b, c, d), a.dispatchEvent(e)
          }, a
        }();
        a.PageUtility = b
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c;
      ! function(b) {
        var c = function() {
          function b(b, c, d, e, f, g, h) {
            this.model_ = b, this.page_ = c, this.balancer_ = d, this.setting_ = e, this.event_ = f, this.success_ = g, this.failure_ = h, this.util_ = a.LIBRARY.Utility, this.main_()
          }
          return b.prototype.main_ = function() {
            function b() {
              return e.call(this, [].slice.call(arguments), undefined)
            }

            function c() {
              return f.apply(this, arguments)
            }

            function d() {
              return g.apply(this, arguments)
            }

            function e(a) {
              arguments.length && arguments[0] && (h.data_ = a[0], h.textStatus_ = a[1], h.jqXHR_ = a[2], h.util_.fire(i.callbacks.ajax.success, this[0] || this, [j, i, h.data_, h.textStatus_, h.jqXHR_]))
            }

            function f(a, b, c) {
              arguments.length && arguments[0] && (h.jqXHR_ = a, h.textStatus_ = b, h.errorThrown_ = c, h.util_.fire(i.callbacks.ajax.error, this[0] || this, [j, i, h.jqXHR_, h.textStatus_, h.errorThrown_]))
            }

            function g() {
              arguments.length && arguments[0] && (h.util_.fire(i.callbacks.ajax.complete, this[0] || this, [j, i, h.jqXHR_, h.textStatus_]), h.model_.setXHR(null), 200 === +h.jqXHR_.status ? (h.model_.setCache(i.destLocation.href, n && n.data || null, h.textStatus_, h.jqXHR_), h.success_(i, j, h.data_, h.textStatus_, h.jqXHR_, h.host_)) : h.failure_(i, j, h.data_, h.textStatus_, h.jqXHR_, h.host_))
            }
            var h = this,
              i = this.setting_,
              j = this.event_ = jQuery.extend(!0, {}, this.event_),
              k = this.util_.fire(i.wait, i, [j, i, i.origLocation.cloneNode(), i.destLocation.cloneNode()]),
              l = i.speedcheck,
              m = this.model_.speed;
            l && (m.fire = j.timeStamp), l && m.time.splice(0, 100, 0), l && m.name.splice(0, 100, "pjax(" + m.time.slice(-1) + ")");
            var n;
            switch (i.cache[j.type.toLowerCase()] && j.type.toLowerCase()) {
              case a.EVENT.CLICK:
                n = this.model_.getCache(i.destLocation.href);
                break;
              case a.EVENT.SUBMIT:
                n = i.cache[j.currentTarget.method.toLowerCase()] ? this.model_.getCache(i.destLocation.href) : n;
                break;
              case a.EVENT.POPSTATE:
                n = this.model_.getCache(i.destLocation.href)
            }
            var o = this.model_.getXHR();
            if (!(o && o.readyState < 4 && o.location && this.model_.comparePageByUrl(o.location.href, i.destLocation.href)))
              if (this.dispatchEvent(document, i.nss.event.pjax.fetch, !1, !1), n && n.jqXHR && 200 === +n.jqXHR.status)
                if (l && m.name.splice(0, 1, "cache(" + m.time.slice(-1) + ")"), o = n.jqXHR, o.location = o.location || i.destLocation.cloneNode(), this.model_.setXHR(o), this.page_.loadtime = 0, this.host_ = this.balancer_.sanitize(n.host, i), this.data_ = n.jqXHR.responseText, this.textStatus_ = n.textStatus, this.jqXHR_ = n.jqXHR, this.model_.isDeferrable) {
                  var p = this.wait_(k);
                  this.page_.setWait(p), jQuery.when(jQuery.Deferred().resolve(this.data_, this.textStatus_, this.jqXHR_), p).done(e).fail(f).always(g)
                } else {
                  var q = jQuery.extend({}, jQuery.ajaxSettings, i.ajax);
                  q = q.context || q, b.call(q, this.data_, this.textStatus_, this.jqXHR_), d.call(q, this.jqXHR_, this.textStatus_)
                } else if (o && o.follow && !~"error abort timeout parsererror".indexOf(o.statusText)) {
              l && m.time.splice(0, 1, o.timeStamp - m.fire), l && m.name.splice(0, 1, "preload(" + m.time.slice(-1) + ")"), l && m.time.push(m.now() - m.fire), l && m.name.push("continue(" + m.time.slice(-1) + ")"), o.location = i.destLocation.cloneNode(), this.model_.setXHR(o), this.balancer_.sanitize(o, i), this.balancer_.changeServer(o.host, i), this.host_ = this.model_.host(), this.page_.loadtime = o.timeStamp;
              var p = this.wait_(k);
              this.page_.setWait(p), delete o.timeStamp, jQuery.when(o, p).done(e).fail(f).always(g)
            } else {
              this.page_.loadtime = j.timeStamp;
              var r = i.destLocation.cloneNode(),
                s = {};
              switch (this.balancer_.changeServer(this.balancer_.chooseServer(i), i), this.host_ = i.balance.active && this.model_.host().split("//").pop() || "", r.host = this.host_ || i.destLocation.host, s.url = i.server.query ? [r.protocol, "//", r.host, r.pathname.replace(/^\/?/, "/"), r.search.replace(/&*$/, "&" + i.server.query).replace(/^\??&/, "?").replace(/(\?|&)$/, ""), r.hash].join("") : r.href, j.type.toLowerCase()) {
                case a.EVENT.CLICK:
                  s.type = "GET";
                  break;
                case a.EVENT.SUBMIT:
                  switch (s.type = j.currentTarget.method.toUpperCase(), s.type) {
                    case "POST":
                      jQuery(j.currentTarget).has(":file").length ? "function" == typeof FormData && (s.data = (new FormData)(j.currentTarget), s.contentType = !1, s.processData = !1) : s.data = jQuery(j.currentTarget).serializeArray();
                      break;
                    case "GET":
                  }
                  break;
                case a.EVENT.POPSTATE:
                  s.type = "GET"
              }
              if (s = jQuery.extend({}, i.ajax, s, {
                  xhr: i.callbacks.ajax.xhr ? function() {
                    var a;
                    return a = h.util_.fire(i.callbacks.ajax.xhr, this, [j, i]), a = "object" == typeof a ? a : jQuery.ajaxSettings.xhr()
                  } : undefined,
                  beforeSend: i.callbacks.ajax.beforeSend || i.server.header ? function(a, b) {
                    i.server.header && a.setRequestHeader(i.nss.requestHeader, "true"), "object" == typeof i.server.header && (a.setRequestHeader(i.nss.requestHeader, "true"), i.server.header.area && a.setRequestHeader(i.nss.requestHeader + "-Area", this.app_.chooseArea(i.area, document, document)), i.server.header.head && a.setRequestHeader(i.nss.requestHeader + "-Head", i.load.head), i.server.header.css && a.setRequestHeader(i.nss.requestHeader + "-CSS", i.load.css.toString()), i.server.header.script && a.setRequestHeader(i.nss.requestHeader + "-Script", i.load.script.toString())), h.util_.fire(i.callbacks.ajax.beforeSend, this, [j, i, a, b])
                  } : undefined,
                  dataFilter: i.callbacks.ajax.dataFilter ? function(a, b) {
                    return h.util_.fire(i.callbacks.ajax.dataFilter, this, [j, i, a, b]) || a
                  } : undefined,
                  success: this.model_.isDeferrable ? null : b,
                  error: this.model_.isDeferrable ? null : c,
                  complete: this.model_.isDeferrable ? null : d
                }), o = jQuery.ajax(s), o.location = i.destLocation.cloneNode(), this.model_.setXHR(o), this.balancer_.sanitize(o, i), !this.model_.isDeferrable) return;
              var p = this.wait_(k);
              this.page_.setWait(p), jQuery.when(this.model_.getXHR(), p).done(e).fail(f).always(g)
            }
          }, b.prototype.wait_ = function(a) {
            var b = jQuery.Deferred();
            return a ? (setTimeout(function() {
              b.resolve()
            }, a), b) : b.resolve()
          }, b.prototype.chooseArea = function() {}, b.prototype.dispatchEvent = function() {}, b
        }();
        b.PageFetch = c
      }(c = b.APP || (b.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      var b;
      ! function(a) {
        var b = function() {
          function b(b, c, d, e) {
            this.Record_ = b, this.model_ = c, this.balancer_ = d, this.page_ = e, this.hash_ = function(a) {
              return a.nss.url
            }, this.table_ = {}, this.order_ = [], this.fetch_ = a.PageFetch
          }
          return b.prototype.fetchRecord = function(a, b, c, d) {
            this.getRecord(a).state(a) ? this.pullRecord(a, b, c, d) : this.pullRecord(a, b, c, d)
          }, b.prototype.pullRecord = function(a, b, c, d) {
            var e = this;
            new this.fetch_(this.model_, this.page_, this.balancer_, a, b, function(a, b, d, f, g, h) {
              var i = e.setRecord(a, e.getRecord(a).data.data() || "", f, g, h);
              c(i, a, b)
            }, function(a, b, c, f, g, h) {
              var i = e.setRecord(a, e.getRecord(a).data.data() || "", f, g, h);
              d(i, a, b)
            })
          }, b.prototype.getRecord = function(a) {
            return this.table_[this.hash_(a)] = this.table_[this.hash_(a)] || new this.Record_
          }, b.prototype.setRecord = function(a, b, c, d, e) {
            return this.cleanRecords_(a), this.addOrder_(a), this.table_[this.hash_(a)] = new this.Record_(a.nss.url, b, c, d, e)
          }, b.prototype.removeRecord = function(a) {
            return this.removeOrder_(a), this.table_[this.hash_(a)] = new this.Record_
          }, b.prototype.clearRecord = function() {
            this.order_.splice(0, this.order_.length);
            for (var a in this.table_) delete this.table_[a]
          }, b.prototype.cleanRecords_ = function(a) {
            if (a.cache.limit)
              for (; this.order_.length >= a.cache.limit;) this.removeRecord(this.order_.pop())
          }, b.prototype.addOrder_ = function(a) {
            this.removeOrder_(a), this.order_.unshift(a)
          }, b.prototype.removeOrder_ = function(a) {
            for (var b = this.order_.length; b--;) this.order_[b].nss.url === a.nss.url && this.order_.splice(b, 1)
          }, b
        }();
        a.PageProvider = b
      }(b = a.APP || (a.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c;
      ! function(b) {
        var c = function() {
          function b(b, c, d, e, f, g, h) {
            this.model_ = b, this.page_ = c, this.data_ = d, this.balancer_ = e, this.setting_ = f, this.event_ = g, this.record_ = h, this.util_ = a.LIBRARY.Utility, this.loadwaits_ = [], this.main_()
          }
          return b.prototype.main_ = function() {
            var b = this.record_,
              c = this.setting_,
              d = this.event_,
              e = c.speedcheck,
              f = this.model_.speed;
            if (e && f.time.push(f.now() - f.fire), e && f.name.push("fetch(" + f.time.slice(-1) + ")"), ++this.page_.count, this.page_.loadtime = this.page_.loadtime && (new Date).getTime() - this.page_.loadtime, c.cache.mix && a.EVENT.POPSTATE !== d.type.toLowerCase() && (new Date).getTime() - d.timeStamp <= c.cache.mix) return this.model_.fallback(d);
            try {
              if (this.page_.landing = null, !~(b.data.jqXHR().getResponseHeader("Content-Type") || "").toLowerCase().search(c.contentType)) throw new Error("throw: content-type mismatch");
              if (this.srcTitle_ = jQuery(b.data.jqXHR().responseText.match(/<title(?:\s.*?[^\\])?>(?:.*?[^\\])?<\/title>|$/i).pop()).text(), this.dstTitle_ = document.title, this.redirect_(), this.dispatchEvent(window, c.nss.event.pjax.unload, !1, !1), this.url_(), !this.model_.comparePageByUrl(c.destLocation.href, window.location.href)) throw new Error("throw: location mismatch");
              this.document_()
            } catch (g) {
              if (!g) return;
              this.model_.getCache(window.location.href) && this.model_.removeCache(c.destLocation.href), this.model_.fallback(d)
            }
          }, b.prototype.isRegister_ = function(b, c) {
            if (b.destLocation.href === b.origLocation.href) return !1;
            switch (c.type.toLowerCase()) {
              case a.EVENT.CLICK:
              case a.EVENT.SUBMIT:
                return !0;
              case a.EVENT.POPSTATE:
                return !1
            }
          }, b.prototype.isReplace_ = function(b, c) {
            switch (c.type.toLowerCase()) {
              case a.EVENT.CLICK:
              case a.EVENT.SUBMIT:
                return jQuery(c.currentTarget).is(b.replace);
              case a.EVENT.POPSTATE:
                return !1
            }
          }, b.prototype.isCacheUsable_ = function(b, c) {
            switch (!0) {
              case !c.cache.click && !c.cache.submit && !c.cache.popstate:
              case a.EVENT.SUBMIT === b.type.toLowerCase() && !c.cache[b.currentTarget.method.toLowerCase()]:
                return !1;
              default:
                return !0
            }
          }, b.prototype.redirect_ = function() {
            var b = this,
              c = this.setting_,
              d = this.event_,
              e = (jQuery('head meta[http-equiv="Refresh"][content*="URL="]').attr("content") || "").match(/\w+:\/\/[^;\s"']+|$/i).shift();
            if (e && !this.model_.comparePageByUrl(c.destLocation.href, e)) {
              var f = c.destLocation.cloneNode();
              if (f.href = e, this.util_.fire(c.callbacks.update.redirect.before, c, [d, c, f.cloneNode(), c.origLocation.cloneNode(), c.destLocation.cloneNode()]) !== !1) {
                switch (!0) {
                  case !c.redirect:
                  case f.protocol !== c.destLocation.protocol:
                  case f.host !== c.destLocation.host:
                  case a.EVENT.SUBMIT === d.type.toLowerCase() && "GET" !== d.currentTarget.method.toUpperCase():
                    switch (d.type.toLowerCase()) {
                      case a.EVENT.CLICK:
                      case a.EVENT.SUBMIT:
                        window.location.assign(f.href);
                        break;
                      case a.EVENT.POPSTATE:
                        window.location.replace(f.href)
                    }
                    throw !1;
                  default:
                    switch (jQuery[a.DEF.NAME].enable(), d.type.toLowerCase()) {
                      case a.EVENT.CLICK:
                      case a.EVENT.SUBMIT:
                        setTimeout(function() {
                          return jQuery[a.DEF.NAME].click(f.href)
                        }, 0);
                        break;
                      case a.EVENT.POPSTATE:
                        window.history.replaceState(window.history.state, this.srcTitle_, f.href), this.isRegister_(c, d) && c.fix.location && !this.util_.compareUrl(c.destLocation.href, window.location.href) && (jQuery[a.DEF.NAME].disable(), window.history.back(), window.history.forward(), jQuery[a.DEF.NAME].enable()), setTimeout(function() {
                          return b.dispatchEvent(window, a.EVENT.POPSTATE, !1, !1)
                        }, 0)
                    }
                    throw !1
                }
                this.util_.fire(c.callbacks.update.redirect.after, c, [d, c, f.cloneNode(), c.origLocation.cloneNode(), c.destLocation.cloneNode()]) === !1
              }
            }
          }, b.prototype.url_ = function() {
            var b = this.setting_,
              c = this.event_;
            this.model_.location.href = b.destLocation.href, this.util_.fire(b.callbacks.update.url.before, b, [c, b, b.origLocation.cloneNode(), b.destLocation.cloneNode()]) !== !1 && (this.isReplace_(b, c) ? (window.history.replaceState(this.util_.fire(b.state, b, [c, b, b.origLocation.cloneNode(), b.destLocation.cloneNode()]), this.srcTitle_, b.destLocation.href), b.fix.location && !this.util_.compareUrl(b.destLocation.href, window.location.href) && window.location.replace(b.destLocation.href)) : this.isRegister_(b, c) && (window.history.pushState(this.util_.fire(b.state, b, [c, b, b.origLocation.cloneNode(), b.destLocation.cloneNode()]), ~window.navigator.userAgent.toLowerCase().indexOf("opera") ? this.dstTitle_ : this.srcTitle_, b.destLocation.href), b.fix.location && !this.util_.compareUrl(b.destLocation.href, window.location.href) && (jQuery[a.DEF.NAME].disable(), window.history.back(), window.history.forward(), jQuery[a.DEF.NAME].enable())), this.util_.fire(b.callbacks.update.url.after, b, [c, b, b.origLocation.cloneNode(), b.destLocation.cloneNode()]) === !1)
          }, b.prototype.document_ = function() {
            var b = this,
              c = this.setting_,
              d = this.event_;
            if (c.load.script && !this.page_.loadedScripts[""]) {
              var e = this.page_.loadedScripts;
              e[""] = !0, jQuery("script").each(function() {
                var a = this;
                a.src && (e[a.src] = !c.load.reload || !jQuery(a).is(c.load.reload))
              })
            }
            this.srcDocument_ = this.page_.parser.parse(this.record_.data.jqXHR().responseText, c.destLocation.href), this.dstDocument_ = document;
            var f = c.speedcheck,
              g = this.model_.speed;
            if (f && g.time.push(g.now() - g.fire), f && g.name.push("parse(" + g.time.slice(-1) + ")"), this.area_ = this.chooseArea(c.area, this.srcDocument_, this.dstDocument_), !this.area_) throw new Error("throw: area notfound");
            this.areas_ = this.area_.match(/(?:[^,]+?|\(.*?\)|\[.*?\])+/g), this.overwriteDocumentByCache_(), c.fix.noscript && this.escapeNoscript_(this.srcDocument_), c.fix.reference && this.fixReference_(c.origLocation.href, this.dstDocument_), this.rewrite_(), this.title_(), c.fix.history && this.data_.saveTitle(), this.data_.saveExpires(this.record_.data.url(), this.record_.data.host(), this.record_.data.expires()), this.head_(), f && g.time.push(g.now() - g.fire), f && g.name.push("head(" + g.time.slice(-1) + ")"), this.content_(), f && g.time.push(g.now() - g.fire), f && g.name.push("content(" + g.time.slice(-1) + ")"), this.balance_(), this.css_('link[rel~="stylesheet"], style'), jQuery(window).one(a.DEF.NAME + ":rendering", function(e) {
              e.preventDefault(), e.stopImmediatePropagation();
              var h = function(a) {
                  return b.model_.comparePageByUrl(c.destLocation.href, window.location.href) ? (b.dispatchEvent(document, c.nss.event.pjax.ready, !1, !1), jQuery(b.area_).each(function(a, b) {
                    return jQuery(b).width()
                  }), jQuery.when ? jQuery.Deferred().resolve() : a()) : void 0
                },
                i = function(e) {
                  return b.model_.comparePageByUrl(c.destLocation.href, window.location.href) ? (b.util_.fire(c.callback, c, [d, c]), setTimeout(function() {
                    switch (d.type.toLowerCase()) {
                      case a.EVENT.CLICK:
                      case a.EVENT.SUBMIT:
                        b.model_.overlay(c) || b.scrollByHash_(c) || b.scroll_(!0);
                        break;
                      case a.EVENT.POPSTATE:
                        b.model_.overlay(c) || b.scroll_(!0)
                    }
                  }, 100), b.dispatchEvent(document, c.nss.event.pjax.render, !1, !1), f && g.time.push(g.now() - g.fire), f && g.name.push("render(" + g.time.slice(-1) + ")"), jQuery.when ? jQuery.when.apply(jQuery, b.loadwaits_) : e()) : void 0
                },
                j = function() {
                  return b.model_.comparePageByUrl(c.destLocation.href, window.location.href) ? (b.dispatchEvent(window, c.nss.event.pjax.load, !1, !1), f && g.time.push(g.now() - g.fire), f && g.name.push("load(" + g.time.slice(-1) + ")"), f && console.log(g.time), f && console.log(g.name), b.script_("[src][defer]"), jQuery.when && jQuery.Deferred().resolve()) : jQuery.when && jQuery.Deferred().reject()
                };
              if (b.scroll_(!1), 100 > b.page_.loadtime && c.reset.type.match(d.type.toLowerCase()) && !jQuery('form[method][method!="GET"]').length) switch (!1) {
                case b.page_.count < c.reset.count || !c.reset.count:
                case (new Date).getTime() < c.reset.time + b.page_.time || !c.reset.time:
                  throw new Error("throw: reset")
              }
              var k = b.script_(":not([defer]), :not([src])");
              if (jQuery.when) {
                var l = jQuery.Deferred().pipe ? "pipe" : "then";
                jQuery.when.apply(jQuery, k)[l](function() {
                  return h()
                })[l](function() {
                  return i()
                })[l](function() {
                  return j()
                })
              } else h(function() {
                return i(function() {
                  return j()
                })
              })
            }).trigger(a.DEF.NAME + ":rendering")
          }, b.prototype.overwriteDocumentByCache_ = function() {
            var a = this.setting_,
              b = this.event_,
              c = this.model_.getCache(a.destLocation.href);
            if (this.isCacheUsable_(b, a) && c && c.data) {
              var d = a.fix.noscript ? this.restoreNoscript_(c.data) : c.data,
                e = this.page_.parser.parse(d, a.destLocation.href),
                f = this.srcDocument_;
              f.title = e.title;
              for (var g, h, i = 0; this.areas_[i]; i++) {
                if (g = jQuery(this.areas_[i], e).clone(), h = jQuery(this.areas_[i], f), !g.length || !h.length || g.length !== h.length) throw new Error("throw: area mismatch");
                for (var j = 0; g[j]; j++) h[j].parentNode.replaceChild(g[j], h[j])
              }
            }
          }, b.prototype.rewrite_ = function() {
            var a = this.setting_,
              b = this.event_;
            a.rewrite && this.util_.fire(a.callbacks.update.rewrite.before, a, [b, a, this.srcDocument_, this.dstDocument_]) !== !1 && (this.util_.fire(a.rewrite, a, [this.srcDocument_, this.area_, this.record_.data.host()]), this.util_.fire(a.callbacks.update.rewrite.before, a, [b, a, this.srcDocument_, this.dstDocument_]) === !1)
          }, b.prototype.title_ = function() {
            var a = this.setting_,
              b = this.event_;
            this.util_.fire(a.callbacks.update.title.before, a, [b, a, this.srcDocument_.title, this.dstDocument_.title]) !== !1 && (this.dstDocument_.title = this.srcDocument_.title, this.util_.fire(a.callbacks.update.title.after, a, [b, a, this.srcDocument_.title, this.dstDocument_.title]) === !1)
          }, b.prototype.head_ = function() {
            var a = this.setting_,
              b = this.event_,
              c = this.srcDocument_,
              d = this.dstDocument_;
            if (a.load.head && this.util_.fire(a.callbacks.update.head.before, a, [b, a, this.srcDocument_.querySelector("head"), this.dstDocument_.querySelector("head")]) !== !1) {
              for (var e, f = "base, meta, link", g = jQuery(c.head).children(f).filter(a.load.head).not(a.load.ignore).not('link[rel~="stylesheet"], style, script'), h = jQuery(d.head).children(f).filter(a.load.head).not(a.load.ignore).not('link[rel~="stylesheet"], style, script'), i = jQuery(), j = h, k = 0; e = g[k]; k++) {
                for (var l = 0; j[l]; l++)
                  if (j[l].tagName === e.tagName && j[l].outerHTML === e.outerHTML) {
                    if (i.length) {
                      var m = h[h.index(j[l]) - 1];
                      m ? jQuery(m).after(i.clone()) : j.eq(l).before(i.clone()), i = jQuery()
                    }
                    j = j.not(j[l]), e = null;
                    break
                  }
                i = i.add(e)
              }
              jQuery("title", d).before(i.clone()), j.remove(), this.util_.fire(a.callbacks.update.head.after, a, [b, a, this.srcDocument_.querySelector("head"), this.dstDocument_.querySelector("head")]) === !1
            }
          }, b.prototype.content_ = function() {
            function a() {
              if (jQuery.Deferred) {
                var a = jQuery.Deferred();
                switch (this.tagName.toLowerCase()) {
                  case "img":
                    jQuery(this).one("load error abort", a.resolve);
                    break;
                  case "iframe":
                  case "frame":
                    jQuery(this).one("load", a.resolve)
                }
                return a
              }
            }
            var b = this,
              c = this.setting_,
              d = this.event_,
              e = this.srcDocument_,
              f = this.dstDocument_;
            if (this.util_.fire(c.callbacks.update.content.before, c, [d, c, jQuery(this.area_, this.srcDocument_).get(), jQuery(this.area_, this.dstDocument_).get()]) !== !1) {
              jQuery(this.area_).children("." + c.nss.elem + "-check").remove();
              for (var g, h, i = 0; this.areas_[i]; i++) {
                if (g = jQuery(this.areas_[i], e), h = jQuery(this.areas_[i], f), !g.length || !h.length || g.length !== h.length) throw new Error("throw: area mismatch");
                g = g.map(function(a, b) {
                  return document.importNode(b, !0)
                }), g.find("script").each(function(a, c) {
                  return b.escapeScript_(c)
                }), this.loadwaits_ = this.loadwaits_.concat(g.find("img, iframe, frame").map(a).get());
                for (var j = 0; g[j]; j++) h[j].parentNode.replaceChild(g[j], h[j]), document.body === g[j] && (jQuery.each(g[j].attributes, function(a, b) {
                  return h[j].removeAttribute(b.name)
                }), jQuery.each(g[j].attributes, function(a, b) {
                  return h[j].setAttribute(b.name, b.value)
                }));
                h = jQuery(this.areas_[i], f), h.find("script").each(function(a, c) {
                  return b.restoreScript_(c)
                })
              }
              this.dispatchEvent(document, c.nss.event.pjax.DOMContentLoaded, !1, !1), this.util_.fire(c.callbacks.update.content.after, c, [d, c, jQuery(this.area_, this.srcDocument_).get(), jQuery(this.area_, this.dstDocument_).get()]) === !1
            }
          }, b.prototype.balance_ = function() {
            var a = this.setting_,
              b = this.event_;
            if (a.balance.active && !(this.page_.loadtime < 100)) {
              var c = this.record_.data.jqXHR(),
                d = this.balancer_.sanitize(c, a) || this.record_.data.host() || "",
                e = this.page_.loadtime,
                f = this.balancer_.score(e, c.responseText.length);
              if (this.util_.fire(a.callbacks.update.balance.before, a, [b, a, d, this.page_.loadtime, c.responseText.length]) !== !1) {
                var g = this.data_.getServerBuffer(a.destLocation.href),
                  f = this.balancer_.score(e, c.responseText.length);
                e = g && !g.state && g.time ? Math.round((g.time + e) / 2) : e, f = g && !g.state && g.score ? Math.round((g.score + f) / 2) : f, this.data_.saveServer(d, (new Date).getTime() + a.balance.server.expires, e, f, 0), this.balancer_.changeServer(this.balancer_.chooseServer(a), a), this.util_.fire(a.callbacks.update.balance.after, a, [b, a, d, this.page_.loadtime, c.responseText.length]) === !1
              }
            }
          }, b.prototype.css_ = function(a) {
            function b() {
              return jQuery.contains(f.head, this)
            }

            function c() {
              return jQuery.contains(f.body, this)
            }
            var d = this.setting_,
              e = this.event_,
              f = this.srcDocument_,
              g = this.dstDocument_;
            if (d.load.css) {
              var h = "link, style",
                i = jQuery(h, f).filter(a).not(jQuery("noscript", f).find(h)),
                j = jQuery(h, g).filter(a).not(jQuery("noscript", f).find(h)),
                k = jQuery(),
                l = j;
              if (this.util_.fire(d.callbacks.update.css.before, d, [e, d, i.get(), j.get()]) !== !1) {
                i = i.not(d.load.ignore), j = i.not(d.load.ignore);
                for (var m, n = 0; m = i[n]; n++) {
                  for (var o, p = 0; l[p]; p++) {
                    switch (m.tagName.toLowerCase()) {
                      case "link":
                        o = m.href === l[p].href;
                        break;
                      case "style":
                        o = this.util_.trim(m.innerHTML) === this.util_.trim(l[p].innerHTML)
                    }
                    if (o) {
                      if (k.length) {
                        if (jQuery.contains(g.body, l[p]) && k.first().parents("head").length) jQuery(g.head).append(k.filter(b).clone()), l.eq(p).before(k.filter(c).clone());
                        else {
                          var q = j[j.index(l[p]) - 1];
                          q ? jQuery(q).after(k.clone()) : l.eq(p).before(k.clone())
                        }
                        k = jQuery()
                      }
                      l = l.not(l[p]), p -= Number(!!p), m = null;
                      break
                    }
                  }
                  k = k.add(m)
                }
                if (jQuery(g.head).append(k.filter(b).clone()), jQuery(g.body).append(k.filter(c).clone()), l.remove(), j = jQuery(h, g).filter(a).not(jQuery("noscript", f).find(h)), this.util_.fire(d.callbacks.update.css.after, d, [e, d, i.get(), j.get()]) !== !1) {
                  var r = d.speedcheck,
                    s = this.model_.speed;
                  r && s.time.push(s.now() - s.fire), r && s.name.push("css(" + s.time.slice(-1) + ")")
                }
              }
            }
          }, b.prototype.script_ = function(a) {
            var b = this,
              c = this.setting_,
              d = this.event_,
              e = this.srcDocument_,
              f = this.dstDocument_,
              g = [],
              h = [];
            if (!c.load.script) return g;
            var i = "script",
              j = jQuery(i, e).filter(a).not(jQuery("noscript", e).find(i)),
              k = jQuery(i, f).filter(a).not(jQuery("noscript", f).find(i)),
              l = this.page_.loadedScripts,
              m = /^$|(?:application|text)\/(?:java|ecma)script/i,
              n = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
            if (this.util_.fire(c.callbacks.update.script.before, c, [d, c, j.get(), k.get()]) === !1) return g;
            j = j.not(c.load.ignore);
            for (var o, p = function(a, d) {
                if (!b.model_.comparePageByUrl(c.destLocation.href, window.location.href)) return !1;
                a.src && (l[a.src] = !c.load.reload || !jQuery(a).is(c.load.reload));
                try {
                  if (b.model_.isDeferrable) {
                    if ("string" != typeof d) throw d;
                    eval.call(window, d)
                  } else a.hasAttribute("src") ? jQuery.ajax(jQuery.extend(!0, {}, c.ajax, c.load.ajax, {
                    url: a.src,
                    dataType: "script",
                    async: !1,
                    global: !1,
                    success: function() {
                      return null
                    },
                    error: function(a) {
                      throw a
                    }
                  })) : eval.call(window, (a.text || a.textContent || a.innerHTML || "").replace(n, ""));
                  try {
                    a.hasAttribute("src") && b.dispatchEvent(a, "load", !1, !1)
                  } catch (e) {}
                } catch (f) {
                  try {
                    a.hasAttribute("src") && b.dispatchEvent(a, "error", !1, !1)
                  } catch (e) {}
                  if (!0 === c.load.error) throw f;
                  b.util_.fire(c.load.error, c, [f, a])
                }
              }, q = 0; o = j[q]; q++)
              if (m.test(o.type || "") && (o.hasAttribute("src") ? !l[o.src] : this.util_.trim(o.innerHTML))) {
                var r = jQuery(o).parent(c.load.log)[0];
                if (r && !jQuery(o).parents(this.area_).length) {
                  var s = jQuery(r.id || r.tagName, f)[0],
                    t = o.cloneNode(!0);
                  this.escapeScript_(t), s.appendChild(t), this.restoreScript_(t)
                }! function(a) {
                  var d = b.model_.isDeferrable && jQuery.Deferred();
                  a.hasAttribute("src") && a.getAttribute("src") ? (l[a.src] = !c.load.reload || !jQuery(a).is(c.load.reload), a.hasAttribute("async") ? jQuery.ajax(jQuery.extend({}, c.ajax, c.load.ajax, {
                    url: a.src,
                    dataType: "script",
                    async: !0,
                    global: !1,
                    success: function() {
                      return b.dispatchEvent(a, "load", !1, !1)
                    },
                    error: function() {
                      return b.dispatchEvent(a, "error", !1, !1)
                    }
                  })) : d ? (jQuery.ajax(jQuery.extend({}, c.ajax, c.load.ajax, {
                    url: a.src,
                    dataType: "text",
                    async: !0,
                    global: !1,
                    success: function() {
                      return d.resolve([a, arguments[0]])
                    },
                    error: function(b) {
                      return d.resolve([a, b])
                    }
                  })), g.push(d)) : h.push(a)) : a.hasAttribute("src") || (d ? g.push(d.resolve([a, (a.text || a.textContent || a.innerHTML || "").replace(n, "")])) : h.push(a))
                }(o)
              }
            try {
              this.model_.isDeferrable ? jQuery.when.apply(jQuery, g).always(function() {
                return jQuery.each(arguments, function(a, c) {
                  return p.apply(b, c)
                })
              }) : jQuery.each(h, function(a, b) {
                return p(b)
              })
            } catch (u) {
              throw setTimeout(function() {
                return b.model_.fallback(d)
              }, 1), u
            }
            if (k = jQuery(i, f).filter(a).not(jQuery("noscript", f).find(i)), this.util_.fire(c.callbacks.update.script.after, c, [d, c, j.get(), k.get()]) === !1) return g;
            var v = c.speedcheck,
              w = this.model_.speed;
            return v && w.time.push(w.now() - w.fire), v && w.name.push("script(" + w.time.slice(-1) + ")"), g
          }, b.prototype.scroll_ = function(b) {
            var c = this.setting_,
              d = this.event_;
            if (this.util_.fire(c.callbacks.update.scroll.before, c, [d, c]) !== !1) {
              var e, f;
              switch (d.type.toLowerCase()) {
                case a.EVENT.CLICK:
                case a.EVENT.SUBMIT:
                  e = b && "function" == typeof c.scrollLeft ? this.util_.fire(c.scrollLeft, c, [d, c, c.origLocation.cloneNode(), c.destLocation.cloneNode()]) : c.scrollLeft, e = e >= 0 ? e : 0, e = e === !1 || null === e ? jQuery(window).scrollLeft() : parseInt(Number(e) + "", 10), f = b && "function" == typeof c.scrollTop ? this.util_.fire(c.scrollTop, c, [d, c, c.origLocation.cloneNode(), c.destLocation.cloneNode()]) : c.scrollTop, f = f >= 0 ? f : 0, f = f === !1 || null === f ? jQuery(window).scrollTop() : parseInt(Number(f) + "", 10), window.scrollTo(e, f);
                  break;
                case a.EVENT.POPSTATE:
                  b && c.fix.scroll && this.data_.loadScrollPosition()
              }
              b && this.data_.saveScrollPosition(), this.util_.fire(c.callbacks.update.scroll.after, c, [d, c]) === !1
            }
          }, b.prototype.scrollByHash_ = function(a) {
            var b = a.destLocation.hash.replace(/^#/, "");
            if (!b) return !1;
            var c = jQuery("#" + b + ", [name~=" + b + "]").first();
            return c.length ? (isFinite(c.offset().top) && window.scrollTo(jQuery(window).scrollLeft(), parseInt(Number(c.offset().top) + "", 10)), this.data_.saveScrollPosition(), !0) : !1
          }, b.prototype.fixReference_ = function(a, b) {
            function c(a, b) {
              var c;
              if ("href" in b) c = "href";
              else {
                if (!("src" in b)) return;
                c = "src"
              }
              switch (d) {
                case 0:
                  break;
                case 1:
                  b[c] = j + b.getAttribute(c);
                  break;
                case -1:
                  b[c] = b.getAttribute(c).replace(j, "")
              }
              b.setAttribute(c, b[c].replace(i, "/"))
            }
            var d, e = a.replace(/[^/]+$/, ""),
              f = b.URL.replace(/[^/]+$/, ""),
              g = e.split("/").length,
              h = f.split("/").length,
              i = /^.+?\w\//,
              j = this.util_.repeat("../", Math.abs(g - h));
            switch (!0) {
              case g === h:
                d = 0;
                break;
              case h > g:
                d = 1;
                break;
              case g > h:
                d = -1
            }
            jQuery("[href], [src]", b).not(['[href^="/"]', '[href^= "http:"]', '[href^= "https:"]', '[src^= "/"]', '[src^= "http:"]', '[src^= "https:"]'].join(",")).each(c)
          }, b.prototype.escapeNoscript_ = function(a) {
            function b() {
              jQuery(this).text(this.innerHTML)
            }
            jQuery("noscript", a).children().parent().each(b)
          }, b.prototype.restoreNoscript_ = function(a) {
            var b = jQuery("<span/>");
            return a.replace(/(<noscript>)([^<>]+?)(<\/noscript>)/gim, function(a, c, d, e) {
              return c + b.html(d).text() + e
            })
          }, b.prototype.escapeScript_ = function(a) {
            jQuery.data(a, "source", a.src), jQuery.data(a, "code", a.innerHTML), a.removeAttribute("src"), a.innerHTML = ""
          }, b.prototype.restoreScript_ = function(a) {
            undefined !== jQuery.data(a, "code") && (a.innerHTML = " ", jQuery.data(a, "source") ? (a.src = jQuery.data(a, "source"), jQuery.removeData(a, "source")) : a.removeAttribute("src"), a.innerHTML = jQuery.data(a, "code"), jQuery.removeData(a, "code"))
          }, b.prototype.chooseArea = function() {}, b.prototype.dispatchEvent = function() {}, b
        }();
        b.PageUpdate = c
      }(c = b.APP || (b.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c;
      ! function(b) {
        var c = function() {
          function b() {
            this.util_ = a.LIBRARY.Utility, this.sandbox_cache_ = {}
          }
          return b.prototype.sandbox_ = function(a) {
            var b = this;
            return void 0 === a && (a = window.location.href), a = this.util_.canonicalizeUrl(a).split("#").shift(), this.sandbox_cache_[a] && "object" == typeof this.sandbox_cache_[a].document && this.sandbox_cache_[a].document.URL === a || jQuery('<iframe srcdoc="<!DOCTYPE html>" sandbox="allow-same-origin"></iframe>').appendTo("body").each(function(c, d) {
              b.sandbox_cache_[a] = d.contentWindow, b.sandbox_cache_[a].document.open(), b.sandbox_cache_[a].document.close()
            }).remove(), this.sandbox_cache_[a]
          }, b.prototype.test_ = function(a) {
            try {
              var b = '<html lang="en" class="html"><head><title>&amp;</title><link href="/"><noscript><style>/**/</style></noscript></head><body><noscript>noscript</noscript><a href="/"></a></body></html>',
                c = this.parse(b, window.location.href, a);
              switch (!1) {
                case !!c:
                case c.URL && decodeURI(c.URL) === decodeURI(window.location.href):
                case "&" === c.title:
                case !!c.querySelector('html.html[lang="en"]'):
                case !!c.querySelector("head>link").href:
                case !!c.querySelector("head>noscript").innerHTML:
                case !!c.querySelector("body>noscript").innerHTML:
                case !!c.querySelector("body>a").href:
                  throw !0
              }
              return a
            } catch (d) {}
          }, b.prototype.parse = function(a, b, c) {
            function d(a, b) {
              var c = document.createElement("div");
              c.innerHTML = b.match(/<html(?:\s.*?[^\\])?>|$/i).shift().replace(/html/i, "div") || "<div>";
              for (var d, e = c.firstChild.attributes, f = 0; d = e[f]; f++) a.documentElement.setAttribute(d.name, d.value);
              var c = document.createElement("html");
              for (c.innerHTML = b.replace(/^.*?<html(?:\s.*?[^\\])?>/im, ""), a.documentElement.removeChild(a.head), a.documentElement.removeChild(a.body); c.childNodes.length;) a.documentElement.appendChild(c.childNodes[0]);
              return a
            }
            void 0 === b && (b = ""), void 0 === c && (c = this.mode_), a += ~a.search(/<title[\s>]/i) ? "" : "<title></title>";
            var e;
            switch (c) {
              case "dom":
                e = (new window.DOMParser).parseFromString(a, "text/html");
                break;
              case "doc":
                if (e = document.implementation.createHTMLDocument(""), "object" != typeof e.activeElement || !e.activeElement) break;
                "function" == typeof window.DOMParser && (e.title = (new window.DOMParser).parseFromString(a.match(/<title(?:\s.*?[^\\])?>(?:.*?[^\\])?<\/title>|$/i), "text/html").title), e.open(), e.write(a), e.close(), e.title !== e.querySelector("title").textContent && (e.title = e.querySelector("title").textContent);
                break;
              case "manipulate":
                e = d(document.implementation.createHTMLDocument(""), a);
                break;
              case null:
                e = null;
                break;
              default:
                switch (/webkit|firefox|trident|$/i.exec(window.navigator.userAgent).shift().toLowerCase()) {
                  case "webkit":
                    this.mode_ = this.test_("doc") || this.test_("dom") || this.test_("manipulate");
                    break;
                  case "firefox":
                    this.mode_ = this.test_("dom") || this.test_("doc") || this.test_("manipulate");
                    break;
                  case "trident":
                    this.mode_ = this.test_("manipulate") || this.test_("dom") || this.test_("doc");
                    break;
                  default:
                    this.mode_ = this.test_("dom") || this.test_("doc") || this.test_("manipulate")
                }
                e = this.mode_ && this.parse(a, b)
            }
            return e
          }, b
        }();
        b.PageParser = c;
        var d = function() {
          function a() {
            a.instance_ = a.instance_ || new c
          }
          return a.prototype.singleton_ = function() {
            return a.instance_
          }, a.prototype.parse = function(a, b) {
            return this.singleton_().parse(a, b)
          }, a
        }();
        b.PageParserSingleton = d
      }(c = b.APP || (b.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c;
      ! function(b) {
        a.MIXIN(b.PageFetch, [b.PageUtility]), a.MIXIN(b.PageUpdate, [b.PageUtility]);
        var c = function() {
          function c(c, d, e) {
            var f = this;
            this.model_ = c, this.data_ = d, this.balancer_ = e, this.util_ = a.LIBRARY.Utility, this.parser = new b.PageParserSingleton, this.provider = new b.PageProvider(b.PageRecord, this.model_, this.balancer_, this), this.landing = this.util_.normalizeUrl(window.location.href), this.loadedScripts = {}, this.loadtime = 0, this.count = 0, this.time = (new Date).getTime(), setTimeout(function() {
              return f.parser.parse("") || f.model_.disable()
            }, 100)
          }
          return c.prototype.transfer = function(b, c) {
            switch (c.type.toLowerCase()) {
              case a.EVENT.CLICK:
                this.data_.saveTitle(), this.data_.saveScrollPosition();
                break;
              case a.EVENT.SUBMIT:
                this.data_.saveTitle(), this.data_.saveScrollPosition();
                break;
              case a.EVENT.POPSTATE:
                this.data_.saveTitle(b.origLocation.href, document.title), b.fix.history && this.data_.loadTitle()
            }
            b = jQuery.extend(!0, {}, b), b.origLocation = b.origLocation.cloneNode(), b.destLocation = b.destLocation.cloneNode(), b = a.FREEZE(b), this.fetch_(b, c)
          }, c.prototype.getWait = function() {
            return this.wait_
          }, c.prototype.setWait = function(a) {
            return this.wait_ && this.wait_.state && "pending" === this.wait_.state() && this.wait_.reject(), this.wait_ = a
          }, c.prototype.fetch_ = function(a, b) {
            var c = this;
            this.provider.fetchRecord(a, b, function(a, b, d) {
              return c.success_(a, b, d)
            }, function(a, b, d) {
              return c.failure_(a, b, d)
            })
          }, c.prototype.success_ = function(a, c, d) {
            new b.PageUpdate(this.model_, this, this.data_, this.balancer_, c, d, a)
          }, c.prototype.failure_ = function(a, b, c) {
            var d = this;
            b.fallback && "abort" !== a.data.textStatus() && (this.data_.saveExpires(b.destLocation.href, "", 0), b.balance.active && (this.data_.saveServer(a.data.host(), (new Date).getTime() + b.balance.server.expires, 0, 0, (new Date).getTime()), this.balancer_.changeServer(this.balancer_.chooseServer(b), b)), setTimeout(function() {
              return d.model_.fallback(c)
            }, 100))
          }, c.prototype.chooseArea = function() {}, c.prototype.dispatchEvent = function() {}, c
        }();
        b.Page = c
      }(c = b.APP || (b.APP = {}))
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(MODULE) {
    var MODEL;
    ! function(MODEL) {
      var APP;
      ! function(APP) {
        MODULE.MIXIN(APP.Page, [APP.PageUtility]);
        var Main = function() {
          function Main(a, b) {
            this.model_ = a, this.controller_ = b, this.util_ = MODULE.LIBRARY.Utility, this.settings_ = {}, this.data = new APP.Data(this.model_), this.balancer = new APP.Balancer(this.data), this.page = new APP.Page(this.model_, this.data, this.balancer)
          }
          return Main.prototype.initialize = function(a, b) {
            var c = this;
            this.controller_.view(a, b), this.balancer.enable(b), this.data.loadBuffers(), setTimeout(function() {
              return c.page.landing = null
            }, 1500)
          }, Main.prototype.configure = function(destination) {
            var _this = this,
              event = destination.preventDefault ? destination : null;
            switch (event && "object" == typeof event && event.type.toLowerCase()) {
              case MODULE.EVENT.CLICK:
                return this.configure(event.currentTarget);
              case MODULE.EVENT.SUBMIT:
                return this.configure(event.currentTarget);
              case MODULE.EVENT.POPSTATE:
                return this.configure(window.location);
              case null:
            }
            var url;
            switch (!0) {
              case "string" == typeof destination:
                url = destination;
                break;
              case "href" in destination:
                url = this.util_.normalizeUrl(destination.href);
                break;
              case "action" in destination:
                switch (url = this.util_.normalizeUrl(destination.action.replace(/[?#].*/, "")), destination.method.toUpperCase()) {
                  case "GET":
                    url += "?" + jQuery(destination).serialize()
                }
                break;
              default:
                url = this.model_.location.href, this.option_ = destination
            }
            var index = [this.util_.canonicalizeUrl(this.model_.location.href).slice(0, 2048), this.util_.canonicalizeUrl(url).slice(0, 2048)].join(" ");
            if (!this.option_) return null;
            if (index in this.settings_) return this.settings_[index];
            var origLocation = this.model_.location.cloneNode(),
              destLocation = this.model_.location.cloneNode();
            origLocation.href = this.util_.canonicalizeUrl(origLocation.href), destLocation.href = this.util_.canonicalizeUrl(url);
            var scope = this.scope_(this.option_, origLocation.href, destLocation.href) || null,
              initial = {
                area: "body",
                link: "a:not([target])",
                filter: function() {
                  return /^https?:/.test(this.href) && /\/[^.]*$|\.(html?|php)$/.test(this.pathname.replace(/^\/?/, "/"))
                },
                form: null,
                replace: null,
                scope: null,
                rewrite: null,
                state: null,
                scrollTop: 0,
                scrollLeft: 0,
                ajax: {
                  dataType: "text"
                },
                contentType: "text/html",
                redirect: !0,
                cache: {
                  click: !1,
                  submit: !1,
                  popstate: !1,
                  get: !0,
                  post: !0,
                  mix: 0,
                  limit: 100,
                  expires: {
                    max: null,
                    min: 3e5
                  }
                },
                buffer: {
                  limit: 30,
                  delay: 500
                },
                load: {
                  head: "",
                  css: !1,
                  script: !1,
                  ignore: '[src*="jquery.js"], [src*="jquery.min.js"], [href^="chrome-extension://"]',
                  reload: "",
                  log: "head, body",
                  error: !0,
                  ajax: {
                    dataType: "script",
                    cache: !0
                  }
                },
                balance: {
                  active: !1,
                  bounds: ["*"],
                  weight: 1,
                  random: 0,
                  option: {
                    server: {
                      header: !1
                    },
                    ajax: {
                      crossDomain: !0
                    },
                    callbacks: {
                      ajax: {
                        beforeSend: null
                      }
                    }
                  },
                  client: {
                    hosts: [],
                    support: {
                      browser: /msie|trident.+ rv:|chrome|firefox|safari/i,
                      redirect: /chrome|firefox|safari/i
                    },
                    cookie: {
                      balance: "balanceable",
                      redirect: "redirectable",
                      host: "host"
                    }
                  },
                  server: {
                    header: "X-Ajax-Host",
                    respite: 6e5,
                    expires: 864e6
                  }
                },
                wait: 0,
                fallback: !0,
                reset: {
                  type: "",
                  count: 100,
                  time: 108e5
                },
                fix: {
                  location: !0,
                  history: !0,
                  scroll: !0,
                  noscript: !0,
                  reference: !0
                },
                database: {
                  active: !0,
                  revision: 0,
                  refresh: 10
                },
                server: {
                  query: null,
                  header: !0
                },
                overlay: "",
                callback: null,
                callbacks: {
                  ajax: {},
                  update: {
                    redirect: {},
                    url: {},
                    rewrite: {},
                    title: {},
                    head: {},
                    content: {},
                    scroll: {},
                    css: {},
                    script: {},
                    balance: {}
                  }
                },
                data: undefined
              },
              force = {
                uid: MODULE.UUID(),
                ns: "",
                nss: undefined,
                speedcheck: undefined,
                origLocation: origLocation,
                destLocation: destLocation,
                scroll: {
                  queue: []
                },
                option: this.option_
              },
              compute = function() {
                setting.ns = setting.ns ? setting.ns.split(".").sort().join(".") : "";
                var nsArray = [MODULE.DEF.NAME].concat(setting.ns ? setting.ns.split(".") : []),
                  query = setting.server.query;
                switch (query && typeof query) {
                  case "string":
                    query = eval("({" + query.toString().match(/[^?=&]+=[^&]*/g).join("&").replace(/"/g, '\\"').replace(/([^?=&]+)=([^&]*)/g, '"$1": "$2"').replace(/&/g, ",") + "})");
                  case "object":
                    query = jQuery.param(query);
                    break;
                  default:
                    query = ""
                }
                return {
                  uid: undefined,
                  ns: undefined,
                  origLocation: undefined,
                  destLocation: undefined,
                  scroll: undefined,
                  option: undefined,
                  speedcheck: undefined,
                  nss: {
                    array: nsArray,
                    name: nsArray.join("."),
                    data: nsArray[0],
                    url: _this.model_.convertUrlToKey(setting.destLocation.href, !0),
                    event: {
                      pjax: {
                        fetch: [MODULE.EVENT.PJAX, "fetch"].join(":"),
                        unload: [MODULE.EVENT.PJAX, "unload"].join(":"),
                        DOMContentLoaded: [MODULE.EVENT.PJAX, "DOMContentLoaded"].join(":"),
                        ready: [MODULE.EVENT.PJAX, "ready"].join(":"),
                        render: [MODULE.EVENT.PJAX, "render"].join(":"),
                        load: [MODULE.EVENT.PJAX, "load"].join(":")
                      },
                      click: [MODULE.EVENT.CLICK].concat(nsArray.join(":")).join("."),
                      submit: [MODULE.EVENT.SUBMIT].concat(nsArray.join(":")).join("."),
                      popstate: [MODULE.EVENT.POPSTATE].concat(nsArray.join(":")).join("."),
                      scroll: [MODULE.EVENT.SCROLL].concat(nsArray.join(":")).join(".")
                    },
                    elem: nsArray.join("-"),
                    requestHeader: ["X", nsArray[0].replace(/^\w/, function(a) {
                      return a.toUpperCase()
                    })].join("-")
                  },
                  fix: /android|iphone os|like mac os x/i.test(window.navigator.userAgent) ? undefined : {
                    location: !1
                  },
                  contentType: setting.contentType.replace(/\s*[,;]\s*/g, "|").toLowerCase(),
                  database: {
                    refresh: Math.min(setting.database.refresh, 30)
                  },
                  reset: {
                    type: (setting.reset.type || "").toLowerCase()
                  },
                  server: {
                    query: query
                  },
                  timeStamp: (new Date).getTime()
                }
              },
              setting;
            return setting = jQuery.extend(!0, initial, scope || this.option_), setting = jQuery.extend(!0, setting, setting.balance.active && setting.balance.option, force), setting = jQuery.extend(!0, setting, compute()), scope ? (MODULE.FREEZE(setting, !0), this.settings_[index] = setting, setting) : (this.settings_[index] = null, null)
          }, Main.prototype.scope_ = function(a, b, c, d) {
            if (void 0 === d && (d = ""), a = jQuery.extend(!0, {}, a), !a.scope) return a;
            var e, f, g, h, i, j, k, l = a.scope;
            if (e = this.model_.convertUrlToKey(b, !0).match(/.+?\w(\/.*)/).pop(), f = this.model_.convertUrlToKey(c, !0).match(/.+?\w(\/.*)/).pop(), d = d.replace(/[#?].*/, ""), h = (d || e).split("/"), d) {
              if (!~d.indexOf("*")) return undefined;
              g = [];
              for (var m = e.split("/"), n = 0, o = h.length; o > n; n++) "*" === h[n] && g.push(m[n])
            }
            for (var n = h.length; n--;)
              if (i = h.slice(0, n + 1).join("/"), i += "/" === (d || e).charAt(i.length) ? "/" : "", i && i in l) {
                var p;
                if (l[i] instanceof Array ? (j = "", p = l[i]) : (j = l[i], p = l[j]), p) {
                  p = p.concat();
                  var q, r, s, t = [];
                  s = k = q = r = undefined;
                  for (var u, v = 0; u = p[v]; v++) {
                    if ("#" === u.charAt(0)) {
                      if (~jQuery.inArray(u, t) || !(u.length > 1)) {
                        j = "";
                        continue
                      }
                      t.push(u), j = u.slice(1), [].splice.apply(p, [v, 1].concat(l[j], "#")), u = p[v]
                    }
                    if ("inherit" === u) s = !0;
                    else if ("rewrite" !== u || "function" != typeof l.rewrite || d) {
                      if ("string" == typeof u) {
                        var w = "!" === u.charAt(0);
                        u = w ? u.slice(1) : u;
                        var x = "*" === u.charAt(0);
                        if (u = x ? u.slice(1) : u, d && ~u.indexOf("/*/"))
                          for (var y = 0, o = g.length; o > y; y++) u = u.replace("/*/", "/" + g[y] + "/");
                        (x ? ~e.search(u) : ~e.indexOf(u)) && (w ? q = !1 : (q = !0, k = l["$" + j] || l["$" + u] || undefined)), (x ? ~f.search(u) : ~f.indexOf(u)) && (w ? r = !1 : (r = !0, k = l["$" + j] || l["$" + u] || undefined))
                      }
                    } else k = this.scope_(a, b, c, this.util_.fire(l.rewrite, null, [f])), k ? q = r = !0 : null === k && (q = r = !1);
                    if (!1 === q || !1 === r) return null
                  }
                  if (q && r) return jQuery.extend(!0, a, k);
                  if (!s) break
                }
              }
            return undefined
          }, Main
        }();
        APP.Main = Main
      }(APP = MODEL.APP || (MODEL.APP = {}))
    }(MODEL = MODULE.MODEL || (MODULE.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(a) {
      a.App = a.APP.Main
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    var b;
    ! function(b) {
      var c = function(c) {
        function d() {
          c.call(this, 1), this.controller_ = new a.Controller(this).singleton(), this.app_ = new b.App(this, this.controller_), this.util_ = a.LIBRARY.Utility, this.isDeferrable = !!jQuery.when && "1.006" <= jQuery().jquery.match(/\d[\d.]+\d/).pop().replace(/\.(\d+)/g, ".00$1").replace(/0*(\d{3})/g, "$1"), this.location = document.createElement("a"), this.queue_ = []
        }
        return __extends(d, c), d.prototype.host = function() {
          return this.app_.balancer.host()
        }, d.prototype.state = function() {
          return this.state_
        }, d.prototype.main_ = function(b, c) {
          var d = this;
          switch (typeof c) {
            case "object":
              b = b instanceof a.DEF.NAMESPACE ? b : jQuery(document)[a.DEF.NAME](), a.FREEZE(c, !0);
              break;
            default:
              return b
          }
          if (!window.history || !window.history.pushState || !window.history.replaceState) return b;
          this.location.href = this.util_.normalizeUrl(window.location.href);
          var e = this.app_.configure(c);
          return e ? (this.app_.data.connect(e), this.speed = {
            fire: 0,
            time: [],
            name: [],
            now: function() {
              return (new Date).getTime()
            }
          }, jQuery(function() {
            d.app_.initialize(b, e), d.state_ = 1 === d.state() ? 2 : d.state(), d.overlay(e, !0)
          }), b) : b
        }, d.prototype.convertUrlToKey = function(a, b) {
          return a = b ? this.util_.canonicalizeUrl(a) : a, this.util_.trim(a).split("#").shift()
        }, d.prototype.compareKeyByUrl = function(a, b) {
          return a = this.convertUrlToKey(a, !0), b = this.convertUrlToKey(b, !0), a === b
        }, d.prototype.comparePageByUrl = function(a, b) {
          return a = this.convertUrlToKey(a, !0), b = this.convertUrlToKey(b, !0), a === b
        }, d.prototype.configure = function(a) {
          return this.app_.configure(a)
        }, d.prototype.isOperatable = function(b) {
          if (2 !== this.state()) return !1;
          if (b.which > 1 || b.metaKey || b.ctrlKey || b.shiftKey || b.altKey) return !1;
          var c;
          switch (b.type.toLowerCase()) {
            case a.EVENT.CLICK:
              if (c = this.app_.configure(b.currentTarget), c && !jQuery(b.currentTarget).filter(c.filter).length) return !1;
              break;
            case a.EVENT.SUBMIT:
              c = this.app_.configure(b.currentTarget);
              break;
            case a.EVENT.POPSTATE:
              c = this.app_.configure(window.location)
          }
          if (!c) return !1;
          if (c.origLocation.protocol !== c.destLocation.protocol || c.origLocation.host !== c.destLocation.host) return !1;
          switch (b.type.toLowerCase()) {
            case a.EVENT.CLICK:
              if (this.comparePageByUrl(c.origLocation.href, c.destLocation.href) && c.destLocation.hash) return !1;
              break;
            case a.EVENT.SUBMIT:
              break;
            case a.EVENT.POPSTATE:
              if (this.comparePageByUrl(c.origLocation.href, c.destLocation.href)) return !1
          }
          return this.app_.page.chooseArea(c.area, document, document) ? !0 : !1
        }, d.prototype.getXHR = function() {
          return this.app_.page.xhr
        }, d.prototype.setXHR = function(a) {
          return this.app_.balancer.sanitize(a, this.app_.configure(window.location)), this.app_.page.xhr && this.app_.page.xhr.readyState < 4 && this.app_.page.xhr !== a && this.app_.page.xhr.abort(), this.app_.page.xhr = a
        }, d.prototype.click = function(a) {
          a.timeStamp = (new Date).getTime();
          var b = a.currentTarget,
            c = (jQuery(b), this.app_.configure(b));
          switch (this.location.href = this.util_.normalizeUrl(window.location.href), !0) {
            case !c:
            case a.isDefaultPrevented():
            case 2 !== this.state():
              break;
            case this.isOperatable(a):
              this.app_.page.transfer(c, a), a.preventDefault();
              break;
            case this.isHashChange(c) && this.overlay(c):
              a.preventDefault(), window.history.pushState(null, document.title, c.destLocation.href);
              break;
            case !a.originalEvent && !jQuery(document).has(b).length:
              this.fallback(a)
          }
        }, d.prototype.submit = function(a) {
          a.timeStamp = (new Date).getTime();
          var b = a.currentTarget,
            c = (jQuery(b), this.app_.configure(b));
          switch (this.location.href = this.util_.normalizeUrl(window.location.href), !0) {
            case !c:
            case a.isDefaultPrevented():
            case 2 !== this.state():
              break;
            case this.isOperatable(a):
              this.app_.page.transfer(c, a), a.preventDefault;
              break;
            case !a.originalEvent && !jQuery(document).has(b).length:
              this.fallback(a)
          }
        }, d.prototype.popstate = function(a) {
          if (!this.app_.page.landing || !this.util_.compareUrl(this.app_.page.landing, window.location.href)) {
            a.timeStamp = (new Date).getTime();
            var b = this.app_.configure(window.location);
            switch (!0) {
              case !b:
                !this.comparePageByUrl(this.location.href, window.location.href) && this.fallback(a);
                break;
              case 2 !== this.state():
                break;
              case this.isOperatable(a):
                this.app_.page.transfer(b, a);
                break;
              case this.isHashChange(b) && this.overlay(b):
                break;
              case !this.comparePageByUrl(b.origLocation.href, window.location.href):
                this.fallback(a)
            }
            this.location.href = this.util_.normalizeUrl(window.location.href)
          }
        }, d.prototype.scroll = function() {
          for (var a, b = this; a = this.queue_.shift();) clearTimeout(a);
          a = setTimeout(function() {
            for (; a = b.queue_.shift();) clearTimeout(a);
            b.compareKeyByUrl(window.location.href, b.location.href) && b.app_.data.saveScrollPosition()
          }, 300), this.queue_.push(a)
        }, d.prototype.fallback = function(a) {
          var b = this.configure(a);
          switch (!0) {
            case b && !b.fallback:
            case b && !1 === this.util_.fire(b.fallback, b, [a, b, b.origLocation.cloneNode(), b.destLocation.cloneNode()]):
              break;
            default:
              this.movePageNormally_(a)
          }
        }, d.prototype.movePageNormally_ = function(b) {
          switch (b.type.toLowerCase()) {
            case a.EVENT.CLICK:
              window.location.assign(b.currentTarget.href);
              break;
            case a.EVENT.SUBMIT:
              switch (b.currentTarget.method.toUpperCase()) {
                case "GET":
                  window.location.assign(b.currentTarget.action.replace(/[?#].*/, "") + "?" + jQuery(b.currentTarget).serialize());
                  break;
                case "POST":
                  window.location.assign(b.currentTarget.action)
              }
              break;
            case a.EVENT.POPSTATE:
              window.location.reload()
          }
        }, d.prototype.isHashChange = function(a) {
          return !!a && a.origLocation.href.replace(/#.*/, "") === a.destLocation.href.replace(/#.*/, "") && a.origLocation.hash !== a.destLocation.hash
        }, d.prototype.overlay = function(a, b) {
          var c = this,
            d = a.destLocation.hash.replace(/^#/, "");
          if (!d || !a.overlay) return !1;
          var e = jQuery("#" + d + ", [name~=" + d + "]");
          if (e = e.add(e.nextUntil(":header")), e = e.filter(a.overlay).add(e.find(a.overlay)).first(), !e.length) return !1;
          this.isHashChange(a) && (this.app_.data.loadScrollPosition(), setTimeout(function() {
            return c.app_.data.loadScrollPosition()
          }, 1));
          var f = jQuery("<div>");
          return e = e.clone(!0), f.addClass(a.nss.elem + "-overlay").css({
            background: "rgba(255, 255, 255, 0.8)",
            display: "none",
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }).append(e.css({
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            margin: "auto"
          }).show()), f.bind("click", f, function(a) {
            a.target === a.currentTarget && (window.history.pushState(window.history.state, document.title, window.location.href.replace(/#.*/, "")), c.location.href = c.util_.normalizeUrl(window.location.href), jQuery(a.data).fadeOut("fast", function() {
              return jQuery(a.data).remove()
            }))
          }), f.appendTo("body").fadeIn(b ? 0 : 100), jQuery(window).one("popstate", f, function(a) {
            setTimeout(function() {
              return c.app_.data.loadScrollPosition()
            }, 1), jQuery(a.data).fadeOut("fast", function() {
              return jQuery(a.data).remove()
            })
          }), /trident/i.test(window.navigator.userAgent) && e.width(e.width()), this.app_.data.saveScrollPosition(), !0
        }, d.prototype.enable = function() {
          this.state_ = 2
        }, d.prototype.disable = function() {
          this.state_ = 3
        }, d.prototype.getCache = function(a) {
          var b = this.configure(this.convertUrlToKey(a));
          if (b) {
            var c = this.app_.page.provider.getRecord(b);
            return c.state(b) || c.data.data() ? {
              data: c.data.data(),
              textStatus: c.data.textStatus(),
              jqXHR: c.data.jqXHR(),
              expires: c.data.expires(),
              host: c.data.host()
            } : void this.removeCache(a)
          }
        }, d.prototype.setCache = function(a, b, c, d) {
          var e = this.configure(this.convertUrlToKey(a));
          if (e) {
            var f = this.app_.page.provider.getRecord(e);
            this.app_.page.provider.setRecord(e, b || "", c || f.data.textStatus(), d || f.data.jqXHR(), this.app_.balancer.sanitize(d, e) || f.data.host() || "")
          }
        }, d.prototype.removeCache = function(a) {
          var b = this.configure(this.convertUrlToKey(a));
          b && this.app_.page.provider.removeRecord(b)
        }, d.prototype.clearCache = function() {
          this.app_.page.provider.clearRecord()
        }, d.prototype.bypass = function() {
          return this.app_.balancer.bypass(this.app_.configure(window.location))
        }, d
      }(b.Template);
      b.Main = c;
      var d = function() {
        function a() {
          a.instance_ = a.instance_ || new c
        }
        return a.singleton = function() {
          return a.instance_
        }, a.prototype.singleton = function() {
          return a.singleton()
        }, a
      }();
      b.Singleton = d
    }(b = a.MODEL || (a.MODEL = {}))
  }(MODULE || (MODULE = {}));
  var MODULE;
  ! function(a) {
    a.Model = a.MODEL.Singleton
  }(MODULE || (MODULE = {}));
  var Module = function() {
    function a() {
      new MODULE.Model
    }
    return a
  }();
  new Module
}(window, window.document, void 0, jQuery);

function init() {
  (navigator.userAgent.indexOf("iPhone") > 0 && -1 == navigator.userAgent.indexOf("iPad") || navigator.userAgent.indexOf("iPod") > 0 || navigator.userAgent.indexOf("Android") > 0) && (spFlag = !0), $html = $("html"), $progress_bar = $(".progress span"), $progress_num = $(".progress p"), $left = $(".leftContent"), $right = $(".rightContent"), $all = $(".all"), $center = $(".centerContent"), $graph = $(".graph"), $graphic = $(".graphic"), $changeColorWrap = $(".changeColorWrap"), $aboutGraph = $(".aboutCircleGraph"), $aboutGraphCV = $(".aboutCircleGraph").find("canvas"), $contact = $(".contact"), $subpageMain = $(".subpageWrap .main"), $loading = $(".loading"), $wW = $(".wW"), $wH = $(".wH"), $loadmask = $(".loadmask"), $product = $(".product"), subpageFlag = $(".subpages").length, aboutFlag = $aboutGraph.length, $aboutOffset = $(".aboutOffset"), $addmember = $(".addmember"), $addpost = $(".addpost"), $addeye = $(".addeye"), subpageFlag ? $html.addClass("onsubpage") : $html.removeClass("onsubpage"), setSize(), getUA(), $html.addClass(getUA()), richFlag || $html.removeClass("high"), !subpageFlag && richFlag && $(".scroll").mCustomScrollbar({
    axis: "y",
    mouseWheel: {
      enable: !1
    },
    scrollInertia: 100,
    callbacks: {
      whileScrolling: function() {
        if (threeFlag) {
          if ("MONO" === colorType) var e = Math.abs(this.mcs.top / 15);
          else if ("STAR" === colorType) var e = Math.abs(this.mcs.top / 3);
          else var e = Math.abs(this.mcs.top / 10);
          camera.position.z = MODELZ + e
        }
      }
    }
  })
}

function getQuerystring(e, a) {
  null == a && (a = ""), e = e.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
  var i = new RegExp("[\\?&]" + e + "=([^&#]*)"),
    t = i.exec(window.location.href);
  return null == t ? a : t[1]
}

function setSize() {
  windowWidth = window.innerWidth, windowHeight = window.innerHeight, windowWidthHalf = windowWidth / 2, windowHeightHalf = windowHeight / 2, canvasRatio = 940, canvasWidth = canvasRatio, canvasHeight = canvasRatio, canvasWidthHalf = canvasWidth / 2, canvasHeightHalf = canvasHeight / 2, canvasRatio3D = 500, canvasWidth3D = canvasRatio3D, canvasHeight3D = canvasRatio3D, canvasWidthHalf3D = canvasWidth3D / 2, canvasHeightHalf3D = canvasHeight3D / 2, leftWidth = $left.width() + 80, rightWidth = $right.width() + 80, centerWidth = $all.width() - leftWidth - rightWidth - 20, centerWidthHalf = centerWidth / 2, $center.css({
    width: centerWidth,
    "margin-left": -centerWidth / 2
  }), $graph.css({
    width: centerWidth,
    "margin-left": -centerWidth / 2
  }), graphR = 330, graphRO = 330, centerWidth > 2 * graphRO + 20 ? (wWOver = !1, $html.removeClass("wwov")) : (wWOver = !0, $html.addClass("wwov")), windowHeight > 840 ? (wHOver = !1, $html.removeClass("whov")) : (wHOver = !0, $html.addClass("whov")), graphR = wHOver && wWOver ? (centerWidth - 60) / 2 : !wHOver && wWOver ? (centerWidth - 60) / 2 : wHOver && !wWOver ? (windowHeight - 160) / 2 : graphRO, $wW.text(windowWidth), $wH.text(windowHeight), graphRadius = graphR, subpageWidth = $all.width() - leftWidth, $subpageMain.css({
    width: subpageWidth,
    height: windowHeight
  }), $loadmask.css({
    width: subpageWidth,
    height: windowHeight
  }), $product.css({
    height: windowHeight - 40
  }), aboutFlag && (aboutOffsetTop = $aboutOffset.offset().top - windowHeight + 200)
}

function getUA() {
  var e = window.navigator.userAgent.toLowerCase(),
    a = window.navigator.appVersion.toLowerCase();
  return e.indexOf("msie") > -1 ? a.indexOf("msie 6.0") > -1 ? "ie ie6" : a.indexOf("msie 7.0") > -1 ? (webAudio = !1, webGL = !1, "ie ie7 low") : a.indexOf("msie 8.0") > -1 ? (webAudio = !1, webGL = !1, "ie ie8 low") : a.indexOf("msie 9.0") > -1 ? (webAudio = !1, webGL = !1, "ie ie9 low") : a.indexOf("msie 10.0") > -1 ? (webAudio = !1, webGL = !1, "ie ie10 low") : (webAudio = !1, webGL = !0, "ie low") : a.indexOf("trident/7.0") > -1 ? (webGL = !1, webAudio = !1, "ie ie11 low") : e.indexOf("firefox") > -1 ? (webGL = !0, "firefox low") : e.indexOf("opera") > -1 ? (webGL = !1, "opera low") : e.indexOf("chrome") > -1 ? (webGL = !0, richFlag = !0, "chrome high") : e.indexOf("safari") > -1 ? (webGL = !1, richFlag = !0, "safari high") : void 0
}
var loaded = !1,
  RAD = Math.PI / 180,
  PI2 = 2 * Math.PI,
  windowWidth = 0,
  windowHeight = 0,
  windowWidthHalf = 0,
  windowHeightHalf = 0,
  wHOver = !1,
  wWOver = !1,
  canvasWidth = 0,
  canvasHeight = 0,
  canvasWidthHalf = 0,
  canvasHeightHalf = 0,
  mouseStatus = {
    x: 0,
    y: 0,
    cx: 0,
    cy: 0,
    px: 0,
    py: 0,
    deg: 0
  },
  ratio = 1,
  graphR = 0,
  loadFlag = !1,
  mousedeg = 0,
  colorType = "MONO",
  canPlayFlag = !0,
  richFlag = !1,
  onetime = !1,
  ajax = !1,
  pvHover = 0,
  canvasXY = {
    x: 0,
    y: 0
  },
  easeing = Power4.easeInOut,
  pvRatioAnimateFlag = !1,
  circleAnimateFlag = !1,
  subpageFlag = !1,
  aboutFlag = !1,
  spFlag = !1,
  renderAboutInt, render2DInt, render3DInt, activeUser = 0,
  fetFlag = !1,
  splash = !1,
  webGL = !0,
  webAudio = !0,
  MODELZ = 0;
$(function() {
  init(), URL = $(".propurl").data("url"), SCHEME_QUERY = getQuerystring("sc"), COOKIE = $.cookie("color"), colorType = "a" === SCHEME_QUERY || "a" === COOKIE ? "BASIC" : "b" === SCHEME_QUERY || "b" === COOKIE ? "COLORFUL" : "c" === SCHEME_QUERY || "c" === COOKIE ? "STAR" : "MONO", checkTheme()
});



function drawWave() {
  if (analyser.getByteTimeDomainData(audioArray), !subpageFlag && MemoriFlag)
    for (var t = 0; 360 > t; t++) {
      var a = audioArray[Math.floor(t * bufferCircle)] / 4;
      MemoriPosition[t][0] = (graphRadius - 50 + a) * Math.cos(t * RAD) + canvasWidthHalf, MemoriPosition[t][1] = (graphRadius - 50 + a) * Math.sin(t * RAD) + canvasHeightHalf, MemoriPosition[t][2] = (graphRadius - 50) * Math.cos(t * RAD) + canvasWidthHalf, MemoriPosition[t][3] = (graphRadius - 50) * Math.sin(t * RAD) + canvasHeightHalf
    }
  for (var t = 0; t < bufferAVLength; t++) {
    var a = audioArray[Math.floor(t * bufferAV)] / 4 - 25;
    audioArrr[t] = a
  }
}

function setVisual() {
  audioWidth = 300, audioHeight = 95, audioWidthHalf = Math.floor(audioWidth / 2), audioHeightHalf = Math.floor(audioHeight / 2), canvasAV = $(".audioVisual")[0], ctxAV = canvasAV.getContext("2d"), canvasAV.width = audioWidth, canvasAV.height = audioHeight, $(".audioVisual").css({
    width: audioWidth,
    height: audioHeight
  }), audioArrr = [];
  for (var t = 0; t < bufferAVLength; t++) audioArrr.push(0)
}

function drawAV() {
  ctxAV.clearRect(0, 0, audioWidth, audioHeight), ctxAV.save(), ctxAV.translate(.5, .5), ctxAV.lineWidth = 2, ctxAV.strokeStyle = "rgba(" + AVCOLOR.RGB[0] + "," + AVCOLOR.RGB[1] + "," + AVCOLOR.RGB[2] + "," + AVCOLOR.ALPHA[0] + ")";
  for (var t = 0; t < bufferAVLength; t++) {
    var a = 4 * t + 10.5,
      e = audioHeightHalf;
    ctxAV.beginPath(), ctxAV.moveTo(a, e + audioArrr[t]), ctxAV.lineTo(a, e - audioArrr[t]), ctxAV.stroke()
  }
  ctxAV.strokeStyle = "rgba(" + AVCOLOR.RGB[0] + "," + AVCOLOR.RGB[1] + "," + AVCOLOR.RGB[2] + "," + AVCOLOR.ALPHA[1] + ")";
  for (var t = 0; t < bufferAVLength; t++) {
    var a = 4 * t + 10.5,
      e = audioHeightHalf;
    ctxAV.beginPath(), ctxAV.moveTo(a, e - audioArrr[t] - 2), ctxAV.lineTo(a, e - audioArrr[t] - 3), ctxAV.stroke()
  }
  for (var t = 0; t < bufferAVLength; t++) {
    var a = 4.5 * t,
      e = audioHeightHalf,
      o = a / bufferAVmax * 100;
    bgmPAR > o ? ctxAV.strokeStyle = "rgba(" + AVCOLOR.RGB[0] + "," + AVCOLOR.RGB[1] + "," + AVCOLOR.RGB[2] + "," + AVCOLOR.ALPHA[2] + ")" : ctxAV.strokeStyle = "rgba(" + AVCOLOR.RGB[0] + "," + AVCOLOR.RGB[1] + "," + AVCOLOR.RGB[2] + "," + AVCOLOR.ALPHA[3] + ")", ctxAV.beginPath(), ctxAV.moveTo(a, e + 40), ctxAV.lineTo(a, e + 40.5), ctxAV.stroke()
  }
  ctxAV.restore()
}

function renderAV() {
  renderAudioInt = window.requestAnimationFrame(renderAV), drawAV(), drawWave()
}

function setSize2D() {
  canvasCR = $(".circle")[0], ctxCR = canvasCR.getContext("2d"), canvasCR.width = canvasWidth, canvasCR.height = canvasHeight, $(".graphic").css({
    width: canvasWidth / ratio,
    height: canvasHeight / ratio,
    "margin-left": -canvasWidthHalf / ratio,
    "margin-top": -canvasHeightHalf / ratio
  }), pointStatus = {
    w: 140,
    h: 70,
    x: canvasWidthHalf + graphRadius - 129,
    y: 50,
    ox: canvasWidthHalf + graphRadius + 11,
    oy: 120
  }, pointPosition = [];
  for (var t = 1; 10 > t; t++) {
    var a = pointStatus.x + pointStatus.w / 10 * t,
      e = pointStatus.y + pointStatus.h / 5 * t,
      o = pointStatus.ox,
      i = pointStatus.oy;
    pointPosition.push([a, e, o, i])
  }
  textPosition = [];
  var r = pointStatus.ox,
    n = pointStatus.oy + 17,
    s = pointStatus.x - 17,
    c = pointStatus.y - 2,
    l = pointStatus.x - 55,
    R = pointStatus.y - 2,
    u = pointStatus.x - 55,
    h = pointStatus.y + 12,
    d = pointStatus.x - 100;
  textPosition.push(r, n, s, c, l, R, u, h, d), MemoriPosition = [];
  for (var t = 360; t > 0; t--) {
    var a = graphRadius * Math.cos(t * RAD) + canvasWidthHalf,
      e = graphRadius * Math.sin(t * RAD) + canvasHeightHalf,
      o = (graphRadius - 50) * Math.cos(t * RAD) + canvasWidthHalf,
      i = (graphRadius - 50) * Math.sin(t * RAD) + canvasHeightHalf;
    MemoriPosition.push([a, e, o, i])
  }
  MemoriFlag = !0, MemoriInnerPosition = [];
  for (var t = 360; t > 0; t -= 2) {
    var a = (graphRadius - 70) * Math.cos(t * RAD) + canvasWidthHalf,
      e = (graphRadius - 70) * Math.sin(t * RAD) + canvasHeightHalf,
      o = (graphRadius - 74) * Math.cos(t * RAD) + canvasWidthHalf,
      i = (graphRadius - 74) * Math.sin(t * RAD) + canvasHeightHalf;
    MemoriInnerPosition.push([a, e, o, i])
  }
  barChartRadius = [], barChartPar = [.001, .001, .001, .001, .001];
  for (var t = 5; t >= 0; t--) barChartRadius.push(graphRadius - 40 + 5 * t);
  if (pvRatio = [.001, .001, .001, .001, .001, .001], MemoriOuterDegree = 36, MemoriOuterR1 = graphRadius + 10, MemoriOuterR2 = graphRadius + 24, MemoriOuterR3 = graphRadius + 18, gaishuuPosition = [], setMemoriOuter(0), $graphic.length) {
    var g = $graphic.offset().left,
      v = $graphic.offset().top;
    canvasXY.x = g, canvasXY.y = v
  }
}

function setMemoriOuter(t) {
  var a = MemoriOuterR1 * Math.cos(t * RAD) + canvasWidthHalf,
    e = MemoriOuterR1 * Math.sin(t * RAD) + canvasHeightHalf,
    o = MemoriOuterR2 * Math.cos(t * RAD) + canvasWidthHalf,
    i = MemoriOuterR2 * Math.sin(t * RAD) + canvasHeightHalf,
    r = MemoriOuterR1 * Math.cos((MemoriOuterDegree + t) * RAD) + canvasWidthHalf,
    n = MemoriOuterR1 * Math.sin((MemoriOuterDegree + t) * RAD) + canvasHeightHalf,
    s = MemoriOuterR2 * Math.cos((MemoriOuterDegree + t) * RAD) + canvasWidthHalf,
    c = MemoriOuterR2 * Math.sin((MemoriOuterDegree + t) * RAD) + canvasHeightHalf;
  gaishuuPosition.push(a, e, o, i, r, n, s, c)
}

function loadPageview() {
  animatePv = [], animatePvName = [], animateBarTo = [], animatePvTo = [], animatePv = {
    name: [],
    view: [],
    line: [],
    day: [],
    circle: []
  }, animatePvFrom = [0, 0, 0, 0, 0, 0, 0], $day = $(".day"), $v1 = $(".view1"), $v2 = $(".view2"), $v3 = $(".view3"), $v4 = $(".view4"), $v5 = $(".view5"), $v6 = $(".view6"), $total = $(".total"), $dnames = $(".dnames"), $onames = $(".onames"), $bnames = $(".bnames"), $.ajax({
    type: "GET",
    url: "http://www.newstech.jp/ga/files/pageview.json",
    dataType: "json",
    success: function(t) {
      for (var a = t.pageview.length, e = 0, o = [], i = 0; a > i; i++) {
        var r = Number(t.pageview[i]["/"]),
          n = Number(t.pageview[i]["/product/"]),
          s = Number(t.pageview[i]["/about/"]),
          c = Number(t.pageview[i]["/news/"]),
          l = Number(t.pageview[i]["/recruit/"]),
          R = Number(t.pageview[i]["/contact/"]),
          u = Number(t.pageview[i]["ga:pageviews"]);
        isNaN(r) && (r = 0), isNaN(n) && (n = 0), isNaN(s) && (s = 0), isNaN(c) && (c = 0), isNaN(l) && (l = 0), isNaN(R) && (R = 0), isNaN(u) && (u = 0);
        var h = n + s + c + l + R;
        o.push(h), e += h, animateMax = [n, s, c, l, R];
        var d = Math.max.apply(null, animateMax),
          g = n / d * 65,
          v = s / d * 65,
          C = c / d * 65,
          O = l / d * 65,
          p = R / d * 65;
        animatePv.circle.push([g, v, C, O, p]), animatePv.view.push([r, n, s, c, l, R, u])
      }
      var m = o[0] / e * 360,
        A = o[1] / e * 360 + m,
        f = o[3] / e * 360 + A,
        x = o[4] / e * 360 + f,
        b = o[5] / e * 360 + x;
      animatePv.line.push(0, m, A, f, x, b);
      for (var i = 1; 7 > i; i++) {
        var H = new Date,
          L = ["Jan", "Feb", "March", "April", "May", "June", "July", "Aug", "Sept", "Oct", "Nov", "Dec"],
          w = (L[H.getMonth()], H.getDate() - i),
          P = w;
        animatePv.day.push(P)
      }
      uaRatio = [], browsRatio = [0], browsName = [];
      for (var y = t.brows.length, h = 0, i = 0; y > i; i++) {
        var T = Number(t.brows[i][1]);
        h += T
      }
      for (var M = 0, i = 0; y > i; i++) {
        M += Number(t.brows[i][1]) / h * 360;
        var B = t.brows[i][0];
        "Internet Explorer" === B && (B = "IE"), browsName.push(B), browsRatio.push(M)
      }
      var M = 0;
      osRatio = [0], osName = [];
      for (var y = t.os.length, h = 0, i = 0; y > i; i++) {
        var T = Number(t.os[i][1]);
        h += T
      }
      for (var i = y - 1; i >= 0; i--) {
        M += Number(t.os[i][1]) / h * 360;
        var B = t.os[i][0];
        osName.push(B), osRatio.push(M)
      }
      var M = 0;
      dvRatio = [0], dvName = [];
      for (var y = t.device.length, h = 0, i = 0; y > i; i++) {
        var T = Number(t.device[i][1]);
        h += T
      }
      for (var i = 0; y > i; i++) {
        M += Number(t.device[i][1]) / h * 360;
        var B = t.device[i][0];
        dvName.push(B), dvRatio.push(M)
      }
      dvRatio.push(360), uaRatio.push(dvRatio), uaRatio.push(osRatio), uaRatio.push(browsRatio), onetime = !0, ajax = !0, uaID = 0;
      for (var S = 0; S < dvName.length; S++) {
        var $ = '<li data-hv="' + uaID + '">' + dvName[S] + "</li>";
        $dnames.append($), uaID++
      }
      for (var S = 0; S < osName.length; S++) {
        var $ = '<li data-hv="' + uaID + '">' + osName[S] + "</li>";
        $onames.append($), uaID++
      }
      for (var S = 0; S < browsName.length; S++) {
        var $ = '<li data-hv="' + uaID + '">' + browsName[S] + "</li>";
        $bnames.append($), uaID++
      }
      initRectXY(), pvRatioAnimateFlag = !0
    }
  })
}

function initRectXY() {
  pvRatioXY = [];
  for (var t = 0; t < animatePv.line.length; t++) {
    var a = (graphRadius - 50) * Math.cos(animatePv.line[t] * RAD) + canvasWidthHalf,
      e = (graphRadius - 50) * Math.sin(animatePv.line[t] * RAD) + canvasHeightHalf,
      o = Math.floor(a - 5),
      i = Math.floor(e - 5),
      r = (graphRadius - 50) * Math.cos((animatePv.line[t] - 90) * RAD) + canvasWidthHalf + canvasXY.x,
      n = (graphRadius - 50) * Math.sin((animatePv.line[t] - 90) * RAD) + canvasHeightHalf + canvasXY.y;
    pvRatioXY.push([a, e, o, i, r, n])
  }
}

function drawLN() {
  ctxCR.save(), ctxCR.translate(canvasWidthHalf, canvasHeightHalf), ctxCR.rotate(90 * Math.PI / 180), ctxCR.translate(-canvasWidthHalf, -canvasHeightHalf), ctxCR.lineWidth = 1;
  for (var t = 0; t < lineObject.length; t++) {
    var a = LNCOLOR.RGB[0],
      e = LNCOLOR.RGB[1],
      o = LNCOLOR.RGB[2],
      i = LNCOLOR.ALPHA[t];
    ctxCR.strokeStyle = "rgba(" + a + "," + e + "," + o + "," + i + ")", ctxCR.beginPath();
    for (var r = 1; r < lineObject[t].length; r += 2) {
      var n = canvasWidthHalf - lineObject[t][r],
        s = canvasHeightHalf - lineObject[t][r + 1];
      ctxCR.lineTo(n, s)
    }
    ctxCR.stroke()
  }
  ctxCR.strokeStyle = "rgba(" + BXCOLOR.RGB[0] + "," + BXCOLOR.RGB[1] + "," + BXCOLOR.RGB[2] + "," + BXCOLOR.ALPHA[0] + ")", ctxCR.beginPath();
  var n = canvasWidthHalf - B1[0],
    s = canvasHeightHalf - B1[1];
  ctxCR.rect(n, s, 151, 6), ctxCR.stroke(), ctxCR.strokeStyle = "rgba(" + BXCOLOR.RGB[0] + "," + BXCOLOR.RGB[1] + "," + BXCOLOR.RGB[2] + "," + BXCOLOR.ALPHA[1] + ")", ctxCR.beginPath();
  var n = canvasWidthHalf - B2[0],
    s = canvasHeightHalf - B2[1];
  ctxCR.rect(n, s, 215, 4), ctxCR.stroke(), ctxCR.beginPath();
  var n = canvasWidthHalf - B3[0],
    s = canvasHeightHalf - B3[1];
  ctxCR.rect(n, s, 438, 4), ctxCR.stroke(), ctxCR.strokeStyle = "rgba(" + MEMORICOLOR.RGB[0] + "," + MEMORICOLOR.RGB[1] + "," + MEMORICOLOR.RGB[2] + "," + MEMORICOLOR.ALPHA[0] + ")", ctxCR.beginPath();
  var c = canvasWidthHalf - 330,
    l = (canvasWidthHalf + 330, canvasHeightHalf + 394);
  ctxCR.moveTo(c, R), ctxCR.lineTo(c, l), ctxCR.stroke();
  for (var t = 0; 7 > t; t++) {
    if (ctxCR.beginPath(), 6 === t) var c = canvasWidthHalf - (330 - 110 * t) - 1;
    else var c = canvasWidthHalf - (330 - 110 * t);
    var R = canvasHeightHalf + 394,
      l = canvasHeightHalf + 388;
    ctxCR.moveTo(c, R), ctxCR.lineTo(c, l), ctxCR.stroke()
  }
  ctxCR.strokeStyle = "rgba(" + MEMORICOLOR.RGB[0] + "," + MEMORICOLOR.RGB[1] + "," + MEMORICOLOR.RGB[2] + "," + MEMORICOLOR.ALPHA[1] + ")";
  for (var t = 0; 133 > t; t++) {
    if (ctxCR.beginPath(), 132 === t) var c = canvasWidthHalf - (330 - 5 * t) - 1;
    else var c = canvasWidthHalf - (330 - 5 * t);
    var R = canvasHeightHalf + 397,
      l = canvasHeightHalf + 399;
    ctxCR.moveTo(c, R), ctxCR.lineTo(c, l), ctxCR.stroke()
  }
  ctxCR.restore()
}

function drawCR() {
  361 > jiten ? jiten += .1 : jiten = 0;
  var t = 0,
    a = 0,
    e = 0,
    o = 0,
    i = 0,
    r = 0;
  ctxCR.clearRect(0, 0, canvasWidth, canvasHeight), ctxCR.lineWidth = 1, ctxCR.save(), ctxCR.translate(canvasWidthHalf + t, canvasHeightHalf + a), ctxCR.rotate(jiten / 2 * Math.PI / 180), ctxCR.translate(-canvasWidthHalf + t, -canvasHeightHalf + a), ctxCR.strokeStyle = "rgba(" + GAISHUUCOLOR.RGB[0] + "," + GAISHUUCOLOR.RGB[1] + "," + GAISHUUCOLOR.RGB[2] + "," + GAISHUUCOLOR.ALPHA[0] + ")", ctxCR.beginPath();
  for (var n = MemoriInnerPosition.length - 1; n >= 0; n--) ctxCR.moveTo(MemoriInnerPosition[n][0], MemoriInnerPosition[n][1]), ctxCR.lineTo(MemoriInnerPosition[n][2], MemoriInnerPosition[n][3]);
  ctxCR.stroke(), ctxCR.restore(), ctxCR.save(), ctxCR.translate(canvasWidthHalf + e, canvasHeightHalf + o), ctxCR.rotate(jiten * Math.PI / 180), ctxCR.translate(-canvasWidthHalf + e, -canvasHeightHalf + o), ctxCR.strokeStyle = "rgba(" + GAISHUUCOLOR.RGB[0] + "," + GAISHUUCOLOR.RGB[1] + "," + GAISHUUCOLOR.RGB[2] + "," + GAISHUUCOLOR.ALPHA[1] + ")", ctxCR.beginPath();
  for (var n = MemoriPosition.length - 1; n >= 0; n--) ctxCR.moveTo(MemoriPosition[n][0], MemoriPosition[n][1]), ctxCR.lineTo(MemoriPosition[n][2], MemoriPosition[n][3]);
  ctxCR.stroke(), ctxCR.restore(), ctxCR.strokeStyle = "rgba(" + GAISHUUCOLOR.RGB[0] + "," + GAISHUUCOLOR.RGB[1] + "," + GAISHUUCOLOR.RGB[2] + "," + GAISHUUCOLOR.ALPHA[2] + ")", ctxCR.beginPath(), ctxCR.arc(canvasWidthHalf + e, canvasHeightHalf + o, graphRadius, 0, PI2, !0), ctxCR.stroke(), ctxCR.strokeStyle = "rgba(" + GAISHUUCOLOR.RGB[0] + "," + GAISHUUCOLOR.RGB[1] + "," + GAISHUUCOLOR.RGB[2] + "," + GAISHUUCOLOR.ALPHA[3] + ")", ctxCR.beginPath(), ctxCR.arc(canvasWidthHalf + e, canvasHeightHalf + o, graphRadius - 50, 0, PI2, !0), ctxCR.stroke(), ctxCR.lineWidth = 3;
  for (var n = barChartPar.length - 1; n >= 0; n--) {
    var s = 3.6 * barChartPar[n],
      c = s * RAD;
    ctxCR.strokeStyle = BARCHARTCOLOR[n], ctxCR.beginPath(), ctxCR.arc(canvasWidthHalf + e, canvasHeightHalf + o, barChartRadius[n], 0, c, !1), ctxCR.stroke()
  }
  if (ctxCR.lineWidth = 1, ctxCR.strokeStyle = "rgba(" + PVCOLOR[0] + "," + PVCOLOR[1] + "," + PVCOLOR[2] + ",1)", pvRatioAnimateFlag) {
    ctxCR.save(), ctxCR.translate(i, r);
    for (var n = 0; n < pvRatio.length; n++) {
      var l = pvRatio[n] - 15,
        R = pvRatio[n] + 15;
      l < mouseStatus.deg && R > mouseStatus.deg ? (pvHover = n, ctxCR.fillStyle = "rgba(" + PVCOLOR[0] + "," + PVCOLOR[1] + "," + PVCOLOR[2] + ",0.3)") : ctxCR.fillStyle = "rgba(" + PVCOLOR[0] + "," + PVCOLOR[1] + "," + PVCOLOR[2] + ",0)", ctxCR.beginPath(), ctxCR.rect(pvRatioXY[n][2], pvRatioXY[n][3], 10, 10), ctxCR.stroke(), ctxCR.fill()
    }
    ctxCR.strokeStyle = "rgba(" + PV2COLOR[0] + "," + PV2COLOR[1] + "," + PV2COLOR[2] + "," + PV2COLOR[3] + ")", ctxCR.beginPath();
    for (var n = 0; n < pvRatio.length; n++) ctxCR.lineTo(pvRatioXY[n][0], pvRatioXY[n][1]);
    var u = (graphRadius - 50) * Math.cos(360 * RAD) + canvasWidthHalf,
      h = (graphRadius - 50) * Math.sin(360 * RAD) + canvasHeightHalf;
    ctxCR.lineTo(u, h), ctxCR.stroke(), ctxCR.restore()
  }
  setMemoriOuter(0), ctxCR.strokeStyle = "rgba(" + SOUSHOKUCOLOR.RGB[0] + "," + SOUSHOKUCOLOR.RGB[1] + "," + SOUSHOKUCOLOR.RGB[2] + "," + SOUSHOKUCOLOR.ALPHA[0] + ")", ctxCR.beginPath(), ctxCR.arc(canvasWidthHalf, canvasHeightHalf, MemoriOuterR2, 0, MemoriOuterDegree * RAD, !1), ctxCR.stroke(), setMemoriOuter(0), ctxCR.strokeStyle = "rgba(" + SOUSHOKUCOLOR.RGB[0] + "," + SOUSHOKUCOLOR.RGB[1] + "," + SOUSHOKUCOLOR.RGB[2] + "," + SOUSHOKUCOLOR.ALPHA[1] + ")", ctxCR.beginPath(), ctxCR.arc(canvasWidthHalf, canvasHeightHalf, MemoriOuterR2 + 5, 0, MemoriOuterDegree * RAD, !1), ctxCR.stroke(), ctxCR.beginPath(), ctxCR.lineTo(gaishuuPosition[0], gaishuuPosition[1]), ctxCR.lineTo(gaishuuPosition[2], gaishuuPosition[3]), ctxCR.stroke(), ctxCR.beginPath(), ctxCR.lineTo(gaishuuPosition[4], gaishuuPosition[5]), ctxCR.lineTo(gaishuuPosition[6], gaishuuPosition[7]), ctxCR.stroke(), mouseDegBegin = mouseStatus.deg - 18, mouseDegEnd = mouseStatus.deg + 18, ctxCR.strokeStyle = "rgba(" + MOUSEDEGCOLOR[0] + "," + MOUSEDEGCOLOR[1] + "," + MOUSEDEGCOLOR[2] + ",0.1)", ctxCR.beginPath(), ctxCR.arc(canvasWidthHalf, canvasHeightHalf, MemoriOuterR1 - 1, mouseDegBegin * RAD, mouseDegEnd * RAD, !1), ctxCR.stroke();
  var d = Math.cos(mouseDegBegin * RAD),
    g = Math.sin(mouseDegBegin * RAD),
    v = Math.cos(mouseDegEnd * RAD),
    C = Math.sin(mouseDegEnd * RAD);
  MemoriOuterR4 = graphRadius + 5, MemoriOuterR5 = MemoriOuterR3 - 5, mx1 = MemoriOuterR4 * d + canvasWidthHalf, my1 = MemoriOuterR4 * g + canvasHeightHalf, mx2 = MemoriOuterR5 * d + canvasWidthHalf, my2 = MemoriOuterR5 * g + canvasHeightHalf, mx3 = MemoriOuterR4 * v + canvasWidthHalf, my3 = MemoriOuterR4 * C + canvasHeightHalf, mx4 = MemoriOuterR5 * v + canvasWidthHalf, my4 = MemoriOuterR5 * C + canvasHeightHalf, ctxCR.lineWidth = 1, ctxCR.strokeStyle = "rgba(" + MOUSEDEGCOLOR[0] + "," + MOUSEDEGCOLOR[1] + "," + MOUSEDEGCOLOR[2] + ",0.2)", ctxCR.beginPath(), ctxCR.lineTo(mx3, my3), ctxCR.lineTo(canvasWidthHalf, canvasHeightHalf), ctxCR.stroke(), ctxCR.lineWidth = 2, ctxCR.strokeStyle = "rgba(" + MOUSEDEGCOLOR[0] + "," + MOUSEDEGCOLOR[1] + "," + MOUSEDEGCOLOR[2] + ",1)", ctxCR.beginPath(), ctxCR.lineTo(mx1, my1), ctxCR.lineTo(mx2, my2), ctxCR.stroke(), ctxCR.beginPath(), ctxCR.lineTo(mx3, my3), ctxCR.lineTo(mx4, my4), ctxCR.stroke(), mouseDegHantai = mouseStatus.deg - 180, mx5 = MemoriOuterR3 * Math.cos(mouseDegHantai * RAD) + canvasWidthHalf, my5 = MemoriOuterR3 * Math.sin(mouseDegHantai * RAD) + canvasHeightHalf, mx6 = (MemoriOuterR3 - 7) * Math.cos(mouseDegHantai * RAD) + canvasWidthHalf, my6 = (MemoriOuterR3 - 7) * Math.sin(mouseDegHantai * RAD) + canvasHeightHalf, ctxCR.beginPath(), ctxCR.moveTo(mx5, my5), ctxCR.lineTo(mx6, my6), ctxCR.stroke(), degText = (mouseStatus.deg / 3.6).toFixed(3), ctxCR.fillStyle = "rgba(" + FONTCOLOR[9] + "," + FONTCOLOR[10] + "," + FONTCOLOR[11] + ",1)", ctxCR.font = "9px 'Roboto'", ctxCR.fillText(degText, canvasWidthHalf + graphRadius + 40, canvasHeightHalf), ctxCR.font = "9px 'Roboto'", ctxCR.fillText("10", gaishuuPosition[6] + 15, gaishuuPosition[7] + 10), ctxCR.translate(canvasWidthHalf, canvasHeightHalf), ctxCR.rotate(-90 * Math.PI / 180), ctxCR.translate(-canvasWidthHalf + .5, -canvasHeightHalf + .5), ctxCR.restore(), ctxCR.save()
}

function drawPT() {
  if (ctxCR.save(), ctxCR.translate(.5, .5), ctxCR.lineWidth = 2, ctxCR.strokeStyle = "rgba(" + CENTERCOLOR[0] + "," + CENTERCOLOR[1] + "," + CENTERCOLOR[2] + "," + CENTERCOLOR[3] + ")", ctxCR.beginPath(), ctxCR.moveTo(canvasWidthHalf - 5, canvasHeightHalf), ctxCR.lineTo(canvasWidthHalf + 5, canvasHeightHalf), ctxCR.moveTo(canvasWidthHalf, canvasHeightHalf - 5), ctxCR.lineTo(canvasWidthHalf, canvasHeightHalf + 5), ctxCR.stroke(), ctxCR.restore(), !wHOver) {
    ctxCR.save(), ctxCR.translate(canvasWidthHalf, canvasHeightHalf), ctxCR.rotate(90 * Math.PI / 180), ctxCR.translate(-canvasWidthHalf, -canvasHeightHalf), ctxCR.lineWidth = 1, ctxCR.strokeStyle = "rgba(" + HYOUCOLOR.RGB[0] + "," + HYOUCOLOR.RGB[1] + "," + HYOUCOLOR.RGB[2] + "," + HYOUCOLOR.ALPHA[0] + ")", ctxCR.beginPath(), ctxCR.rect(pointStatus.x, pointStatus.y, pointStatus.w, pointStatus.h), ctxCR.stroke(), ctxCR.strokeStyle = "rgba(" + HYOUCOLOR.RGB[0] + "," + HYOUCOLOR.RGB[1] + "," + HYOUCOLOR.RGB[2] + "," + HYOUCOLOR.ALPHA[1] + ")", ctxCR.beginPath();
    for (var t = pointPosition.length - 1; t >= 0; t--) ctxCR.moveTo(pointPosition[t][0], pointStatus.y), ctxCR.lineTo(pointPosition[t][0], pointPosition[t][3]), 5 > t && (ctxCR.moveTo(pointStatus.x, pointPosition[t][1]), ctxCR.lineTo(pointPosition[t][2], pointPosition[t][1]));
    ctxCR.stroke(), ctxCR.strokeStyle = "rgba(" + HYOUCOLOR.RGB[0] + "," + HYOUCOLOR.RGB[1] + "," + HYOUCOLOR.RGB[2] + "," + HYOUCOLOR.ALPHA[2] + ")", ctxCR.beginPath(), ctxCR.moveTo(pointStatus.x, pointStatus.oy + 6), ctxCR.lineTo(pointStatus.ox, pointStatus.oy + 6), ctxCR.lineTo(pointStatus.ox, pointStatus.oy + 12), ctxCR.stroke(), ctxCR.beginPath(), ctxCR.moveTo(pointStatus.x - 6, pointStatus.oy), ctxCR.lineTo(pointStatus.x - 6, pointStatus.y), ctxCR.lineTo(pointStatus.x - 12, pointStatus.y), ctxCR.stroke();
    var a = pointStatus.x + mouseStatus.px * (pointStatus.w / 100) - 3,
      e = pointStatus.y + mouseStatus.py * (pointStatus.h / 100) - 3;
    ctxCR.strokeStyle = "rgba(" + HYOUCOLOR.RGB[0] + "," + HYOUCOLOR.RGB[1] + "," + HYOUCOLOR.RGB[2] + "," + HYOUCOLOR.ALPHA[3] + ")", ctxCR.beginPath(), ctxCR.rect(a, pointStatus.oy + 3, 6, 6), ctxCR.stroke(), ctxCR.beginPath(), ctxCR.rect(pointStatus.x - 9, e, 6, 6), ctxCR.stroke(), ctxCR.strokeStyle = "rgba(" + HYOUCOLOR.RGB[0] + "," + HYOUCOLOR.RGB[1] + "," + HYOUCOLOR.RGB[2] + "," + HYOUCOLOR.ALPHA[5] + ")", ctxCR.beginPath(), ctxCR.moveTo(a + 3, pointStatus.oy + 6), ctxCR.lineTo(a + 3, e + 3), ctxCR.stroke(), ctxCR.beginPath(), ctxCR.moveTo(pointStatus.x - 6, e + 3), ctxCR.lineTo(a + 3, e + 3), ctxCR.stroke(), ctxCR.fillStyle = "rgba(" + HYOUCOLOR.RGB[0] + "," + HYOUCOLOR.RGB[1] + "," + HYOUCOLOR.RGB[2] + "," + HYOUCOLOR.ALPHA[4] + ")", ctxCR.beginPath(), ctxCR.arc(a + 3, e + 3, 1, 0, 360 * RAD, !0), ctxCR.fill(), ctxCR.fillStyle = "rgba(" + FONTCOLOR[0] + "," + FONTCOLOR[1] + "," + FONTCOLOR[2] + ",1)", ctxCR.font = "9px 'Roboto'", ctxCR.textAlign = "end", ctxCR.textBaseline = "top", ctxCR.fillText(windowWidth, textPosition[0], textPosition[1]), ctxCR.fillText(windowHeight, textPosition[2], textPosition[3]), ctxCR.fillStyle = "rgba(" + FONTCOLOR[3] + "," + FONTCOLOR[4] + "," + FONTCOLOR[5] + ",1)", ctxCR.fillText("X", textPosition[8], textPosition[5]), ctxCR.fillText("Y", textPosition[8], textPosition[7]), ctxCR.fillStyle = "rgba(" + FONTCOLOR[6] + "," + FONTCOLOR[7] + "," + FONTCOLOR[8] + ",1)", ctxCR.fillText(mouseStatus.x.toFixed(3), textPosition[4], textPosition[5]), ctxCR.fillText(mouseStatus.y.toFixed(3), textPosition[6], textPosition[7]), ctxCR.restore()
  }
}

function render2D() {
  if (spFlag || (drawCR(), drawPT(), wHOver || drawLN()), drawUA(), webAudio && !spFlag && (drawAV(), drawWave()), render2DInt = window.requestAnimationFrame(render2D), ajax) {
    ajax = !1, $day.text(animatePv.day[pvHover]);
    var t = animatePv.circle[pvHover];
    TweenLite.to(barChartPar, 1, t);
    var a = animatePv.line;
    TweenLite.to(pvRatio, 0, a), setTimeout(function() {
      if (ajax = !0, onetime && ($("html").addClass("go"), onetime = !1, !spFlag)) {
        TweenLite.to(prevUARatio[0], 0, dvRatio), TweenLite.to(prevUARatio[1], 0, osRatio), TweenLite.to(prevUARatio[2], 0, browsRatio);
        var t = animatePv.line;
        TweenLite.to(pvRatio, 1, t)
      }
      var a = animatePv.view[pvHover];
      TweenLite.to(animatePvFrom, 1, a), a.onUpdate = function() {
        $v1.text(Math.floor(animatePvFrom[0])), $v2.text(Math.floor(animatePvFrom[1])), $v3.text(Math.floor(animatePvFrom[2])), $v4.text(Math.floor(animatePvFrom[3])), $v5.text(Math.floor(animatePvFrom[4])), $v6.text(Math.floor(animatePvFrom[5])), $total.text(Math.floor(animatePvFrom[6]))
      }
    }, 1e3)
  }
}

function setSize3D() {
  scene = new THREE.Scene, camera = new THREE.PerspectiveCamera(60, canvasWidth3D / canvasHeight3D, .1, 1e5), camera.position.z = 2e3 - cameraOffet, scene.add(camera), renderer = new THREE.WebGLRenderer({
    canvas: $(".background")[0],
    alpha: !0,
    antialias: !0
  }), renderer.shadowMapEnabled = !1, renderer.setSize(canvasWidth3D, canvasHeight3D), init3D(), render3D(), updateSize3D()
}

function updateSize3D() {
  $(".background").css({
    width: canvasWidth3D / ratio,
    height: canvasHeight3D / ratio
  })
}

function init3D() {
  scene.fog = new THREE.FogExp2(0, .0013);
  var t = new THREE.MeshPhongMaterial({
    color: new THREE.Color("rgb(67,116,217)"),
    emissive: new THREE.Color("rgb(3,7,15)"),
    specular: new THREE.Color("rgb(140,140,140)"),
    shininess: 10,
    shading: THREE.FlatShading,
    fog: !0,
    transparent: 1,
    opacity: 0
  });
  Ico = new THREE.Mesh(new THREE.IcosahedronGeometry(330, 2), t), Ico.position.x = 0, Ico.position.z = 2e3, Ico.rotation.x = 0, Ico.rotation.z = .5, scene.add(Ico), IsoBasic = new THREE.IcosahedronGeometry(330, 4);
  var a = [new THREE.MeshBasicMaterial({
    opacity: 0,
    wireframe: !1,
    fog: !1,
    transparent: !0
  })];
  group = THREE.SceneUtils.createMultiMaterialObject(IsoBasic, a), group.position.x = 0, group.position.z = 0, group.rotation.x = 0, scene.add(group);
  for (var e = new THREE.Geometry, o = 0; o < IsoBasic.vertices.length; o++) {
    var i = new THREE.Vector3;
    i.x = IsoBasic.vertices[o].x, i.y = IsoBasic.vertices[o].y, i.z = IsoBasic.vertices[o].z, e.vertices.push(i)
  }
  var r = new THREE.PointCloudMaterial({
    color: 8641491,
    size: 2,
    blending: THREE.AdditiveBlending,
    transparent: !0,
    fog: !0
  });
  particleSystem = new THREE.PointCloud(e, r), particleSystem.position = new THREE.Vector3(0, 0, -200), particleSystem.sortParticles = !1, scene.add(particleSystem), setFlower();
  for (var n = new THREE.BufferGeometry, s = new THREE.LineBasicMaterial({
      fog: !1,
      opacity: 0,
      transparent: !0,
      vertexColors: THREE.VertexColors
    }), c = new Float32Array(3 * particlesNum), l = new Float32Array(3 * particlesNum), o = 0; particlesNum > o; o++) {
    var R = colRatio[o].r / 255,
      u = colRatio[o].g / 255,
      h = colRatio[o].b / 255;
    if (o % 2) var d = linePos[o].x2,
      g = linePos[o].y2,
      v = 0;
    else var d = linePos[o].x1,
      g = linePos[o].y1,
      v = 0;
    c[3 * o] = d, c[3 * o + 1] = g, c[3 * o + 2] = v, l[3 * o] = R, l[3 * o + 1] = u, l[3 * o + 2] = h
  }
  n.addAttribute("position", new THREE.BufferAttribute(c, 3)), n.addAttribute("color", new THREE.BufferAttribute(l, 3)), n.computeBoundingSphere(), Flower = new THREE.Line(n, s), scene.add(Flower), Flower.position.x = 0, Flower.position.y = 0, Flower.position.z = 4e3;
  for (var C = 0; starNum > C; C++)
    for (var o = 0; o < degs.length; o++) {
      var O = degs[o] + 3 * C,
        p = Math.PI * O / 180,
        m = 980 + (maxdis - dis * C),
        d = Math.cos(p) * m,
        g = Math.sin(p) * m,
        v = dis * C;
      updatePositions.push(d), updatePositions.push(g), updatePositions.push(v), vertexPositions.push([d, g, v])
    }
  LineGeometry = new THREE.BufferGeometry;
  for (var s = new THREE.LineBasicMaterial({
      fog: !1,
      opacity: 0,
      transparent: !0,
      vertexColors: THREE.VertexColors
    }), A = new Float32Array(3 * vertexPositions.length), l = new Float32Array(3 * vertexPositions.length), f = 1600, o = 0; o < vertexPositions.length; o++) A[3 * o + 0] = vertexPositions[o][0], A[3 * o + 1] = vertexPositions[o][1], A[3 * o + 2] = vertexPositions[o][2], l[3 * o] = vertexPositions[o][0] / f + .5, l[3 * o + 1] = vertexPositions[o][1] / f + .5, l[3 * o + 2] = vertexPositions[o][2] / f + .5;
  LineGeometry.addAttribute("position", new THREE.BufferAttribute(A, 3)), LineGeometry.addAttribute("color", new THREE.BufferAttribute(l, 3)), LineGeometry.computeBoundingSphere(), Star = new THREE.Line(LineGeometry, s, THREE.LinePieces), scene.add(Star), LineNum = LineGeometry.attributes.position.array.length, Star.position.z = 8e3, pointLight = new THREE.PointLight(16777215, .4), pointLight.position.z = camera.position.z + 100, pointLight.position.y = 0, pointLight.position.x = 0, scene.add(pointLight), threeFlag = !0
}

function render3D() {
  render3DInt = window.requestAnimationFrame(render3D), Ico.rotation.x += cx, Ico.rotation.y += cy, particleSystem.rotation.x += cx, particleSystem.rotation.y += cy, Star.rotation.z += .002, Flower.rotation.z -= .002, camera.lookAt({
    x: 0,
    y: 0,
    z: camera.position.z + 1e3
  }), renderer.render(scene, camera)
}

function setFlower() {
  flowerRGB = [80, 10, 10], flowerRGP = flowerRGB[0] + flowerRGB[1] + flowerRGB[2], flowerRRatio = flowerRGB[0] / flowerRGP * 100, flowerGRatio = flowerRGB[1] / flowerRGP * 100, flowerPRatio = flowerRGB[2] / flowerRGP * 100, flowerOver1 = Math.floor(particlesNum / 100 * flowerRRatio), flowerOver2 = Math.floor(particlesNum / 100 * flowerGRatio) + flowerOver1, colRatio = [];
  for (var t = particlesNum; t >= 0; t--) {
    var a = t + 5 * Math.random(),
      e = (t + 5 * Math.random(), flowerRadius * Math.sin(a * RAD) * Math.cos(a * RAD)),
      o = flowerRadius * Math.sin(a * RAD) * Math.sin(a * RAD) - flowerRadius / 2,
      i = flowerRadius * Math.cos(a * RAD),
      r = flowerRadius / 2 * Math.sin(a * RAD) * Math.cos(a * RAD),
      n = flowerRadius / 2 * Math.sin(a * RAD) * Math.sin(a * RAD) - flowerRadius / 4,
      s = flowerRadius / 2 * Math.cos(a * RAD);
    linePos.push({
      x1: e,
      y1: o,
      z1: i,
      x2: r,
      y2: n,
      z2: s
    }), colRatio.push(t < flowerOver1 ? t % 2 ? {
      r: 224,
      g: 58,
      b: 67
    } : {
      r: 120,
      g: 31,
      b: 36
    } : t < flowerOver2 ? {
      r: 23,
      g: 152,
      b: 136
    } : {
      r: 141,
      g: 25,
      b: 233
    })
  }
  colRatio.sort(function() {
    return Math.random() - .5
  })
}

function initUA() {
  uamouse = 100, uaRadius = 27, prevUARatio = [
    [0, 0, 0, 0],
    [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0]
  ], uaIDARR = [
    [0, 1, 2, -1],
    [3, 4, 5, 6, -1],
    [7, 8, 9, 10, -1]
  ], uaWidth = $(".rightContent").width(), uaHeight = 100, canvasUA = $(".uaVisual")[0], ctxUA = canvasUA.getContext("2d"), canvasUA.width = uaWidth, canvasUA.height = uaHeight, $(".uaVisual").css({
    width: uaWidth,
    height: uaHeight
  })
}

function drawUA() {
  if (!spFlag) {
    ctxUA.clearRect(0, 0, uaWidth, uaHeight), ctxUA.strokeStyle = "rgba(223,245,255,0.5)";
    for (var t = 0; t < prevUARatio.length; t++)
      for (var a = uaWidth / 6 + uaWidth / prevUARatio.length * t, e = 50, o = prevUARatio[t].length - 2; o >= 0; o--) {
        var i = prevUARatio[t][o] * RAD,
          r = prevUARatio[t][o + 1] * RAD,
          n = uaIDARR[t][o];
        n === uamouse ? ctxUA.strokeStyle = "rgba(223,245,255,0.5)" : ctxUA.strokeStyle = "rgba(223,245,255,0.1)", ctxUA.beginPath(), ctxUA.arc(a, e, uaRadius + 6, i, r, !1), ctxUA.stroke();
        var s = o * UACOLOR[3];
        ctxUA.fillStyle = "rgba(" + UACOLOR[0] + "," + UACOLOR[1] + "," + UACOLOR[2] + "," + s + ")", ctxUA.beginPath(), ctxUA.arc(a, e, uaRadius, i, r, !0), ctxUA.lineTo(a, e), ctxUA.closePath(), ctxUA.fill()
      }
  }
}

function checkTheme() {
  "BASIC" === colorType ? (BTNCOLOR = ["rgba(223,245,255, 0.5)", "rgba(223,245,255, 0)"], BARCHARTCOLOR = ["rgba(235,39,85,1)", "rgba(109,126,132,1)", "rgba(223,245,255,1)", "rgba(223,245,255,1)", "rgba(223,245,255,1)"], CENTERCOLOR = [168, 215, 215, 1], MOUSEDEGCOLOR = [223, 245, 255], PVCOLOR = [168, 215, 215], PV2COLOR = [223, 245, 255, .1], LNCOLOR = {
    RGB: [109, 126, 132],
    ALPHA: [1, 1, .3, .3, .3, 1, 1, .2]
  }, SOUSHOKUCOLOR = {
    RGB: [223, 245, 255],
    ALPHA: [.2, .2]
  }, BXCOLOR = {
    RGB: [109, 126, 132],
    ALPHA: [1, .3]
  }, MEMORICOLOR = {
    RGB: [109, 126, 132],
    ALPHA: [1, .3]
  }, GAISHUUCOLOR = {
    RGB: [223, 245, 255],
    ALPHA: [.3, .1, .1, .2]
  }, HYOUCOLOR = {
    RGB: [223, 245, 255],
    ALPHA: [.3, .1, .2, .6, 1, .6]
  }, FONTCOLOR = [223, 245, 255, 223, 245, 255, 37, 45, 48, 223, 245, 255], UACOLOR = [223, 245, 255, .2], AVCOLOR = {
    RGB: [223, 245, 255],
    ALPHA: [.1, .4, 1, .4]
  }, aboutGraphCol = [
    [223, 245, 255],
    [49, 163, 192],
    [240, 40, 87],
    [71, 100, 114]
  ]) : "MONO" === colorType ? (BTNCOLOR = ["rgba(255,255,255,0.5)", "rgba(255,255,255,0)"], BARCHARTCOLOR = ["rgba(255,255,255,1)", "rgba(255,255,255,1)", "rgba(255,255,255,1)", "rgba(255,255,255,1)", "rgba(255,255,255,1)"], CENTERCOLOR = [255, 255, 255, 1], MOUSEDEGCOLOR = [223, 245, 255], PVCOLOR = [255, 255, 255], PV2COLOR = [255, 255, 255, .1], LNCOLOR = {
    RGB: [255, 255, 255],
    ALPHA: [.2, .2, .2, .2, .2, .2, .2, .2]
  }, SOUSHOKUCOLOR = {
    RGB: [255, 255, 255],
    ALPHA: [.2, .2]
  }, BXCOLOR = {
    RGB: [255, 255, 255],
    ALPHA: [.1, .1]
  }, MEMORICOLOR = {
    RGB: [255, 255, 255],
    ALPHA: [.3, .3]
  }, GAISHUUCOLOR = {
    RGB: [255, 255, 255],
    ALPHA: [.3, .1, .1, .2]
  }, HYOUCOLOR = {
    RGB: [255, 255, 255],
    ALPHA: [.3, .1, .2, .6, 1, .6]
  }, FONTCOLOR = [38, 41, 48, 255, 255, 255, 38, 41, 48, 38, 41, 48], UACOLOR = [255, 255, 255, .05], AVCOLOR = {
    RGB: [255, 255, 255],
    ALPHA: [.1, .4, 1, .4]
  }, aboutGraphCol = [
    [255, 255, 255],
    [190, 190, 190],
    [120, 120, 120],
    [90, 90, 90]
  ]) : "COLORFUL" === colorType ? (BTNCOLOR = ["rgba(224,58,67,0.5)", "rgba(224,58,67,0)"], BARCHARTCOLOR = ["rgba(224,58,67,1)", "rgba(224,58,67,1)", "rgba(224,58,67,1)", "rgba(224,58,67,1)", "rgba(224,58,67,1)"], CENTERCOLOR = [26, 168, 151, 1], MOUSEDEGCOLOR = [100, 62, 240], PVCOLOR = [26, 168, 151, 1], PV2COLOR = [223, 245, 255, .1], LNCOLOR = {
    RGB: [109, 126, 132],
    ALPHA: [.2, .2, .6, .6, .2, .6, .6, .2]
  }, SOUSHOKUCOLOR = {
    RGB: [223, 245, 255],
    ALPHA: [0, 0]
  }, BXCOLOR = {
    RGB: [109, 126, 132],
    ALPHA: [.2, .2]
  }, MEMORICOLOR = {
    RGB: [109, 126, 132],
    ALPHA: [.2, .2]
  }, GAISHUUCOLOR = {
    RGB: [223, 245, 255],
    ALPHA: [.1, .1, .1, .1]
  }, HYOUCOLOR = {
    RGB: [26, 168, 151],
    ALPHA: [.2, .1, 0, 1, 1, .2]
  }, FONTCOLOR = [37, 45, 48, 26, 168, 151, 37, 45, 48, 239, 62, 72], UACOLOR = [239, 62, 72, .2], AVCOLOR = {
    RGB: [26, 168, 151],
    ALPHA: [1, .4, 1, .4]
  }, aboutGraphCol = [
    [224, 58, 67],
    [26, 168, 151],
    [141, 25, 233],
    [52, 64, 69]
  ]) : "STAR" === colorType && (BTNCOLOR = ["rgba(54,207,194,0.5)", "rgba(54,207,194,0)"], BARCHARTCOLOR = ["rgba(119,21,196,1)", "rgba(119,21,196,1)", "rgba(119,21,196,1)", "rgba(119,21,196,1)", "rgba(119,21,196,1)"], CENTERCOLOR = [26, 168, 151, 1], MOUSEDEGCOLOR = [100, 62, 240], PVCOLOR = [26, 168, 151, 1], PV2COLOR = [100, 62, 240, .1], LNCOLOR = {
    RGB: [26, 168, 151],
    ALPHA: [.1, .1, .1, .1, .1, .1, .1, .1]
  }, SOUSHOKUCOLOR = {
    RGB: [223, 245, 255],
    ALPHA: [0, 0]
  }, BXCOLOR = {
    RGB: [26, 168, 151],
    ALPHA: [.1, 1]
  }, MEMORICOLOR = {
    RGB: [26, 168, 151],
    ALPHA: [0, .2]
  }, GAISHUUCOLOR = {
    RGB: [223, 245, 255],
    ALPHA: [0, 0, 0, 0]
  }, HYOUCOLOR = {
    RGB: [26, 168, 151],
    ALPHA: [.2, .1, 0, 1, 1, .2]
  }, FONTCOLOR = [37, 45, 48, 26, 168, 151, 37, 45, 48, 26, 168, 151], UACOLOR = [26, 168, 151, .2], AVCOLOR = {
    RGB: [26, 168, 151],
    ALPHA: [1, .4, 1, .4]
  }, aboutGraphCol = [
    [100, 62, 240],
    [26, 168, 151],
    [141, 25, 233],
    [52, 64, 69]
  ])
}

function changeTheme() {
  "BASIC" === colorType ? ($html.removeClass("basic colorful star mono"), $html.addClass("basic"), $.cookie("color", "a", {
    expires: 90
  })) : "MONO" === colorType ? ($html.removeClass("basic colorful star mono"), $html.addClass("mono"), $.removeCookie("color")) : "COLORFUL" === colorType ? ($html.removeClass("basic colorful star mono"), $html.addClass("colorful"), $.cookie("color", "b", {
    expires: 90
  })) : "STAR" === colorType ? ($html.removeClass("basic colorful star mono"), $html.addClass("star"), $.cookie("color", "c", {
    expires: 90
  })) : $.removeCookie("color")
}

function change3D() {
  var t = 2;
  subpageFlag || spFlag || !webGL || ("BASIC" === colorType ? (MODELZ = 0 - cameraOffet, query = URL + "?sc=a", TweenLite.to(particleSystem.material, t, {
    opacity: 1,
    ease: easeing
  }), TweenLite.to(Ico.material, t, {
    opacity: 0,
    ease: easeing
  }), TweenLite.to(Flower.material, t, {
    opacity: 0,
    ease: easeing
  }), TweenLite.to(Star.material, t, {
    opacity: 0,
    ease: easeing
  })) : "MONO" === colorType ? (MODELZ = 2e3 - cameraOffet, query = URL, TweenLite.to(particleSystem.material, t, {
    opacity: 0,
    ease: easeing
  }), TweenLite.to(Ico.material, t, {
    opacity: 1,
    ease: easeing
  }), TweenLite.to(Flower.material, t, {
    opacity: 0,
    ease: easeing
  }), TweenLite.to(Star.material, t, {
    opacity: 0,
    ease: easeing
  })) : "COLORFUL" === colorType ? (MODELZ = 4e3 - cameraOffet, query = URL + "?sc=b", TweenLite.to(particleSystem.material, t, {
    opacity: 0,
    ease: easeing
  }), TweenLite.to(Ico.material, t, {
    opacity: 0,
    ease: easeing
  }), TweenLite.to(Flower.material, t, {
    opacity: 1,
    ease: easeing
  }), TweenLite.to(Star.material, t, {
    opacity: 0,
    ease: easeing
  })) : "STAR" === colorType ? (MODELZ = 6e3 - cameraOffet, query = URL + "?sc=c", TweenLite.to(particleSystem.material, t, {
    opacity: 0,
    ease: easeing
  }), TweenLite.to(Ico.material, t, {
    opacity: 0,
    ease: easeing
  }), TweenLite.to(Flower.material, t, {
    opacity: 0,
    ease: easeing
  }), TweenLite.to(Star.material, t, {
    opacity: 1,
    ease: easeing
  })) : query = URL, window.history.pushState(null, null, query), TweenLite.to(camera.position, t, {
    z: MODELZ,
    ease: easeing
  }), TweenLite.to(pointLight.position, t, {
    z: MODELZ,
    ease: easeing
  }))
}

function loadedAnimate() {
  $progress_bar.css({
    width: "100%"
  }), $progress_num.text(100), $all.addClass("hideprogress"), spFlag && $html.addClass("sploaded"), setTimeout(function() {
    $all.addClass("showborder hideprogress hideexpand showsidebar"), setTimeout(function() {
      $all.addClass("hideborder")
    }, 600), setTimeout(function() {
      $(".hidechild").children().css({
        "transition-delay": "0s"
      }), $(".hide").css({
        "transition-delay": "0s"
      }), $(".hide").removeClass("hide"), $(".hidechild").removeClass("hidechild"), $(".btn").each(function(t, a) {
        for (var e = $(this), o = e.find(".name").text().length, i = e.find(".light").children(), r = 0; o > r; r++) i.eq(r).addClass("o").css({
          "transition-delay": r / 50 + "s"
        })
      })
    }, 1100), setTimeout(function() {
      $all.addClass("showgraphic"), richFlag ? !spFlag && webAudio && ($.cookie("audio") ? ($html.addClass("pause"), canPlayFlag = !1) : (bgm.play(), canPlayFlag = !0)) : !spFlag && webAudio && ($html.addClass("pause"), canPlayFlag = !1)
    }, 1800)
  }, 1e3)
}

function countActive() {
  $(".avtive").text(activeUser), TweenMax.to($(".activeload svg"), 1.5, {
    rotation: 360,
    ease: Power4.easeOut,
    repeat: 2
  }), $(".avtiveIcon .icon").removeClass("on"), $(".avtiveIcon .icon").each(function(t, a) {
    if (t <= activeUser - 1) {
      var e = $(this);
      e.addClass("on")
    }
  })
}

function initSubpage() {
  appArr = [], devArr = [], idArr = [], mangaArr = [], marioArr = [], eyeArr = [
    [0],
    [0]
  ], postArr = [
    [0],
    [0]
  ], drowAboutFlag = !1, aboutOffset = 0, spFlag || $(".scroll").mCustomScrollbar({
    axis: "y",
    scrollInertia: 100,
    callbacks: {
      whileScrolling: function() {
        if (aboutFlag && drowAboutFlag) {
          var t = Math.abs(this.mcs.top);
          if (t > aboutOffsetTop) {
            var a = postArr[1],
              e = postArr[0];
            TweenLite.to(a, .8, e);
            var o = eyeArr[1],
              i = eyeArr[0];
            TweenLite.to(o, .8, i), i.onComplete = function() {
              drowAboutFlag = !1, window.cancelAnimationFrame(renderAboutInt)
            }, $(".aboutbar").removeClass("on")
          }
        }
      }
    }
  }), aboutWidth = 290, aboutHeight = 290, aboutWidthHalf = aboutWidth / 2, aboutHeightHalf = aboutHeight / 2, aboutFlag && !spFlag && (setAbout(), renderABOUT(), loadAbout())
}

function setAbout() {
  canvasAB1 = $(".aboutCircleGraph_1")[0], ctxAB1 = canvasAB1.getContext("2d"), canvasAB2 = $(".aboutCircleGraph_2")[0], ctxAB2 = canvasAB2.getContext("2d"), canvasAB3 = $(".aboutCircleGraph_3")[0], ctxAB3 = canvasAB3.getContext("2d"), $aboutGraphCV.attr({
    width: aboutWidth,
    height: aboutHeight
  }), aboutbg = [], aboutbgRadius = aboutWidthHalf - 20;

  for (var t = 360; t > 0; t -= 3) {
    var a = aboutbgRadius * Math.cos(t * RAD) + aboutWidthHalf,
      e = aboutbgRadius * Math.sin(t * RAD) + aboutWidthHalf,
      o = (aboutbgRadius - 5) * Math.cos(t * RAD) + aboutWidthHalf,
      i = (aboutbgRadius - 5) * Math.sin(t * RAD) + aboutWidthHalf;
    aboutbg.push([a, e, o, i])
  }
}

function loadAbout() {
  $.ajax({
    type: "GET",
    url: "http://www.newstech.jp/ga/files/member.json",
    dataType: "json",
    success: function(t) {
      objEYE = t.RATIO[0].EYE[0], objPOST = t.RATIO[0].POST[0], mamberNum = t.TOTAL, eyeCat = Object.keys(objEYE), postCat = Object.keys(objPOST);
      for (var a = 1; a < eyeCat.length; a++) {
        var e = eyeArr[0][a - 1],
          o = Math.floor(objEYE[eyeCat[a]] / mamberNum * 360);
        eyeArr[0].push(o + e), eyeArr[1].push(0)
      }
      eyeArr[0].push(360), eyeArr[1].push(0);
      for (var a = 1; a < postCat.length; a++) {
        var e = postArr[0][a - 1],
          o = Math.floor(objPOST[postCat[a]] / mamberNum * 360);
        postArr[0].push(o + e), postArr[1].push(0)
      }
      postArr[0].push(360), postArr[1].push(0), pi = 1;
      for (var a = 1; a < postCat.length; a++) {
        var i = '<li><div class="col"><span class="c' + a % 4 + '"></span></div><div class="name">' + postCat[a] + '</div><div class="num">' + objPOST[postCat[a]] + "</div></li>";
        $addpost.append(i), pi++
      }
      var i = '<li><div class="col"><span class="c' + pi % 4 + '"></span></div><div class="name">' + postCat[0] + '</div><div class="num">' + objPOST[postCat[0]] + "</div></li>";
      $addpost.append(i), ei = 1;
      for (var a = 1; a < eyeCat.length; a++) {
        var i = '<li><div class="col"><span class="c' + a % 4 + '"></span></div><div class="name">' + eyeCat[a] + '</div><div class="num">' + objEYE[eyeCat[a]] + "</div></li>";
        $addeye.append(i), ei++
      }
      var i = '<li><div class="col"><span class="c' + ei % 4 + '"></span></div><div class="name">' + eyeCat[0] + '</div><div class="num">' + objEYE[eyeCat[0]] + "</div></li>";
      $addeye.append(i);
      for (var a = 0; a < t.DETA.length; a++) appArr.push(t.DETA[a].APP), devArr.push(t.DETA[a].DEVICE), idArr.push(t.DETA[a].ID), mangaArr.push(t.DETA[a].MANGA), marioArr.push(t.DETA[a].MARIO);
      appMax = Math.max.apply(null, appArr), devMax = Math.max.apply(null, devArr), mangaMax = Math.max.apply(null, mangaArr), marioMax = Math.max.apply(null, marioArr), marioMin = Math.min.apply(null, marioArr), $(".score1").text(marioMin), $(".score2").text(devMax), $(".score3").text(appMax), $(".score4").text(mangaMax);
      for (var r = 1, a = 0; a < appArr.length; a++) {
        var n = idArr[a],
          s = appArr[a] / appMax * 100,
          c = devArr[a] / devMax * 100,
          l = mangaArr[a] / mangaMax * 100,
          R = marioArr[a] / marioMax * 100,
          i = '<div class="row"><div class="cell">' + n + '</div><div class="cell"><div class="aboutbar on"><span class="c1" style="transition-delay:' + r / 8 + "s; width:" + R + '%;"></span><span class="c2" style="transition-delay:' + (r + 1) / 8 + "s; width:" + c + '%;"></span><span class="c3" style="transition-delay:' + (r + 2) / 8 + "s; width:" + s + '%;"></span><span class="c4" style="transition-delay:' + (r + 3) / 8 + "s; width:" + l + '%;"></span></div></div></div>';
        $addmember.append(i), r++
      }
      drowAboutFlag = !0
    }
  })
}

function drawAbout() {
  if (drowAboutFlag) {
    ctxAB1.clearRect(0, 0, 600, 600), ctxAB2.clearRect(0, 0, 600, 600), ctxAB3.clearRect(0, 0, 600, 600), ctxAB1.save(), ctxAB1.translate(aboutWidthHalf, aboutWidthHalf), ctxAB1.rotate(-90 * Math.PI / 180), ctxAB1.translate(-aboutWidthHalf, -aboutWidthHalf), ctxAB1.lineWidth = 20;
    for (var t = 1; t < postArr[1].length; t++) {
      var a = aboutWidthHalf - 60,
        e = aboutGraphCol[(t - 1) % aboutGraphCol.length][0],
        o = aboutGraphCol[(t - 1) % aboutGraphCol.length][1],
        i = aboutGraphCol[(t - 1) % aboutGraphCol.length][2],
        r = postArr[1][t - 1] * RAD,
        n = postArr[1][t] * RAD;
      ctxAB1.strokeStyle = "rgba(" + e + "," + o + "," + i + ",1)", ctxAB1.beginPath(), ctxAB1.arc(aboutWidthHalf, aboutWidthHalf, a, r, n, !1), ctxAB1.stroke()
    }
    ctxAB1.lineWidth = 1, ctxAB1.strokeStyle = "rgba(" + aboutGraphCol[0][0] + "," + aboutGraphCol[0][1] + "," + aboutGraphCol[0][2] + ",0.5)", ctxAB1.beginPath();
    for (var t = aboutbg.length - 1; t >= 0; t--) ctxAB1.moveTo(aboutbg[t][0], aboutbg[t][1]), ctxAB1.lineTo(aboutbg[t][2], aboutbg[t][3]);
    ctxAB1.stroke(), ctxAB1.beginPath(), ctxAB1.arc(aboutWidthHalf, aboutWidthHalf, aboutbgRadius, 0 * RAD, 360 * RAD, !1), ctxAB1.stroke(), ctxAB1.restore(), ctxAB2.save(), ctxAB2.translate(aboutWidthHalf, aboutWidthHalf), ctxAB2.rotate(-90 * Math.PI / 180), ctxAB2.translate(-aboutWidthHalf, -aboutWidthHalf), ctxAB2.lineWidth = 20;
    for (var t = 1; t < eyeArr[1].length; t++) {
      var a = aboutWidthHalf - 60,
        e = aboutGraphCol[(t - 1) % aboutGraphCol.length][0],
        o = aboutGraphCol[(t - 1) % aboutGraphCol.length][1],
        i = aboutGraphCol[(t - 1) % aboutGraphCol.length][2],
        r = eyeArr[1][t - 1] * RAD,
        n = eyeArr[1][t] * RAD;
      ctxAB2.strokeStyle = "rgba(" + e + "," + o + "," + i + ",1)", ctxAB2.beginPath(), ctxAB2.arc(aboutWidthHalf, aboutWidthHalf, a, r, n, !1), ctxAB2.stroke()
    }
    ctxAB2.lineWidth = 1, ctxAB2.strokeStyle = "rgba(" + aboutGraphCol[0][0] + "," + aboutGraphCol[0][1] + "," + aboutGraphCol[0][2] + ",0.5)", ctxAB2.beginPath();
    for (var t = aboutbg.length - 1; t >= 0; t--) ctxAB2.moveTo(aboutbg[t][0], aboutbg[t][1]), ctxAB2.lineTo(aboutbg[t][2], aboutbg[t][3]);
    ctxAB2.stroke(), ctxAB2.beginPath(), ctxAB2.arc(aboutWidthHalf, aboutWidthHalf, aboutbgRadius, 0 * RAD, 360 * RAD, !1), ctxAB2.stroke(), ctxAB2.restore(), ctxAB3.save(), ctxAB3.translate(aboutWidthHalf, aboutWidthHalf), ctxAB3.rotate(-90 * Math.PI / 180), ctxAB3.translate(-aboutWidthHalf, -aboutWidthHalf), ctxAB3.lineWidth = 1, ctxAB3.strokeStyle = "rgba(" + aboutGraphCol[0][0] + "," + aboutGraphCol[0][1] + "," + aboutGraphCol[0][2] + ",0.5)", ctxAB3.beginPath();
    for (var t = aboutbg.length - 1; t >= 0; t--) ctxAB3.moveTo(aboutbg[t][0], aboutbg[t][1]), ctxAB3.lineTo(aboutbg[t][2], aboutbg[t][3]);
    ctxAB3.stroke(), ctxAB3.beginPath(), ctxAB3.arc(aboutWidthHalf, aboutWidthHalf, aboutbgRadius, 0 * RAD, 360 * RAD, !1), ctxAB3.stroke(), ctxAB3.restore()
  }
}

function renderABOUT() {
  drawAbout(), renderAboutInt = window.requestAnimationFrame(renderABOUT)
}
var audioInt, bgmNow = 0,
  bgmDUR = 0,
  bgmPAR = 0,
  MemoriFlag = !1;
$(function() {
  if (webAudio && !spFlag) {
    bgm = document.getElementById("bgm"), audioCtx = new(window.AudioContext || window.webkitAudioContext);
    var t = audioCtx.createMediaElementSource(bgm);
    analyser = audioCtx.createAnalyser(), t.connect(analyser), analyser.connect(audioCtx.destination), spFlag && (canPlayFlag = !1), $audioNow = $(".audioStatus").children(".now"), $audioMax = $(".audioStatus").children(".max"), bgm.addEventListener("timeupdate", function() {
      bgmDUR = Math.round(bgm.duration), bgmNow = Math.round(bgm.currentTime), bgmPAR = bgmNow / bgmDUR * 100, $audioNow.text(bgmNow), $audioMax.text(bgmDUR)
    }, !0), bufferLength = analyser.frequencyBinCount, bufferCircle = bufferLength / 360, audioArray = new Uint8Array(bufferLength), bufferAVLength = 70, bufferAVmax = 4 * bufferAVLength + 10.5, bufferAV = bufferLength / bufferAVLength, setVisual(), subpageFlag && renderAV()
  }
}), $(document).on("click", ".audioVisualWrap", function(t) {
  t.preventDefault(), canPlayFlag ? (bgm.pause(), canPlayFlag = !1, $html.addClass("pause"), $.cookie("audio", "0", {
    expires: 90
  })) : (bgm.play(), canPlayFlag = !0, $html.removeClass("pause"), $.removeCookie("audio"))
});
var renderAudioInt, lineObject = [
    [1, 310, 242, 310, 292, 260, 292],
    [1, -310, 242, -310, 292, -260, 292],
    [.3, 329, 305, 329, 311, 181, 311, 181, 305],
    [.3, 270, 305, 270, 311],
    [.3, 330, 316, 180, 316],
    [1, 180, -352, 180, -358, 330, -358, 330, -352, -330, -352],
    [1, 270, -352, 270, -358],
    [.2, 330, -364, 180, -364]
  ],
  B1 = [330, 330],
  B2 = [330, -413],
  B3 = [109, -413],
  jiten = 0;
$(function() {
  subpageFlag || (loadPageview(), setSize2D(), spFlag || initUA(), render2D())
}), $(window).on("load", function() {
  subpageFlag || spFlag || !webGL || setSize3D()
});
for (var threeFlag = !1, scene, camera, renderer, particlesNum = 300, scene, camera, renderer, cameraOffet = 900, cx = 1 / 600, cy = 1 / 600, pointLight, updatePositions = [], vertexPositions = [], starNum = 30, degs = [], i = 0; 6 > i; i++) {
  var step = 120 * i - 30;
  degs.push(step)
}
var dis = 40,
  maxdis = dis * starNum,
  linePos = [],
  originalPos = [],
  flowerRadius = 400;
$(document).on({
  mouseenter: function() {
    var t = $(this).data("hv");
    uamouse = t
  },
  mouseleave: function() {
    uamouse = 100
  }
}, ".uanames li"), $(document).on({
  mouseenter: function() {
    var t = "#paths" + $(this).data("line");
    $(".paths.animate").children(t).attr({
      "class": "on"
    })
  },
  mouseleave: function() {
    $(".paths.animate").children().attr({
      "class": ""
    })
  }
}, ".click"), $(document).on("click", ".colorPanel", function(t) {
  t.preventDefault(), $html.addClass("openColor openLine"), setTimeout(function() {
    $html.addClass("opened")
  }, 1e3);
  var a = new TimelineLite;
  a.to($changeColorWrap, 1.5, {
    opacity: 1,
    ease: easeing
  })
}), $(document).on("click", ".changeColor", function(t) {
  t.preventDefault();
  var a = $(this).data("target");
  colorType = a, $html.addClass("switched"), setTimeout(function() {
    changeTheme(), checkTheme(), change3D(), setTimeout(function() {
      $html.removeClass("switched openLine");
      var t = new TimelineLite;
      t.to($changeColorWrap, 1, {
        opacity: 0,
        ease: easeing,
        onComplete: function() {
          $html.removeClass("openColor opened")
        }
      })
    }, 500)
  }, 500)
}), $(document).on({
  mouseenter: function() {
    var t = $(this);
    t.siblings().removeClass("on"), t.addClass("on");
    var a = new TimelineLite;
    a.to(t, .23, {
      backgroundColor: BTNCOLOR[0],
      ease: Bounce.easeOut
    }), a.to(t, .5, {
      backgroundColor: BTNCOLOR[1],
      ease: Power4.easeOut
    })
  },
  mouseleave: function() {
    $(this)
  }
}, ".btn"), $(document).on({
  mousemove: function(t) {
    mouseX = t.pageX, mouseY = t.pageY;
    var a = mouseX - windowWidthHalf,
      e = mouseY - windowHeightHalf,
      o = mouseX / windowWidth * 100,
      i = mouseY / windowHeight * 100,
      r = 180 * Math.atan2(a, -e) / Math.PI;
    0 > r && (r = 360 - Math.abs(r)), 345 > r && r > 15 ? TweenMax.to(mouseStatus, 1, {
      deg: r,
      ease: Power4.easeOut
    }) : TweenMax.to(mouseStatus, 0, {
      deg: r,
      ease: Power4.easeOut
    }), TweenMax.to(mouseStatus, 1, {
      x: mouseX,
      y: mouseY,
      cx: a,
      cy: e,
      px: o,
      py: i,
      ease: Power4.easeOut
    }), threeFlag && TweenLite.to(pointLight.position, 1, {
      x: -a,
      y: -e
    })
  }
}), $(function() {
  $(".expand").find("path").pathReset(), $(".leftContent path,.rightContent path,.expand path").each(function(t) {
    var a = ($(this), this),
      e = a.getTotalLength();
    $(this).css({
      "stroke-dashoffset": e,
      "stroke-dasharray": e
    })
  }), richFlag && ($(".hide").each(function(t, a) {
    var e = $(this),
      o = 2 * Math.random();
    e.css({
      "transition-delay": o + "s"
    })
  }), $(".hidechild").children().each(function(t, a) {
    var e = $(this),
      o = 2 * Math.random();
    e.css({
      "transition-delay": o + "s"
    })
  }));
  var t = 0,
    a = 0;
  setTimeout(function() {
    clearInterval(loaderInt), loaderInt = setInterval(function() {
      $progress_bar.css({
        width: a + "%"
      }), $progress_num.text(a), 100 > t ? (a = t, t += 6) : ajax && loadFlag ? a = 99 : (loadedAnimate(), clearInterval(loaderInt))
    }, 30), $(".expand").addClass("on")
  }, 1200)
});
var loaderInt;
$(window).on("load", function() {
  $weather = $(".weather"), loadFlag = !0, $html.addClass("loaded"), $all.addClass("showsplash"), changeTheme(), change3D();
  var t = 35.6886177,
    a = 139.6745768;
  $.ajax({
    type: "GET",
    url: "http://api.openweathermap.org/data/2.5/weather?lat=" + t + "&lon=" + a,
    dataType: "jsonp",
    jsonpCallback: "android",
    success: function(t) {
      var a = t.weather[0].id,
        e = Math.floor(a / 100);
      2 === e ? Weather = 8 : 3 === e ? Weather = 4 : 5 === e ? 500 === a ? Weather = 4 : Weather = 5 : 6 === e ? Weather = 6 : 7 === e ? Weather = 3 : 8 === e ? 800 === a ? Weather = 1 : 801 === e ? Weather = 2 : Weather = 7 : Weather = 9, $weather.text(Weather), $weather.addClass("on")
    },
    error: function(t, a, e) {
      $weather.text(9), $weather.addClass("on")
    },
    complete: function(t) {}
  })
}), $.fn.pathReset = function(t) {
  var a = this;
  a.each(function(t) {
    var a = $(this),
      e = this,
      o = e.getTotalLength();
    a.css({
      "transition-delay": t / 20 + "s",
      "stroke-dashoffset": o,
      "stroke-dasharray": o
    })
  })
};
var timer = !1;
$(window).resize(function() {
  timer !== !1 && clearTimeout(timer), timer = setTimeout(function() {
    setSize(), subpageFlag || (setSize2D(), pvRatioAnimateFlag && $graphic.length && initRectXY())
  }, 1e3)
}), $(window).on("load", function() {
  $.ajax({
    type: "GET",
    url: "http://www.newstech.jp/ga/active.php",
    cache: !1,
    dataType: "json",
    success: function(t) {
      activeUser = Number(t["rt:activeUsers"]), countActive()
    },
    error: function(t, a, e) {
      activeUser && (activeUser = "-"), countActive()
    },
    complete: function(t) {}
  })
}), $(document).on("click", ".toggle", function(t) {
  t.preventDefault(), $html.toggleClass("navopend")
}), $(document).on("click", ".openshare_fb", function(t) {
  t.preventDefault();
  var a = ($("title").text(), encodeURI(location.href)),
    e = "http://www.facebook.com/share.php?u=" + a;
  window.open(e, "facebook", "width=650, height=450, menubar=no, toolbar=no, scrollbars=yes")
}), $(document).on("click", ".openshare_tw", function(t) {
  t.preventDefault();
  var a = ($("title").text(), encodeURI(location.href)),
    e = "http://twitter.com/share?count=horizontal&amp;original_referer=" + a + "&amp;text=&amp;";
  window.open(e, "twitter", "width=650, height=450, menubar=no, toolbar=no, scrollbars=yes")
}), $(document).on("click", ".openshare_gg", function(t) {
  t.preventDefault();
  var a = ($("title").text(), encodeURI(location.href)),
    e = "https://plus.google.com/share?url=" + a;
  window.open(e, "googleplus", "width=650, height=450, menubar=no, toolbar=no, scrollbars=yes")
}), $(function() {
  subpageFlag && initSubpage()
}), $(window).on("load", function() {
  $(".slidecontain").bgSlideCover({
    size: "contain"
  }), $(".contain").bgCover({
    size: "contain"
  }), $(".cover").bgCover({
    size: "cover"
  }), $(".product").addClass("on"), $(".slideWrap").addClass("on")
}), $.fn.bgCover = function(t) {
  var a = this;
  a.each(function(a, e) {
    var o = $(this),
      i = o.data("src");
    o.css({
      "background-image": "url(" + i + ")",
      "background-repeat": "no-repeat",
      "background-position": "center",
      "background-size": t.size
    })
  })
}, $.fn.bgSlideCover = function(t) {
  var a = this;
  a.each(function(a, e) {
    var o = $(this);
    if ("COLORFUL" === colorType) var i = "_b.png";
    else if ("STAR" === colorType) var i = "_c.png";
    else var i = ".png";
    var r = o.data("src") + i;
    o.css({
      "background-image": "url(" + r + ")",
      "background-repeat": "no-repeat",
      "background-position": "center",
      "background-size": t.size
    })
  })
}, $(document).on("click", ".slideNav a", function(t) {
  t.preventDefault(), $(this).siblings().removeClass("on"), $(this).addClass("on");
  var a = Number($(this).data("num")),
    e = $(this).parents(".slideWrap").find(".slideBd").children();
  e.removeClass("on"), e.eq(a).addClass("on")
}), $(document).on("change", 'input[type="checkbox"]', function() {
  $(this).is(":checked") ? $(this).parents("label").addClass("chenged") : $(this).parents("label").removeClass("chenged")
}), /touch|tablet|mobile|phone|android|iphone|ipad|blackberry/i.test(window.navigator.userAgent) || ($.preload({
  forward: $.pjax.follow,
  check: $.pjax.getCache,
  encode: !0,
  ajax: {
    success: function(t, a, e) {
      !$.pjax.getCache(this.url) && $.pjax.setCache(this.url, null, a, e)
    }
  }
}), $.pjax({
  area: ".loadinner",
  link: "a.link,.post,.entrybtn,.wp-pagenavi a",
  load: {
    head: "base, meta, link",
    css: !0,
    script: !0
  },
  cache: {
    click: !0,
    submit: !1,
    popstate: !0
  },
  wait: 300,
  speedcheck: !1
}), $(document).bind("pjax:fetch", function() {
  window.cancelAnimationFrame(renderAudioInt), window.cancelAnimationFrame(renderAboutInt), window.cancelAnimationFrame(render3DInt), window.cancelAnimationFrame(render2DInt), $html.addClass("fetch")
}), $(document).bind("pjax:ready", function() {
  window.cancelAnimationFrame(renderAudioInt), window.cancelAnimationFrame(renderAboutInt), window.cancelAnimationFrame(render3DInt), window.cancelAnimationFrame(render2DInt), init(), subpageFlag ? (initSubpage(), $(".slidecontain").bgSlideCover({
    size: "contain"
  }), $(".contain").bgCover({
    size: "contain"
  }), $(".cover").bgCover({
    size: "cover"
  }), $(".slideWrap").addClass("on"), setTimeout(function() {
    $(".product").addClass("on")
  }, 1e3), renderAV(), setTimeout(function() {
    $html.removeClass("fetch")
  }, 600)) : setTimeout(function() {
    !spFlag && webGL && (setSize3D(), render3D()), loadPageview(), setSize2D(), initUA(), render2D(), change3D(), countActive(), richFlag ? setTimeout(function() {
      $html.removeClass("fetch")
    }, 500) : setTimeout(function() {
      $html.removeClass("fetch")
    }, 1500)
  }, 1e3), setTimeout(function() {
    $(document).trigger("preload")
  }, 2e3)
})), $(document).on("click", ".click", function(t) {
  t.preventDefault();
  var a = $(this).data("url");
  location.href = a
});